/home/matt/.uecide/compilers/pic32-gcc/bin/pic32-objdump -h -S /tmp/build-65e5bee8-31cd-447d-bed0-9e6ad2f593f3/RAMtest.elf 

/tmp/build-65e5bee8-31cd-447d-bed0-9e6ad2f593f3/RAMtest.elf:     file format elf32-tradlittlemips

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00000010  9d001000  9d001000  00011000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .image_ptr_table 00000008  9d0000f8  9d0000f8  000100f8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .app_excpt    00000010  9d000180  9d000180  00010180  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .vector_0     00000014  9d000200  9d000200  00010200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .vector_1     00000014  9d000220  9d000220  00010220  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .vector_2     00000014  9d000240  9d000240  00010240  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .vector_3     00000014  9d000260  9d000260  00010260  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .vector_4     00000014  9d000280  9d000280  00010280  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .vector_5     00000014  9d0002a0  9d0002a0  000102a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .vector_6     00000014  9d0002c0  9d0002c0  000102c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .vector_7     00000014  9d0002e0  9d0002e0  000102e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .vector_8     00000014  9d000300  9d000300  00010300  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .vector_9     00000014  9d000320  9d000320  00010320  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .vector_10    00000014  9d000340  9d000340  00010340  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .vector_11    00000014  9d000360  9d000360  00010360  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .vector_12    00000014  9d000380  9d000380  00010380  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .vector_13    00000014  9d0003a0  9d0003a0  000103a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .vector_14    00000014  9d0003c0  9d0003c0  000103c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .vector_15    00000014  9d0003e0  9d0003e0  000103e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .vector_16    00000014  9d000400  9d000400  00010400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .vector_17    00000014  9d000420  9d000420  00010420  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 21 .vector_18    00000014  9d000440  9d000440  00010440  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .vector_19    00000014  9d000460  9d000460  00010460  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .vector_20    00000014  9d000480  9d000480  00010480  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 24 .vector_21    00000014  9d0004a0  9d0004a0  000104a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 25 .vector_22    00000014  9d0004c0  9d0004c0  000104c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 26 .vector_23    00000014  9d0004e0  9d0004e0  000104e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 27 .vector_24    00000014  9d000500  9d000500  00010500  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 28 .vector_25    00000014  9d000520  9d000520  00010520  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 29 .vector_26    00000014  9d000540  9d000540  00010540  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 30 .vector_27    00000014  9d000560  9d000560  00010560  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .vector_28    00000014  9d000580  9d000580  00010580  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 32 .vector_29    00000014  9d0005a0  9d0005a0  000105a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .vector_30    00000014  9d0005c0  9d0005c0  000105c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 34 .vector_31    00000014  9d0005e0  9d0005e0  000105e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 35 .vector_32    00000014  9d000600  9d000600  00010600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 36 .vector_33    00000014  9d000620  9d000620  00010620  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 37 .vector_34    00000014  9d000640  9d000640  00010640  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 38 .vector_35    00000014  9d000660  9d000660  00010660  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 39 .vector_36    00000014  9d000680  9d000680  00010680  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 40 .vector_37    00000014  9d0006a0  9d0006a0  000106a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 41 .vector_38    00000014  9d0006c0  9d0006c0  000106c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 42 .vector_39    00000014  9d0006e0  9d0006e0  000106e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 43 .vector_40    00000014  9d000700  9d000700  00010700  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 44 .vector_41    00000014  9d000720  9d000720  00010720  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 45 .vector_42    00000014  9d000740  9d000740  00010740  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 46 .vector_43    00000014  9d000760  9d000760  00010760  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 47 .vector_44    00000014  9d000780  9d000780  00010780  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 48 .vector_45    00000014  9d0007a0  9d0007a0  000107a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 49 .vector_46    00000014  9d0007c0  9d0007c0  000107c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 50 .vector_47    00000014  9d0007e0  9d0007e0  000107e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 51 .vector_48    00000014  9d000800  9d000800  00010800  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 52 .vector_49    00000014  9d000820  9d000820  00010820  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 53 .vector_50    00000014  9d000840  9d000840  00010840  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 54 .vector_51    00000014  9d000860  9d000860  00010860  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 55 .vector_52    00000014  9d000880  9d000880  00010880  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 56 .vector_53    00000014  9d0008a0  9d0008a0  000108a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 57 .vector_54    00000014  9d0008c0  9d0008c0  000108c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 58 .vector_55    00000014  9d0008e0  9d0008e0  000108e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 59 .vector_56    00000014  9d000900  9d000900  00010900  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 60 .vector_57    00000014  9d000920  9d000920  00010920  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 61 .vector_58    00000014  9d000940  9d000940  00010940  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 62 .vector_59    00000014  9d000960  9d000960  00010960  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 63 .vector_60    00000014  9d000980  9d000980  00010980  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 64 .vector_61    00000014  9d0009a0  9d0009a0  000109a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 65 .vector_62    00000014  9d0009c0  9d0009c0  000109c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 66 .vector_63    00000014  9d0009e0  9d0009e0  000109e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 67 .startup      000001e0  9d001010  9d001010  00011010  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 68 .text         00005274  9d0011f0  9d0011f0  000111f0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 69 .init         00000024  9d006464  9d006464  00016464  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 70 .fini         0000001c  9d006488  9d006488  00016488  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 71 .ctors        00000010  9d0064a4  9d0064a4  000164a4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 72 .dtors        00000008  9d0064b4  9d0064b4  000164b4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 73 .header_info  0000004c  9d0064bc  9d0064bc  000164bc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 74 .ram_exchange_data 00000008  a0000000  a0000000  00022000  2**0
                  CONTENTS
 75 .rodata       000003cc  9d006508  9d006508  00016508  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 76 .data         000004e8  a0000008  9d0068d4  00020008  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 77 .sdata        00000008  a00004f0  9d006dbc  000204f0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 78 .sbss         0000002c  a00004f8  9d006dc4  000204f8  2**2
                  ALLOC
 79 .bss          0000055c  a0000524  9d006dc4  00020524  2**2
                  ALLOC
 80 .heap         00000800  a0000a80  9d006dc4  00020a80  2**0
                  ALLOC
 81 .stack        00000800  a0001280  9d006dc4  00021280  2**0
                  ALLOC
 82 .comment      00000095  00000000  00000000  00022008  2**0
                  CONTENTS, READONLY
 83 .debug_aranges 000015a8  00000000  00000000  000220a0  2**3
                  CONTENTS, READONLY, DEBUGGING
 84 .debug_pubnames 000020e6  00000000  00000000  00023648  2**0
                  CONTENTS, READONLY, DEBUGGING
 85 .debug_info   0002f017  00000000  00000000  0002572e  2**0
                  CONTENTS, READONLY, DEBUGGING
 86 .debug_abbrev 00008ef9  00000000  00000000  00054745  2**0
                  CONTENTS, READONLY, DEBUGGING
 87 .debug_line   0000d434  00000000  00000000  0005d63e  2**0
                  CONTENTS, READONLY, DEBUGGING
 88 .debug_frame  000026ec  00000000  00000000  0006aa74  2**2
                  CONTENTS, READONLY, DEBUGGING
 89 .debug_str    00006161  00000000  00000000  0006d160  2**0
                  CONTENTS, READONLY, DEBUGGING
 90 .debug_loc    0001e15b  00000000  00000000  000732c1  2**0
                  CONTENTS, READONLY, DEBUGGING
 91 .debug_pubtypes 00002fd1  00000000  00000000  0009141c  2**0
                  CONTENTS, READONLY, DEBUGGING
 92 .debug_ranges 00003fb0  00000000  00000000  000943f0  2**3
                  CONTENTS, READONLY, DEBUGGING
 93 .gnu.attributes 00000010  00000000  00000000  000983a0  2**0
                  CONTENTS, READONLY
 94 .mdebug.abi32 00000000  a0002000  a0002000  00022000  2**0
                  CONTENTS, ALLOC, LOAD, DATA

Disassembly of section .reset:

9d001000 <_reset>:
9d001000:	3c1a9d00 	lui	k0,0x9d00
9d001004:	275a1010 	addiu	k0,k0,4112
9d001008:	03400008 	jr	k0
9d00100c:	00000000 	nop

Disassembly of section .app_excpt:

9d000180 <_gen_exception>:
9d000180:	3c1a9d00 	lui	k0,0x9d00
9d000184:	275a6310 	addiu	k0,k0,25360
9d000188:	03400008 	jr	k0
9d00018c:	00000000 	nop

Disassembly of section .vector_0:

9d000200 <__vector_0>:
    lw       k0,4 * number (k0); \
    jr       k0; \
    .end VECTOR_SYMBOLNAME(number); \
    .size VECTOR_SYMBOLNAME(number), .-VECTOR_SYMBOLNAME(number);

 VECTOR_ENTRY(0)
9d000200:	3c1aa000 	lui	k0,0xa000
9d000204:	275a0020 	addiu	k0,k0,32
9d000208:	8f5a0000 	lw	k0,0(k0)
9d00020c:	03400008 	jr	k0
9d000210:	00000000 	nop

Disassembly of section .vector_1:

9d000220 <__vector_1>:
 VECTOR_ENTRY(1)
9d000220:	3c1aa000 	lui	k0,0xa000
9d000224:	275a0020 	addiu	k0,k0,32
9d000228:	8f5a0004 	lw	k0,4(k0)
9d00022c:	03400008 	jr	k0
9d000230:	00000000 	nop

Disassembly of section .vector_2:

9d000240 <__vector_2>:
 VECTOR_ENTRY(2)
9d000240:	3c1aa000 	lui	k0,0xa000
9d000244:	275a0020 	addiu	k0,k0,32
9d000248:	8f5a0008 	lw	k0,8(k0)
9d00024c:	03400008 	jr	k0
9d000250:	00000000 	nop

Disassembly of section .vector_3:

9d000260 <__vector_3>:
 VECTOR_ENTRY(3)
9d000260:	3c1aa000 	lui	k0,0xa000
9d000264:	275a0020 	addiu	k0,k0,32
9d000268:	8f5a000c 	lw	k0,12(k0)
9d00026c:	03400008 	jr	k0
9d000270:	00000000 	nop

Disassembly of section .vector_4:

9d000280 <__vector_4>:
 VECTOR_ENTRY(4)
9d000280:	3c1aa000 	lui	k0,0xa000
9d000284:	275a0020 	addiu	k0,k0,32
9d000288:	8f5a0010 	lw	k0,16(k0)
9d00028c:	03400008 	jr	k0
9d000290:	00000000 	nop

Disassembly of section .vector_5:

9d0002a0 <__vector_5>:
 VECTOR_ENTRY(5)
9d0002a0:	3c1aa000 	lui	k0,0xa000
9d0002a4:	275a0020 	addiu	k0,k0,32
9d0002a8:	8f5a0014 	lw	k0,20(k0)
9d0002ac:	03400008 	jr	k0
9d0002b0:	00000000 	nop

Disassembly of section .vector_6:

9d0002c0 <__vector_6>:
 VECTOR_ENTRY(6)
9d0002c0:	3c1aa000 	lui	k0,0xa000
9d0002c4:	275a0020 	addiu	k0,k0,32
9d0002c8:	8f5a0018 	lw	k0,24(k0)
9d0002cc:	03400008 	jr	k0
9d0002d0:	00000000 	nop

Disassembly of section .vector_7:

9d0002e0 <__vector_7>:
 VECTOR_ENTRY(7)
9d0002e0:	3c1aa000 	lui	k0,0xa000
9d0002e4:	275a0020 	addiu	k0,k0,32
9d0002e8:	8f5a001c 	lw	k0,28(k0)
9d0002ec:	03400008 	jr	k0
9d0002f0:	00000000 	nop

Disassembly of section .vector_8:

9d000300 <__vector_8>:
 VECTOR_ENTRY(8)
9d000300:	3c1aa000 	lui	k0,0xa000
9d000304:	275a0020 	addiu	k0,k0,32
9d000308:	8f5a0020 	lw	k0,32(k0)
9d00030c:	03400008 	jr	k0
9d000310:	00000000 	nop

Disassembly of section .vector_9:

9d000320 <__vector_9>:
 VECTOR_ENTRY(9)
9d000320:	3c1aa000 	lui	k0,0xa000
9d000324:	275a0020 	addiu	k0,k0,32
9d000328:	8f5a0024 	lw	k0,36(k0)
9d00032c:	03400008 	jr	k0
9d000330:	00000000 	nop

Disassembly of section .vector_10:

9d000340 <__vector_10>:
 VECTOR_ENTRY(10)
9d000340:	3c1aa000 	lui	k0,0xa000
9d000344:	275a0020 	addiu	k0,k0,32
9d000348:	8f5a0028 	lw	k0,40(k0)
9d00034c:	03400008 	jr	k0
9d000350:	00000000 	nop

Disassembly of section .vector_11:

9d000360 <__vector_11>:
 VECTOR_ENTRY(11)
9d000360:	3c1aa000 	lui	k0,0xa000
9d000364:	275a0020 	addiu	k0,k0,32
9d000368:	8f5a002c 	lw	k0,44(k0)
9d00036c:	03400008 	jr	k0
9d000370:	00000000 	nop

Disassembly of section .vector_12:

9d000380 <__vector_12>:
 VECTOR_ENTRY(12)
9d000380:	3c1aa000 	lui	k0,0xa000
9d000384:	275a0020 	addiu	k0,k0,32
9d000388:	8f5a0030 	lw	k0,48(k0)
9d00038c:	03400008 	jr	k0
9d000390:	00000000 	nop

Disassembly of section .vector_13:

9d0003a0 <__vector_13>:
 VECTOR_ENTRY(13)
9d0003a0:	3c1aa000 	lui	k0,0xa000
9d0003a4:	275a0020 	addiu	k0,k0,32
9d0003a8:	8f5a0034 	lw	k0,52(k0)
9d0003ac:	03400008 	jr	k0
9d0003b0:	00000000 	nop

Disassembly of section .vector_14:

9d0003c0 <__vector_14>:
 VECTOR_ENTRY(14)
9d0003c0:	3c1aa000 	lui	k0,0xa000
9d0003c4:	275a0020 	addiu	k0,k0,32
9d0003c8:	8f5a0038 	lw	k0,56(k0)
9d0003cc:	03400008 	jr	k0
9d0003d0:	00000000 	nop

Disassembly of section .vector_15:

9d0003e0 <__vector_15>:
 VECTOR_ENTRY(15)
9d0003e0:	3c1aa000 	lui	k0,0xa000
9d0003e4:	275a0020 	addiu	k0,k0,32
9d0003e8:	8f5a003c 	lw	k0,60(k0)
9d0003ec:	03400008 	jr	k0
9d0003f0:	00000000 	nop

Disassembly of section .vector_16:

9d000400 <__vector_16>:
 VECTOR_ENTRY(16)
9d000400:	3c1aa000 	lui	k0,0xa000
9d000404:	275a0020 	addiu	k0,k0,32
9d000408:	8f5a0040 	lw	k0,64(k0)
9d00040c:	03400008 	jr	k0
9d000410:	00000000 	nop

Disassembly of section .vector_17:

9d000420 <__vector_17>:
 VECTOR_ENTRY(17)
9d000420:	3c1aa000 	lui	k0,0xa000
9d000424:	275a0020 	addiu	k0,k0,32
9d000428:	8f5a0044 	lw	k0,68(k0)
9d00042c:	03400008 	jr	k0
9d000430:	00000000 	nop

Disassembly of section .vector_18:

9d000440 <__vector_18>:
 VECTOR_ENTRY(18)
9d000440:	3c1aa000 	lui	k0,0xa000
9d000444:	275a0020 	addiu	k0,k0,32
9d000448:	8f5a0048 	lw	k0,72(k0)
9d00044c:	03400008 	jr	k0
9d000450:	00000000 	nop

Disassembly of section .vector_19:

9d000460 <__vector_19>:
 VECTOR_ENTRY(19)
9d000460:	3c1aa000 	lui	k0,0xa000
9d000464:	275a0020 	addiu	k0,k0,32
9d000468:	8f5a004c 	lw	k0,76(k0)
9d00046c:	03400008 	jr	k0
9d000470:	00000000 	nop

Disassembly of section .vector_20:

9d000480 <__vector_20>:
 VECTOR_ENTRY(20)
9d000480:	3c1aa000 	lui	k0,0xa000
9d000484:	275a0020 	addiu	k0,k0,32
9d000488:	8f5a0050 	lw	k0,80(k0)
9d00048c:	03400008 	jr	k0
9d000490:	00000000 	nop

Disassembly of section .vector_21:

9d0004a0 <__vector_21>:
 VECTOR_ENTRY(21)
9d0004a0:	3c1aa000 	lui	k0,0xa000
9d0004a4:	275a0020 	addiu	k0,k0,32
9d0004a8:	8f5a0054 	lw	k0,84(k0)
9d0004ac:	03400008 	jr	k0
9d0004b0:	00000000 	nop

Disassembly of section .vector_22:

9d0004c0 <__vector_22>:
 VECTOR_ENTRY(22)
9d0004c0:	3c1aa000 	lui	k0,0xa000
9d0004c4:	275a0020 	addiu	k0,k0,32
9d0004c8:	8f5a0058 	lw	k0,88(k0)
9d0004cc:	03400008 	jr	k0
9d0004d0:	00000000 	nop

Disassembly of section .vector_23:

9d0004e0 <__vector_23>:
 VECTOR_ENTRY(23)
9d0004e0:	3c1aa000 	lui	k0,0xa000
9d0004e4:	275a0020 	addiu	k0,k0,32
9d0004e8:	8f5a005c 	lw	k0,92(k0)
9d0004ec:	03400008 	jr	k0
9d0004f0:	00000000 	nop

Disassembly of section .vector_24:

9d000500 <__vector_24>:
 VECTOR_ENTRY(24)
9d000500:	3c1aa000 	lui	k0,0xa000
9d000504:	275a0020 	addiu	k0,k0,32
9d000508:	8f5a0060 	lw	k0,96(k0)
9d00050c:	03400008 	jr	k0
9d000510:	00000000 	nop

Disassembly of section .vector_25:

9d000520 <__vector_25>:
 VECTOR_ENTRY(25)
9d000520:	3c1aa000 	lui	k0,0xa000
9d000524:	275a0020 	addiu	k0,k0,32
9d000528:	8f5a0064 	lw	k0,100(k0)
9d00052c:	03400008 	jr	k0
9d000530:	00000000 	nop

Disassembly of section .vector_26:

9d000540 <__vector_26>:
 VECTOR_ENTRY(26)
9d000540:	3c1aa000 	lui	k0,0xa000
9d000544:	275a0020 	addiu	k0,k0,32
9d000548:	8f5a0068 	lw	k0,104(k0)
9d00054c:	03400008 	jr	k0
9d000550:	00000000 	nop

Disassembly of section .vector_27:

9d000560 <__vector_27>:
 VECTOR_ENTRY(27)
9d000560:	3c1aa000 	lui	k0,0xa000
9d000564:	275a0020 	addiu	k0,k0,32
9d000568:	8f5a006c 	lw	k0,108(k0)
9d00056c:	03400008 	jr	k0
9d000570:	00000000 	nop

Disassembly of section .vector_28:

9d000580 <__vector_28>:
 VECTOR_ENTRY(28)
9d000580:	3c1aa000 	lui	k0,0xa000
9d000584:	275a0020 	addiu	k0,k0,32
9d000588:	8f5a0070 	lw	k0,112(k0)
9d00058c:	03400008 	jr	k0
9d000590:	00000000 	nop

Disassembly of section .vector_29:

9d0005a0 <__vector_29>:
 VECTOR_ENTRY(29)
9d0005a0:	3c1aa000 	lui	k0,0xa000
9d0005a4:	275a0020 	addiu	k0,k0,32
9d0005a8:	8f5a0074 	lw	k0,116(k0)
9d0005ac:	03400008 	jr	k0
9d0005b0:	00000000 	nop

Disassembly of section .vector_30:

9d0005c0 <__vector_30>:
 VECTOR_ENTRY(30)
9d0005c0:	3c1aa000 	lui	k0,0xa000
9d0005c4:	275a0020 	addiu	k0,k0,32
9d0005c8:	8f5a0078 	lw	k0,120(k0)
9d0005cc:	03400008 	jr	k0
9d0005d0:	00000000 	nop

Disassembly of section .vector_31:

9d0005e0 <__vector_31>:
 VECTOR_ENTRY(31)
9d0005e0:	3c1aa000 	lui	k0,0xa000
9d0005e4:	275a0020 	addiu	k0,k0,32
9d0005e8:	8f5a007c 	lw	k0,124(k0)
9d0005ec:	03400008 	jr	k0
9d0005f0:	00000000 	nop

Disassembly of section .vector_32:

9d000600 <__vector_32>:
 VECTOR_ENTRY(32)
9d000600:	3c1aa000 	lui	k0,0xa000
9d000604:	275a0020 	addiu	k0,k0,32
9d000608:	8f5a0080 	lw	k0,128(k0)
9d00060c:	03400008 	jr	k0
9d000610:	00000000 	nop

Disassembly of section .vector_33:

9d000620 <__vector_33>:
 VECTOR_ENTRY(33)
9d000620:	3c1aa000 	lui	k0,0xa000
9d000624:	275a0020 	addiu	k0,k0,32
9d000628:	8f5a0084 	lw	k0,132(k0)
9d00062c:	03400008 	jr	k0
9d000630:	00000000 	nop

Disassembly of section .vector_34:

9d000640 <__vector_34>:
 VECTOR_ENTRY(34)
9d000640:	3c1aa000 	lui	k0,0xa000
9d000644:	275a0020 	addiu	k0,k0,32
9d000648:	8f5a0088 	lw	k0,136(k0)
9d00064c:	03400008 	jr	k0
9d000650:	00000000 	nop

Disassembly of section .vector_35:

9d000660 <__vector_35>:
 VECTOR_ENTRY(35)
9d000660:	3c1aa000 	lui	k0,0xa000
9d000664:	275a0020 	addiu	k0,k0,32
9d000668:	8f5a008c 	lw	k0,140(k0)
9d00066c:	03400008 	jr	k0
9d000670:	00000000 	nop

Disassembly of section .vector_36:

9d000680 <__vector_36>:
 VECTOR_ENTRY(36)
9d000680:	3c1aa000 	lui	k0,0xa000
9d000684:	275a0020 	addiu	k0,k0,32
9d000688:	8f5a0090 	lw	k0,144(k0)
9d00068c:	03400008 	jr	k0
9d000690:	00000000 	nop

Disassembly of section .vector_37:

9d0006a0 <__vector_37>:
 VECTOR_ENTRY(37)
9d0006a0:	3c1aa000 	lui	k0,0xa000
9d0006a4:	275a0020 	addiu	k0,k0,32
9d0006a8:	8f5a0094 	lw	k0,148(k0)
9d0006ac:	03400008 	jr	k0
9d0006b0:	00000000 	nop

Disassembly of section .vector_38:

9d0006c0 <__vector_38>:
 VECTOR_ENTRY(38)
9d0006c0:	3c1aa000 	lui	k0,0xa000
9d0006c4:	275a0020 	addiu	k0,k0,32
9d0006c8:	8f5a0098 	lw	k0,152(k0)
9d0006cc:	03400008 	jr	k0
9d0006d0:	00000000 	nop

Disassembly of section .vector_39:

9d0006e0 <__vector_39>:
 VECTOR_ENTRY(39)
9d0006e0:	3c1aa000 	lui	k0,0xa000
9d0006e4:	275a0020 	addiu	k0,k0,32
9d0006e8:	8f5a009c 	lw	k0,156(k0)
9d0006ec:	03400008 	jr	k0
9d0006f0:	00000000 	nop

Disassembly of section .vector_40:

9d000700 <__vector_40>:
 VECTOR_ENTRY(40)
9d000700:	3c1aa000 	lui	k0,0xa000
9d000704:	275a0020 	addiu	k0,k0,32
9d000708:	8f5a00a0 	lw	k0,160(k0)
9d00070c:	03400008 	jr	k0
9d000710:	00000000 	nop

Disassembly of section .vector_41:

9d000720 <__vector_41>:
 VECTOR_ENTRY(41)
9d000720:	3c1aa000 	lui	k0,0xa000
9d000724:	275a0020 	addiu	k0,k0,32
9d000728:	8f5a00a4 	lw	k0,164(k0)
9d00072c:	03400008 	jr	k0
9d000730:	00000000 	nop

Disassembly of section .vector_42:

9d000740 <__vector_42>:
 VECTOR_ENTRY(42)
9d000740:	3c1aa000 	lui	k0,0xa000
9d000744:	275a0020 	addiu	k0,k0,32
9d000748:	8f5a00a8 	lw	k0,168(k0)
9d00074c:	03400008 	jr	k0
9d000750:	00000000 	nop

Disassembly of section .vector_43:

9d000760 <__vector_43>:
 VECTOR_ENTRY(43)
9d000760:	3c1aa000 	lui	k0,0xa000
9d000764:	275a0020 	addiu	k0,k0,32
9d000768:	8f5a00ac 	lw	k0,172(k0)
9d00076c:	03400008 	jr	k0
9d000770:	00000000 	nop

Disassembly of section .vector_44:

9d000780 <__vector_44>:
 VECTOR_ENTRY(44)
9d000780:	3c1aa000 	lui	k0,0xa000
9d000784:	275a0020 	addiu	k0,k0,32
9d000788:	8f5a00b0 	lw	k0,176(k0)
9d00078c:	03400008 	jr	k0
9d000790:	00000000 	nop

Disassembly of section .vector_45:

9d0007a0 <__vector_45>:
 VECTOR_ENTRY(45)
9d0007a0:	3c1aa000 	lui	k0,0xa000
9d0007a4:	275a0020 	addiu	k0,k0,32
9d0007a8:	8f5a00b4 	lw	k0,180(k0)
9d0007ac:	03400008 	jr	k0
9d0007b0:	00000000 	nop

Disassembly of section .vector_46:

9d0007c0 <__vector_46>:
 VECTOR_ENTRY(46)
9d0007c0:	3c1aa000 	lui	k0,0xa000
9d0007c4:	275a0020 	addiu	k0,k0,32
9d0007c8:	8f5a00b8 	lw	k0,184(k0)
9d0007cc:	03400008 	jr	k0
9d0007d0:	00000000 	nop

Disassembly of section .vector_47:

9d0007e0 <__vector_47>:
 VECTOR_ENTRY(47)
9d0007e0:	3c1aa000 	lui	k0,0xa000
9d0007e4:	275a0020 	addiu	k0,k0,32
9d0007e8:	8f5a00bc 	lw	k0,188(k0)
9d0007ec:	03400008 	jr	k0
9d0007f0:	00000000 	nop

Disassembly of section .vector_48:

9d000800 <__vector_48>:
 VECTOR_ENTRY(48)
9d000800:	3c1aa000 	lui	k0,0xa000
9d000804:	275a0020 	addiu	k0,k0,32
9d000808:	8f5a00c0 	lw	k0,192(k0)
9d00080c:	03400008 	jr	k0
9d000810:	00000000 	nop

Disassembly of section .vector_49:

9d000820 <__vector_49>:
 VECTOR_ENTRY(49)
9d000820:	3c1aa000 	lui	k0,0xa000
9d000824:	275a0020 	addiu	k0,k0,32
9d000828:	8f5a00c4 	lw	k0,196(k0)
9d00082c:	03400008 	jr	k0
9d000830:	00000000 	nop

Disassembly of section .vector_50:

9d000840 <__vector_50>:
 VECTOR_ENTRY(50)
9d000840:	3c1aa000 	lui	k0,0xa000
9d000844:	275a0020 	addiu	k0,k0,32
9d000848:	8f5a00c8 	lw	k0,200(k0)
9d00084c:	03400008 	jr	k0
9d000850:	00000000 	nop

Disassembly of section .vector_51:

9d000860 <__vector_51>:
 VECTOR_ENTRY(51)
9d000860:	3c1aa000 	lui	k0,0xa000
9d000864:	275a0020 	addiu	k0,k0,32
9d000868:	8f5a00cc 	lw	k0,204(k0)
9d00086c:	03400008 	jr	k0
9d000870:	00000000 	nop

Disassembly of section .vector_52:

9d000880 <__vector_52>:
 VECTOR_ENTRY(52)
9d000880:	3c1aa000 	lui	k0,0xa000
9d000884:	275a0020 	addiu	k0,k0,32
9d000888:	8f5a00d0 	lw	k0,208(k0)
9d00088c:	03400008 	jr	k0
9d000890:	00000000 	nop

Disassembly of section .vector_53:

9d0008a0 <__vector_53>:
 VECTOR_ENTRY(53)
9d0008a0:	3c1aa000 	lui	k0,0xa000
9d0008a4:	275a0020 	addiu	k0,k0,32
9d0008a8:	8f5a00d4 	lw	k0,212(k0)
9d0008ac:	03400008 	jr	k0
9d0008b0:	00000000 	nop

Disassembly of section .vector_54:

9d0008c0 <__vector_54>:
 VECTOR_ENTRY(54)
9d0008c0:	3c1aa000 	lui	k0,0xa000
9d0008c4:	275a0020 	addiu	k0,k0,32
9d0008c8:	8f5a00d8 	lw	k0,216(k0)
9d0008cc:	03400008 	jr	k0
9d0008d0:	00000000 	nop

Disassembly of section .vector_55:

9d0008e0 <__vector_55>:
 VECTOR_ENTRY(55)
9d0008e0:	3c1aa000 	lui	k0,0xa000
9d0008e4:	275a0020 	addiu	k0,k0,32
9d0008e8:	8f5a00dc 	lw	k0,220(k0)
9d0008ec:	03400008 	jr	k0
9d0008f0:	00000000 	nop

Disassembly of section .vector_56:

9d000900 <__vector_56>:
 VECTOR_ENTRY(56)
9d000900:	3c1aa000 	lui	k0,0xa000
9d000904:	275a0020 	addiu	k0,k0,32
9d000908:	8f5a00e0 	lw	k0,224(k0)
9d00090c:	03400008 	jr	k0
9d000910:	00000000 	nop

Disassembly of section .vector_57:

9d000920 <__vector_57>:
 VECTOR_ENTRY(57)
9d000920:	3c1aa000 	lui	k0,0xa000
9d000924:	275a0020 	addiu	k0,k0,32
9d000928:	8f5a00e4 	lw	k0,228(k0)
9d00092c:	03400008 	jr	k0
9d000930:	00000000 	nop

Disassembly of section .vector_58:

9d000940 <__vector_58>:
 VECTOR_ENTRY(58)
9d000940:	3c1aa000 	lui	k0,0xa000
9d000944:	275a0020 	addiu	k0,k0,32
9d000948:	8f5a00e8 	lw	k0,232(k0)
9d00094c:	03400008 	jr	k0
9d000950:	00000000 	nop

Disassembly of section .vector_59:

9d000960 <__vector_59>:
 VECTOR_ENTRY(59)
9d000960:	3c1aa000 	lui	k0,0xa000
9d000964:	275a0020 	addiu	k0,k0,32
9d000968:	8f5a00ec 	lw	k0,236(k0)
9d00096c:	03400008 	jr	k0
9d000970:	00000000 	nop

Disassembly of section .vector_60:

9d000980 <__vector_60>:
 VECTOR_ENTRY(60)
9d000980:	3c1aa000 	lui	k0,0xa000
9d000984:	275a0020 	addiu	k0,k0,32
9d000988:	8f5a00f0 	lw	k0,240(k0)
9d00098c:	03400008 	jr	k0
9d000990:	00000000 	nop

Disassembly of section .vector_61:

9d0009a0 <__vector_61>:
 VECTOR_ENTRY(61)
9d0009a0:	3c1aa000 	lui	k0,0xa000
9d0009a4:	275a0020 	addiu	k0,k0,32
9d0009a8:	8f5a00f4 	lw	k0,244(k0)
9d0009ac:	03400008 	jr	k0
9d0009b0:	00000000 	nop

Disassembly of section .vector_62:

9d0009c0 <__vector_62>:
 VECTOR_ENTRY(62)
9d0009c0:	3c1aa000 	lui	k0,0xa000
9d0009c4:	275a0020 	addiu	k0,k0,32
9d0009c8:	8f5a00f8 	lw	k0,248(k0)
9d0009cc:	03400008 	jr	k0
9d0009d0:	00000000 	nop

Disassembly of section .vector_63:

9d0009e0 <__vector_63>:
 VECTOR_ENTRY(63)
9d0009e0:	3c1aa000 	lui	k0,0xa000
9d0009e4:	275a0020 	addiu	k0,k0,32
9d0009e8:	8f5a00fc 	lw	k0,252(k0)
9d0009ec:	03400008 	jr	k0
9d0009f0:	00000000 	nop

Disassembly of section .startup:

9d001010 <_startup>:
9d001010:	401a6000 	mfc0	k0,c0_status
9d001014:	7f5a04c0 	ext	k0,k0,0x13,0x1
9d001018:	13400005 	beqz	k0,9d001030 <_no_nmi>
9d00101c:	00000000 	nop
9d001020:	3c1a9d00 	lui	k0,0x9d00
9d001024:	275a63f8 	addiu	k0,k0,25592
9d001028:	03400008 	jr	k0
9d00102c:	00000000 	nop

9d001030 <_no_nmi>:
9d001030:	3c1da000 	lui	sp,0xa000
9d001034:	27bd4000 	addiu	sp,sp,16384
9d001038:	3c1ca001 	lui	gp,0xa001
9d00103c:	279c84e0 	addiu	gp,gp,-31520
9d001040:	40096002 	mfc0	t1,c0_srsctl
9d001044:	01205820 	add	t3,t1,zero
9d001048:	7d2a1e80 	ext	t2,t1,0x1a,0x4
9d00104c:	7d494984 	ins	t1,t2,0x6,0x4
9d001050:	40896002 	mtc0	t1,c0_srsctl
9d001054:	41dce000 	wrpgpr	gp,gp
9d001058:	408b6002 	mtc0	t3,c0_srsctl
9d00105c:	3c089d00 	lui	t0,0x9d00
9d001060:	250863e8 	addiu	t0,t0,25576
9d001064:	0100f809 	jalr	t0
9d001068:	00000000 	nop
9d00106c:	3c08a000 	lui	t0,0xa000
9d001070:	250804f8 	addiu	t0,t0,1272
9d001074:	3c09a000 	lui	t1,0xa000
9d001078:	25290a80 	addiu	t1,t1,2688
9d00107c:	10000006 	b	9d001098 <_bss_check>
9d001080:	00000000 	nop

9d001084 <_bss_init>:
9d001084:	ad000000 	sw	zero,0(t0)
9d001088:	ad000004 	sw	zero,4(t0)
9d00108c:	ad000008 	sw	zero,8(t0)
9d001090:	ad00000c 	sw	zero,12(t0)
9d001094:	25080010 	addiu	t0,t0,16

9d001098 <_bss_check>:
9d001098:	0109082b 	sltu	at,t0,t1
9d00109c:	1420fff9 	bnez	at,9d001084 <_bss_init>
9d0010a0:	00000000 	nop
9d0010a4:	3c089d00 	lui	t0,0x9d00
9d0010a8:	250868d4 	addiu	t0,t0,26836
9d0010ac:	3c09a000 	lui	t1,0xa000
9d0010b0:	25290008 	addiu	t1,t1,8
9d0010b4:	3c0aa000 	lui	t2,0xa000
9d0010b8:	254a04f8 	addiu	t2,t2,1272
9d0010bc:	10000005 	b	9d0010d4 <_init_check>
9d0010c0:	00000000 	nop

9d0010c4 <_init_data>:
9d0010c4:	8d0b0000 	lw	t3,0(t0)
9d0010c8:	ad2b0000 	sw	t3,0(t1)
9d0010cc:	25080004 	addiu	t0,t0,4
9d0010d0:	25290004 	addiu	t1,t1,4

9d0010d4 <_init_check>:
9d0010d4:	012a082b 	sltu	at,t1,t2
9d0010d8:	1420fffa 	bnez	at,9d0010c4 <_init_data>
9d0010dc:	00000000 	nop
9d0010e0:	3c090000 	lui	t1,0x0
9d0010e4:	25290000 	addiu	t1,t1,0
9d0010e8:	1120001d 	beqz	t1,9d001160 <_ramfunc_done>
9d0010ec:	00000000 	nop
9d0010f0:	3c089d00 	lui	t0,0x9d00
9d0010f4:	25086dc4 	addiu	t0,t0,28100
9d0010f8:	3c09a000 	lui	t1,0xa000
9d0010fc:	25292000 	addiu	t1,t1,8192
9d001100:	3c0aa000 	lui	t2,0xa000
9d001104:	254a2000 	addiu	t2,t2,8192

9d001108 <_init_ramfunc>:
9d001108:	8d0b0000 	lw	t3,0(t0)
9d00110c:	ad2b0000 	sw	t3,0(t1)
9d001110:	25080004 	addiu	t0,t0,4
9d001114:	25290004 	addiu	t1,t1,4

9d001118 <_ramfunc_check>:
9d001118:	012a082b 	sltu	at,t1,t2
9d00111c:	1420fffa 	bnez	at,9d001108 <_init_ramfunc>
9d001120:	00000000 	nop
9d001124:	3c090000 	lui	t1,0x0
9d001128:	25292000 	addiu	t1,t1,8192
9d00112c:	3c0abf88 	lui	t2,0xbf88
9d001130:	254a2010 	addiu	t2,t2,8208
9d001134:	ad490000 	sw	t1,0(t2)
9d001138:	3c090000 	lui	t1,0x0
9d00113c:	25294000 	addiu	t1,t1,16384
9d001140:	3c0abf88 	lui	t2,0xbf88
9d001144:	254a2020 	addiu	t2,t2,8224
9d001148:	ad490000 	sw	t1,0(t2)
9d00114c:	3c090000 	lui	t1,0x0
9d001150:	25294000 	addiu	t1,t1,16384
9d001154:	3c0abf88 	lui	t2,0xbf88
9d001158:	254a2030 	addiu	t2,t2,8240
9d00115c:	ad490000 	sw	t1,0(t2)

9d001160 <_ramfunc_done>:
9d001160:	40804800 	mtc0	zero,c0_count
9d001164:	240affff 	li	t2,-1
9d001168:	408a5800 	mtc0	t2,c0_compare
9d00116c:	3c099d00 	lui	t1,0x9d00
9d001170:	25290000 	addiu	t1,t1,0
9d001174:	40897801 	mtc0	t1,c0_ebase
9d001178:	3c090000 	lui	t1,0x0
9d00117c:	25290001 	addiu	t1,t1,1
9d001180:	240a0000 	li	t2,0
9d001184:	7d2a4944 	ins	t2,t1,0x5,0x5
9d001188:	408a6001 	mtc0	t2,c0_intctl
9d00118c:	3c090080 	lui	t1,0x80
9d001190:	40896800 	mtc0	t1,c0_cause
9d001194:	40088000 	mfc0	t0,c0_config
9d001198:	7d090580 	ext	t1,t0,0x16,0x1
9d00119c:	00094c40 	sll	t1,t1,0x11
9d0011a0:	40086000 	mfc0	t0,c0_status
9d0011a4:	3c010058 	lui	at,0x58
9d0011a8:	01014024 	and	t0,t0,at
9d0011ac:	01284025 	or	t0,t1,t0
9d0011b0:	40886000 	mtc0	t0,c0_status
9d0011b4:	3c089d00 	lui	t0,0x9d00
9d0011b8:	250863f0 	addiu	t0,t0,25584
9d0011bc:	0100f809 	jalr	t0
9d0011c0:	00000000 	nop
9d0011c4:	40086000 	mfc0	t0,c0_status
9d0011c8:	3c01ffbf 	lui	at,0xffbf
9d0011cc:	3421ffff 	ori	at,at,0xffff
9d0011d0:	01014024 	and	t0,t0,at
9d0011d4:	40886000 	mtc0	t0,c0_status
9d0011d8:	30840000 	andi	a0,a0,0x0
9d0011dc:	30a50000 	andi	a1,a1,0x0
9d0011e0:	3c089d00 	lui	t0,0x9d00
9d0011e4:	250811f0 	addiu	t0,t0,4592
9d0011e8:	01000008 	jr	t0
9d0011ec:	00000000 	nop

Disassembly of section .text:

9d0011f0 <_main_entry>:
9d0011f0:	0f401919 	jal	9d006464 <_text_end>
9d0011f4:	00000000 	nop
9d0011f8:	30840000 	andi	a0,a0,0x0
9d0011fc:	30a50000 	andi	a1,a1,0x0
9d001200:	0f400ef0 	jal	9d003bc0 <main>
9d001204:	00000000 	nop
9d001208:	1000fffd 	b	9d001200 <_main_entry+0x10>
9d00120c:	00000000 	nop

9d001210 <__do_global_dtors_aux>:
9d001210:	27bdffd8 	addiu	sp,sp,-40
9d001214:	afb2001c 	sw	s2,28(sp)
9d001218:	3c12a000 	lui	s2,0xa000
9d00121c:	92420524 	lbu	v0,1316(s2)
9d001220:	afbf0024 	sw	ra,36(sp)
9d001224:	afb30020 	sw	s3,32(sp)
9d001228:	afb10018 	sw	s1,24(sp)
9d00122c:	14400020 	bnez	v0,9d0012b0 <__do_global_dtors_aux+0xa0>
9d001230:	afb00014 	sw	s0,20(sp)
9d001234:	3c119d00 	lui	s1,0x9d00
9d001238:	3c109d00 	lui	s0,0x9d00
9d00123c:	3c13a000 	lui	s3,0xa000
9d001240:	263164b4 	addiu	s1,s1,25780
9d001244:	261064b8 	addiu	s0,s0,25784
9d001248:	8e620528 	lw	v0,1320(s3)
9d00124c:	02118023 	subu	s0,s0,s1
9d001250:	00108083 	sra	s0,s0,0x2
9d001254:	2610ffff 	addiu	s0,s0,-1
9d001258:	0050182b 	sltu	v1,v0,s0
9d00125c:	5060000c 	beqzl	v1,9d001290 <__do_global_dtors_aux+0x80>
9d001260:	3c020000 	lui	v0,0x0
9d001264:	24420001 	addiu	v0,v0,1
9d001268:	00021880 	sll	v1,v0,0x2
9d00126c:	02231821 	addu	v1,s1,v1
9d001270:	8c630000 	lw	v1,0(v1)
9d001274:	0060f809 	jalr	v1
9d001278:	ae620528 	sw	v0,1320(s3)
9d00127c:	8e620528 	lw	v0,1320(s3)
9d001280:	0050182b 	sltu	v1,v0,s0
9d001284:	1460fff8 	bnez	v1,9d001268 <__do_global_dtors_aux+0x58>
9d001288:	24420001 	addiu	v0,v0,1
9d00128c:	3c020000 	lui	v0,0x0
9d001290:	24420000 	addiu	v0,v0,0
9d001294:	10400005 	beqz	v0,9d0012ac <__do_global_dtors_aux+0x9c>
9d001298:	24020001 	li	v0,1
9d00129c:	3c04a000 	lui	a0,0xa000
9d0012a0:	0c000000 	jal	90000000 <_imageExecutionJumpToFirstInFlash+0x8e000000>
9d0012a4:	24840008 	addiu	a0,a0,8
9d0012a8:	24020001 	li	v0,1
9d0012ac:	a2420524 	sb	v0,1316(s2)
9d0012b0:	8fbf0024 	lw	ra,36(sp)
9d0012b4:	8fb30020 	lw	s3,32(sp)
9d0012b8:	8fb2001c 	lw	s2,28(sp)
9d0012bc:	8fb10018 	lw	s1,24(sp)
9d0012c0:	8fb00014 	lw	s0,20(sp)
9d0012c4:	03e00008 	jr	ra
9d0012c8:	27bd0028 	addiu	sp,sp,40

9d0012cc <frame_dummy>:
9d0012cc:	3c020000 	lui	v0,0x0
9d0012d0:	27bdffe8 	addiu	sp,sp,-24
9d0012d4:	24420000 	addiu	v0,v0,0
9d0012d8:	10400006 	beqz	v0,9d0012f4 <frame_dummy+0x28>
9d0012dc:	afbf0014 	sw	ra,20(sp)
9d0012e0:	3c04a000 	lui	a0,0xa000
9d0012e4:	3c05a000 	lui	a1,0xa000
9d0012e8:	24840008 	addiu	a0,a0,8
9d0012ec:	0c000000 	jal	90000000 <_imageExecutionJumpToFirstInFlash+0x8e000000>
9d0012f0:	24a5052c 	addiu	a1,a1,1324
9d0012f4:	3c04a000 	lui	a0,0xa000
9d0012f8:	8c820008 	lw	v0,8(a0)
9d0012fc:	10400007 	beqz	v0,9d00131c <frame_dummy+0x50>
9d001300:	3c190000 	lui	t9,0x0
9d001304:	27390000 	addiu	t9,t9,0
9d001308:	13200004 	beqz	t9,9d00131c <frame_dummy+0x50>
9d00130c:	8fbf0014 	lw	ra,20(sp)
9d001310:	24840008 	addiu	a0,a0,8
9d001314:	03200008 	jr	t9
9d001318:	27bd0018 	addiu	sp,sp,24
9d00131c:	8fbf0014 	lw	ra,20(sp)
9d001320:	03e00008 	jr	ra
9d001324:	27bd0018 	addiu	sp,sp,24

9d001328 <setup>:
9d001328:	3c04a000 	lui	a0,0xa000
9d00132c:	3c050001 	lui	a1,0x1
9d001330:	27bdffe8 	addiu	sp,sp,-24
9d001334:	24840628 	addiu	a0,a0,1576
9d001338:	afbf0014 	sw	ra,20(sp)
9d00133c:	0f400c8d 	jal	9d003234 <_ZN14HardwareSerial5beginEm>
9d001340:	34a5c200 	ori	a1,a1,0xc200
9d001344:	3c04a000 	lui	a0,0xa000
9d001348:	8fbf0014 	lw	ra,20(sp)
9d00134c:	24840570 	addiu	a0,a0,1392
9d001350:	0b4007ae 	j	9d001eb8 <_ZN6SPIRAM5beginEv>
9d001354:	27bd0018 	addiu	sp,sp,24

9d001358 <_Z11testPatternPhm>:
9d001358:	27bdffc8 	addiu	sp,sp,-56
9d00135c:	afb50030 	sw	s5,48(sp)
9d001360:	3c15a000 	lui	s5,0xa000
9d001364:	8ea30570 	lw	v1,1392(s5)
9d001368:	afb20024 	sw	s2,36(sp)
9d00136c:	afb0001c 	sw	s0,28(sp)
9d001370:	afbf0034 	sw	ra,52(sp)
9d001374:	afb4002c 	sw	s4,44(sp)
9d001378:	afb30028 	sw	s3,40(sp)
9d00137c:	afb10020 	sw	s1,32(sp)
9d001380:	00809021 	move	s2,a0
9d001384:	00a08021 	move	s0,a1
9d001388:	10600036 	beqz	v1,9d001464 <_Z11testPatternPhm+0x10c>
9d00138c:	24020001 	li	v0,1
9d001390:	00009821 	move	s3,zero
9d001394:	0b4004eb 	j	9d0013ac <_Z11testPatternPhm+0x54>
9d001398:	26b10570 	addiu	s1,s5,1392
9d00139c:	26730001 	addiu	s3,s3,1
9d0013a0:	0262102b 	sltu	v0,s3,v0
9d0013a4:	10400038 	beqz	v0,9d001488 <_Z11testPatternPhm+0x130>
9d0013a8:	8fbf0034 	lw	ra,52(sp)
9d0013ac:	0270001b 	divu	zero,s3,s0
9d0013b0:	020001f4 	teq	s0,zero,0x7
9d0013b4:	02602821 	move	a1,s3
9d0013b8:	02202021 	move	a0,s1
9d0013bc:	0000a010 	mfhi	s4
9d0013c0:	0254a021 	addu	s4,s2,s4
9d0013c4:	0f400844 	jal	9d002110 <_ZN6SPIRAM5writeEmh>
9d0013c8:	92860000 	lbu	a2,0(s4)
        uint8_t read(uint32_t address);
        void read(uint32_t address, uint8_t *data, uint32_t len);
        void write(uint32_t address, uint8_t data);
        void write(uint32_t address, uint8_t *data, uint32_t len);
        void begin();
        uint8_t operator[](uint32_t address) { return read(address); }
9d0013cc:	02202021 	move	a0,s1
9d0013d0:	0f4007d0 	jal	9d001f40 <_ZN6SPIRAM4readEm>
9d0013d4:	02602821 	move	a1,s3
9d0013d8:	92830000 	lbu	v1,0(s4)
9d0013dc:	5062ffef 	beql	v1,v0,9d00139c <_Z11testPatternPhm+0x44>
9d0013e0:	8ea20570 	lw	v0,1392(s5)
9d0013e4:	3c10a000 	lui	s0,0xa000
9d0013e8:	3c059d00 	lui	a1,0x9d00
9d0013ec:	26040628 	addiu	a0,s0,1576
9d0013f0:	24a56508 	addiu	a1,a1,25864
9d0013f4:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d0013f8:	afa20010 	sw	v0,16(sp)
9d0013fc:	2406000a 	li	a2,10
9d001400:	26040628 	addiu	a0,s0,1576
9d001404:	0f400e1b 	jal	9d00386c <_ZN5Print5printEmi>
9d001408:	02602821 	move	a1,s3
9d00140c:	3c059d00 	lui	a1,0x9d00
9d001410:	26040628 	addiu	a0,s0,1576
9d001414:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d001418:	24a5650c 	addiu	a1,a1,25868
9d00141c:	92850000 	lbu	a1,0(s4)
9d001420:	24060010 	li	a2,16
9d001424:	0f400e22 	jal	9d003888 <_ZN5Print5printEhi>
9d001428:	26040628 	addiu	a0,s0,1576
9d00142c:	3c059d00 	lui	a1,0x9d00
9d001430:	26040628 	addiu	a0,s0,1576
9d001434:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d001438:	24a56510 	addiu	a1,a1,25872
9d00143c:	8fa20010 	lw	v0,16(sp)
9d001440:	26040628 	addiu	a0,s0,1576
9d001444:	24060010 	li	a2,16
9d001448:	0f400e22 	jal	9d003888 <_ZN5Print5printEhi>
9d00144c:	00402821 	move	a1,v0
9d001450:	3c059d00 	lui	a1,0x9d00
9d001454:	26040628 	addiu	a0,s0,1576
9d001458:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d00145c:	24a56518 	addiu	a1,a1,25880
9d001460:	00001021 	move	v0,zero
9d001464:	8fbf0034 	lw	ra,52(sp)
9d001468:	8fb50030 	lw	s5,48(sp)
9d00146c:	8fb4002c 	lw	s4,44(sp)
9d001470:	8fb30028 	lw	s3,40(sp)
9d001474:	8fb20024 	lw	s2,36(sp)
9d001478:	8fb10020 	lw	s1,32(sp)
9d00147c:	8fb0001c 	lw	s0,28(sp)
9d001480:	03e00008 	jr	ra
9d001484:	27bd0038 	addiu	sp,sp,56
9d001488:	24020001 	li	v0,1
9d00148c:	8fb50030 	lw	s5,48(sp)
9d001490:	8fb4002c 	lw	s4,44(sp)
9d001494:	8fb30028 	lw	s3,40(sp)
9d001498:	8fb20024 	lw	s2,36(sp)
9d00149c:	8fb10020 	lw	s1,32(sp)
9d0014a0:	8fb0001c 	lw	s0,28(sp)
9d0014a4:	03e00008 	jr	ra
9d0014a8:	27bd0038 	addiu	sp,sp,56

9d0014ac <_Z10walkingBitv>:
9d0014ac:	27bdffe0 	addiu	sp,sp,-32
9d0014b0:	afb00018 	sw	s0,24(sp)
9d0014b4:	3c059d00 	lui	a1,0x9d00
9d0014b8:	3c10a000 	lui	s0,0xa000
9d0014bc:	26040628 	addiu	a0,s0,1576
9d0014c0:	afbf001c 	sw	ra,28(sp)
9d0014c4:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d0014c8:	24a5651c 	addiu	a1,a1,25884
9d0014cc:	24020001 	li	v0,1
9d0014d0:	27a40010 	addiu	a0,sp,16
9d0014d4:	24050001 	li	a1,1
9d0014d8:	0f4004d6 	jal	9d001358 <_Z11testPatternPhm>
9d0014dc:	a3a20010 	sb	v0,16(sp)
9d0014e0:	1040004c 	beqz	v0,9d001614 <_Z10walkingBitv+0x168>
9d0014e4:	26040628 	addiu	a0,s0,1576
9d0014e8:	3c059d00 	lui	a1,0x9d00
9d0014ec:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d0014f0:	24a56538 	addiu	a1,a1,25912
9d0014f4:	24020002 	li	v0,2
9d0014f8:	27a40010 	addiu	a0,sp,16
9d0014fc:	24050001 	li	a1,1
9d001500:	0f4004d6 	jal	9d001358 <_Z11testPatternPhm>
9d001504:	a3a20010 	sb	v0,16(sp)
9d001508:	10400042 	beqz	v0,9d001614 <_Z10walkingBitv+0x168>
9d00150c:	26040628 	addiu	a0,s0,1576
9d001510:	3c059d00 	lui	a1,0x9d00
9d001514:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d001518:	24a56540 	addiu	a1,a1,25920
9d00151c:	24020004 	li	v0,4
9d001520:	27a40010 	addiu	a0,sp,16
9d001524:	24050001 	li	a1,1
9d001528:	0f4004d6 	jal	9d001358 <_Z11testPatternPhm>
9d00152c:	a3a20010 	sb	v0,16(sp)
9d001530:	10400038 	beqz	v0,9d001614 <_Z10walkingBitv+0x168>
9d001534:	26040628 	addiu	a0,s0,1576
9d001538:	3c059d00 	lui	a1,0x9d00
9d00153c:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d001540:	24a56548 	addiu	a1,a1,25928
9d001544:	24020008 	li	v0,8
9d001548:	27a40010 	addiu	a0,sp,16
9d00154c:	24050001 	li	a1,1
9d001550:	0f4004d6 	jal	9d001358 <_Z11testPatternPhm>
9d001554:	a3a20010 	sb	v0,16(sp)
9d001558:	1040002e 	beqz	v0,9d001614 <_Z10walkingBitv+0x168>
9d00155c:	26040628 	addiu	a0,s0,1576
9d001560:	3c059d00 	lui	a1,0x9d00
9d001564:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d001568:	24a56550 	addiu	a1,a1,25936
9d00156c:	24020010 	li	v0,16
9d001570:	27a40010 	addiu	a0,sp,16
9d001574:	24050001 	li	a1,1
9d001578:	0f4004d6 	jal	9d001358 <_Z11testPatternPhm>
9d00157c:	a3a20010 	sb	v0,16(sp)
9d001580:	10400024 	beqz	v0,9d001614 <_Z10walkingBitv+0x168>
9d001584:	26040628 	addiu	a0,s0,1576
9d001588:	3c059d00 	lui	a1,0x9d00
9d00158c:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d001590:	24a56558 	addiu	a1,a1,25944
9d001594:	24020020 	li	v0,32
9d001598:	27a40010 	addiu	a0,sp,16
9d00159c:	24050001 	li	a1,1
9d0015a0:	0f4004d6 	jal	9d001358 <_Z11testPatternPhm>
9d0015a4:	a3a20010 	sb	v0,16(sp)
9d0015a8:	1040001a 	beqz	v0,9d001614 <_Z10walkingBitv+0x168>
9d0015ac:	26040628 	addiu	a0,s0,1576
9d0015b0:	3c059d00 	lui	a1,0x9d00
9d0015b4:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d0015b8:	24a56560 	addiu	a1,a1,25952
9d0015bc:	24020040 	li	v0,64
9d0015c0:	27a40010 	addiu	a0,sp,16
9d0015c4:	24050001 	li	a1,1
9d0015c8:	0f4004d6 	jal	9d001358 <_Z11testPatternPhm>
9d0015cc:	a3a20010 	sb	v0,16(sp)
9d0015d0:	10400010 	beqz	v0,9d001614 <_Z10walkingBitv+0x168>
9d0015d4:	26040628 	addiu	a0,s0,1576
9d0015d8:	3c059d00 	lui	a1,0x9d00
9d0015dc:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d0015e0:	24a56568 	addiu	a1,a1,25960
9d0015e4:	2402ff80 	li	v0,-128
9d0015e8:	27a40010 	addiu	a0,sp,16
9d0015ec:	24050001 	li	a1,1
9d0015f0:	0f4004d6 	jal	9d001358 <_Z11testPatternPhm>
9d0015f4:	a3a20010 	sb	v0,16(sp)
9d0015f8:	10400006 	beqz	v0,9d001614 <_Z10walkingBitv+0x168>
9d0015fc:	26040628 	addiu	a0,s0,1576
9d001600:	3c059d00 	lui	a1,0x9d00
9d001604:	0f400e57 	jal	9d00395c <_ZN5Print7printlnEPKc>
9d001608:	24a56570 	addiu	a1,a1,25968
9d00160c:	0b40058a 	j	9d001628 <_Z10walkingBitv+0x17c>
9d001610:	8fbf001c 	lw	ra,28(sp)
9d001614:	3c059d00 	lui	a1,0x9d00
9d001618:	26040628 	addiu	a0,s0,1576
9d00161c:	0f400e57 	jal	9d00395c <_ZN5Print7printlnEPKc>
9d001620:	24a56530 	addiu	a1,a1,25904
9d001624:	8fbf001c 	lw	ra,28(sp)
9d001628:	8fb00018 	lw	s0,24(sp)
9d00162c:	03e00008 	jr	ra
9d001630:	27bd0020 	addiu	sp,sp,32

9d001634 <_Z12checkerboardv>:
9d001634:	27bdffd8 	addiu	sp,sp,-40
9d001638:	afb00018 	sw	s0,24(sp)
9d00163c:	3c059d00 	lui	a1,0x9d00
9d001640:	3c10a000 	lui	s0,0xa000
9d001644:	afb20020 	sw	s2,32(sp)
9d001648:	afb1001c 	sw	s1,28(sp)
9d00164c:	26040628 	addiu	a0,s0,1576
9d001650:	24a56578 	addiu	a1,a1,25976
9d001654:	24110055 	li	s1,85
9d001658:	2412ffaa 	li	s2,-86
9d00165c:	afbf0024 	sw	ra,36(sp)
9d001660:	a3b10010 	sb	s1,16(sp)
9d001664:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d001668:	a3b20011 	sb	s2,17(sp)
9d00166c:	27a40010 	addiu	a0,sp,16
9d001670:	0f4004d6 	jal	9d001358 <_Z11testPatternPhm>
9d001674:	24050002 	li	a1,2
9d001678:	10400014 	beqz	v0,9d0016cc <_Z12checkerboardv+0x98>
9d00167c:	26040628 	addiu	a0,s0,1576
9d001680:	3c059d00 	lui	a1,0x9d00
9d001684:	24a56594 	addiu	a1,a1,26004
9d001688:	a3b20010 	sb	s2,16(sp)
9d00168c:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d001690:	a3b10011 	sb	s1,17(sp)
9d001694:	27a40010 	addiu	a0,sp,16
9d001698:	0f4004d6 	jal	9d001358 <_Z11testPatternPhm>
9d00169c:	24050002 	li	a1,2
9d0016a0:	1040000a 	beqz	v0,9d0016cc <_Z12checkerboardv+0x98>
9d0016a4:	26040628 	addiu	a0,s0,1576
9d0016a8:	3c059d00 	lui	a1,0x9d00
9d0016ac:	0f400e57 	jal	9d00395c <_ZN5Print7printlnEPKc>
9d0016b0:	24a56570 	addiu	a1,a1,25968
9d0016b4:	8fbf0024 	lw	ra,36(sp)
9d0016b8:	8fb20020 	lw	s2,32(sp)
9d0016bc:	8fb1001c 	lw	s1,28(sp)
9d0016c0:	8fb00018 	lw	s0,24(sp)
9d0016c4:	03e00008 	jr	ra
9d0016c8:	27bd0028 	addiu	sp,sp,40
9d0016cc:	3c059d00 	lui	a1,0x9d00
9d0016d0:	26040628 	addiu	a0,s0,1576
9d0016d4:	0f400e57 	jal	9d00395c <_ZN5Print7printlnEPKc>
9d0016d8:	24a56530 	addiu	a1,a1,25904
9d0016dc:	8fbf0024 	lw	ra,36(sp)
9d0016e0:	8fb20020 	lw	s2,32(sp)
9d0016e4:	8fb1001c 	lw	s1,28(sp)
9d0016e8:	8fb00018 	lw	s0,24(sp)
9d0016ec:	03e00008 	jr	ra
9d0016f0:	27bd0028 	addiu	sp,sp,40

9d0016f4 <_Z12randomValuesv>:
9d0016f4:	27bdfee0 	addiu	sp,sp,-288
9d0016f8:	afb10118 	sw	s1,280(sp)
9d0016fc:	afb00114 	sw	s0,276(sp)
9d001700:	afbf011c 	sw	ra,284(sp)
9d001704:	27b10010 	addiu	s1,sp,16
9d001708:	27b00110 	addiu	s0,sp,272
9d00170c:	0f4018ae 	jal	9d0062b8 <rand>
9d001710:	00000000 	nop
9d001714:	a2220000 	sb	v0,0(s1)
9d001718:	26310001 	addiu	s1,s1,1
9d00171c:	1630fffb 	bne	s1,s0,9d00170c <_Z12randomValuesv+0x18>
9d001720:	3c059d00 	lui	a1,0x9d00
9d001724:	3c10a000 	lui	s0,0xa000
9d001728:	24a565a0 	addiu	a1,a1,26016
9d00172c:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d001730:	26040628 	addiu	a0,s0,1576
9d001734:	27a40010 	addiu	a0,sp,16
9d001738:	0f4004d6 	jal	9d001358 <_Z11testPatternPhm>
9d00173c:	24050100 	li	a1,256
9d001740:	10400009 	beqz	v0,9d001768 <_Z12randomValuesv+0x74>
9d001744:	26040628 	addiu	a0,s0,1576
9d001748:	3c059d00 	lui	a1,0x9d00
9d00174c:	0f400e57 	jal	9d00395c <_ZN5Print7printlnEPKc>
9d001750:	24a56570 	addiu	a1,a1,25968
9d001754:	8fbf011c 	lw	ra,284(sp)
9d001758:	8fb10118 	lw	s1,280(sp)
9d00175c:	8fb00114 	lw	s0,276(sp)
9d001760:	03e00008 	jr	ra
9d001764:	27bd0120 	addiu	sp,sp,288
9d001768:	3c059d00 	lui	a1,0x9d00
9d00176c:	0f400e57 	jal	9d00395c <_ZN5Print7printlnEPKc>
9d001770:	24a56530 	addiu	a1,a1,25904
9d001774:	8fbf011c 	lw	ra,284(sp)
9d001778:	8fb10118 	lw	s1,280(sp)
9d00177c:	8fb00114 	lw	s0,276(sp)
9d001780:	03e00008 	jr	ra
9d001784:	27bd0120 	addiu	sp,sp,288

9d001788 <_Z9writeTimev>:
9d001788:	27bdfbb8 	addiu	sp,sp,-1096
9d00178c:	afb00420 	sw	s0,1056(sp)
9d001790:	3c059d00 	lui	a1,0x9d00
9d001794:	3c10a000 	lui	s0,0xa000
9d001798:	26040628 	addiu	a0,s0,1576
9d00179c:	24a565b4 	addiu	a1,a1,26036
9d0017a0:	afbf0444 	sw	ra,1092(sp)
9d0017a4:	afb50434 	sw	s5,1076(sp)
9d0017a8:	afb10424 	sw	s1,1060(sp)
9d0017ac:	afbe0440 	sw	s8,1088(sp)
9d0017b0:	afb7043c 	sw	s7,1084(sp)
9d0017b4:	afb60438 	sw	s6,1080(sp)
9d0017b8:	afb40430 	sw	s4,1072(sp)
9d0017bc:	afb3042c 	sw	s3,1068(sp)
9d0017c0:	afb20428 	sw	s2,1064(sp)
9d0017c4:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d0017c8:	3c15a000 	lui	s5,0xa000
9d0017cc:	0f400a63 	jal	9d00298c <millis>
9d0017d0:	00000000 	nop
9d0017d4:	00408821 	move	s1,v0
9d0017d8:	8ea20570 	lw	v0,1392(s5)
9d0017dc:	1040000b 	beqz	v0,9d00180c <_Z9writeTimev+0x84>
9d0017e0:	00009821 	move	s3,zero
9d0017e4:	26b20570 	addiu	s2,s5,1392
9d0017e8:	02602821 	move	a1,s3
9d0017ec:	02402021 	move	a0,s2
9d0017f0:	0f400844 	jal	9d002110 <_ZN6SPIRAM5writeEmh>
9d0017f4:	00003021 	move	a2,zero
9d0017f8:	8ea20570 	lw	v0,1392(s5)
9d0017fc:	26730001 	addiu	s3,s3,1
9d001800:	0262102b 	sltu	v0,s3,v0
9d001804:	5440fff9 	bnezl	v0,9d0017ec <_Z9writeTimev+0x64>
9d001808:	02602821 	move	a1,s3
9d00180c:	0f400a63 	jal	9d00298c <millis>
9d001810:	3c169d00 	lui	s6,0x9d00
9d001814:	00518823 	subu	s1,v0,s1
9d001818:	26040628 	addiu	a0,s0,1576
9d00181c:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d001820:	26c565d8 	addiu	a1,s6,26072
9d001824:	3c129d00 	lui	s2,0x9d00
9d001828:	2406000a 	li	a2,10
9d00182c:	26040628 	addiu	a0,s0,1576
9d001830:	0f400e1b 	jal	9d00386c <_ZN5Print5printEmi>
9d001834:	02202821 	move	a1,s1
9d001838:	264565dc 	addiu	a1,s2,26076
9d00183c:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d001840:	26040628 	addiu	a0,s0,1576
9d001844:	8ea40570 	lw	a0,1392(s5)
9d001848:	3c139d00 	lui	s3,0x9d00
9d00184c:	0f400f21 	jal	9d003c84 <__floatunsisf>
9d001850:	3c149d00 	lui	s4,0x9d00
9d001854:	0f4017fa 	jal	9d005fe8 <__extendsfdf2>
9d001858:	00402021 	move	a0,v0
9d00185c:	02202021 	move	a0,s1
9d001860:	afa3041c 	sw	v1,1052(sp)
9d001864:	0f400f21 	jal	9d003c84 <__floatunsisf>
9d001868:	afa20418 	sw	v0,1048(sp)
9d00186c:	0f4017fa 	jal	9d005fe8 <__extendsfdf2>
9d001870:	00402021 	move	a0,v0
9d001874:	8e666640 	lw	a2,26176(s3)
9d001878:	8e676644 	lw	a3,26180(s3)
9d00187c:	00402021 	move	a0,v0
9d001880:	0f40119c 	jal	9d004670 <__divdf3>
9d001884:	00602821 	move	a1,v1
9d001888:	8fa80418 	lw	t0,1048(sp)
9d00188c:	8fa9041c 	lw	t1,1052(sp)
9d001890:	00403021 	move	a2,v0
9d001894:	01002021 	move	a0,t0
9d001898:	01202821 	move	a1,t1
9d00189c:	0f40119c 	jal	9d004670 <__divdf3>
9d0018a0:	00603821 	move	a3,v1
9d0018a4:	00602821 	move	a1,v1
9d0018a8:	0f401834 	jal	9d0060d0 <__truncdfsf2>
9d0018ac:	00402021 	move	a0,v0
9d0018b0:	0f4017fa 	jal	9d005fe8 <__extendsfdf2>
9d0018b4:	00402021 	move	a0,v0
9d0018b8:	00403021 	move	a2,v0
9d0018bc:	00603821 	move	a3,v1
9d0018c0:	24020002 	li	v0,2
9d0018c4:	26040628 	addiu	a0,s0,1576
9d0018c8:	0f400eed 	jal	9d003bb4 <_ZN5Print5printEdi>
9d0018cc:	afa20010 	sw	v0,16(sp)
9d0018d0:	26040628 	addiu	a0,s0,1576
9d0018d4:	0f400e57 	jal	9d00395c <_ZN5Print7printlnEPKc>
9d0018d8:	268565e4 	addiu	a1,s4,26084
9d0018dc:	3c059d00 	lui	a1,0x9d00
9d0018e0:	26040628 	addiu	a0,s0,1576
9d0018e4:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d0018e8:	24a565e8 	addiu	a1,a1,26088
9d0018ec:	0f400a63 	jal	9d00298c <millis>
9d0018f0:	00000000 	nop
9d0018f4:	0040b821 	move	s7,v0
9d0018f8:	8ea20570 	lw	v0,1392(s5)
9d0018fc:	1040000c 	beqz	v0,9d001930 <_Z9writeTimev+0x1a8>
9d001900:	0000f021 	move	s8,zero
9d001904:	26b10570 	addiu	s1,s5,1392
9d001908:	03c02821 	move	a1,s8
9d00190c:	02202021 	move	a0,s1
9d001910:	27a60018 	addiu	a2,sp,24
9d001914:	0f40086f 	jal	9d0021bc <_ZN6SPIRAM5writeEmPhm>
9d001918:	24070400 	li	a3,1024
9d00191c:	8ea20570 	lw	v0,1392(s5)
9d001920:	27de0400 	addiu	s8,s8,1024
9d001924:	03c2102b 	sltu	v0,s8,v0
9d001928:	5440fff8 	bnezl	v0,9d00190c <_Z9writeTimev+0x184>
9d00192c:	03c02821 	move	a1,s8
9d001930:	0f400a63 	jal	9d00298c <millis>
9d001934:	00000000 	nop
9d001938:	00578823 	subu	s1,v0,s7
9d00193c:	26040628 	addiu	a0,s0,1576
9d001940:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d001944:	26c565d8 	addiu	a1,s6,26072
9d001948:	2406000a 	li	a2,10
9d00194c:	26040628 	addiu	a0,s0,1576
9d001950:	0f400e1b 	jal	9d00386c <_ZN5Print5printEmi>
9d001954:	02202821 	move	a1,s1
9d001958:	264565dc 	addiu	a1,s2,26076
9d00195c:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d001960:	26040628 	addiu	a0,s0,1576
9d001964:	0f400f21 	jal	9d003c84 <__floatunsisf>
9d001968:	8ea40570 	lw	a0,1392(s5)
9d00196c:	0f4017fa 	jal	9d005fe8 <__extendsfdf2>
9d001970:	00402021 	move	a0,v0
9d001974:	02202021 	move	a0,s1
9d001978:	0060b821 	move	s7,v1
9d00197c:	0f400f21 	jal	9d003c84 <__floatunsisf>
9d001980:	0040b021 	move	s6,v0
9d001984:	0f4017fa 	jal	9d005fe8 <__extendsfdf2>
9d001988:	00402021 	move	a0,v0
9d00198c:	8e666640 	lw	a2,26176(s3)
9d001990:	8e676644 	lw	a3,26180(s3)
9d001994:	00402021 	move	a0,v0
9d001998:	0f40119c 	jal	9d004670 <__divdf3>
9d00199c:	00602821 	move	a1,v1
9d0019a0:	00403021 	move	a2,v0
9d0019a4:	00603821 	move	a3,v1
9d0019a8:	02c02021 	move	a0,s6
9d0019ac:	0f40119c 	jal	9d004670 <__divdf3>
9d0019b0:	02e02821 	move	a1,s7
9d0019b4:	00602821 	move	a1,v1
9d0019b8:	0f401834 	jal	9d0060d0 <__truncdfsf2>
9d0019bc:	00402021 	move	a0,v0
9d0019c0:	0f4017fa 	jal	9d005fe8 <__extendsfdf2>
9d0019c4:	00402021 	move	a0,v0
9d0019c8:	00403021 	move	a2,v0
9d0019cc:	26040628 	addiu	a0,s0,1576
9d0019d0:	24020002 	li	v0,2
9d0019d4:	00603821 	move	a3,v1
9d0019d8:	0f400eed 	jal	9d003bb4 <_ZN5Print5printEdi>
9d0019dc:	afa20010 	sw	v0,16(sp)
9d0019e0:	26040628 	addiu	a0,s0,1576
9d0019e4:	0f400e57 	jal	9d00395c <_ZN5Print7printlnEPKc>
9d0019e8:	268565e4 	addiu	a1,s4,26084
9d0019ec:	8fbf0444 	lw	ra,1092(sp)
9d0019f0:	8fbe0440 	lw	s8,1088(sp)
9d0019f4:	8fb7043c 	lw	s7,1084(sp)
9d0019f8:	8fb60438 	lw	s6,1080(sp)
9d0019fc:	8fb50434 	lw	s5,1076(sp)
9d001a00:	8fb40430 	lw	s4,1072(sp)
9d001a04:	8fb3042c 	lw	s3,1068(sp)
9d001a08:	8fb20428 	lw	s2,1064(sp)
9d001a0c:	8fb10424 	lw	s1,1060(sp)
9d001a10:	8fb00420 	lw	s0,1056(sp)
9d001a14:	03e00008 	jr	ra
9d001a18:	27bd0448 	addiu	sp,sp,1096

9d001a1c <_Z8readTimev>:
9d001a1c:	27bdfbb8 	addiu	sp,sp,-1096
9d001a20:	afb00420 	sw	s0,1056(sp)
9d001a24:	3c059d00 	lui	a1,0x9d00
9d001a28:	3c10a000 	lui	s0,0xa000
9d001a2c:	26040628 	addiu	a0,s0,1576
9d001a30:	24a56604 	addiu	a1,a1,26116
9d001a34:	afbf0444 	sw	ra,1092(sp)
9d001a38:	afb50434 	sw	s5,1076(sp)
9d001a3c:	afb10424 	sw	s1,1060(sp)
9d001a40:	afbe0440 	sw	s8,1088(sp)
9d001a44:	afb7043c 	sw	s7,1084(sp)
9d001a48:	afb60438 	sw	s6,1080(sp)
9d001a4c:	afb40430 	sw	s4,1072(sp)
9d001a50:	afb3042c 	sw	s3,1068(sp)
9d001a54:	afb20428 	sw	s2,1064(sp)
9d001a58:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d001a5c:	3c15a000 	lui	s5,0xa000
9d001a60:	0f400a63 	jal	9d00298c <millis>
9d001a64:	00000000 	nop
9d001a68:	00408821 	move	s1,v0
9d001a6c:	8ea20570 	lw	v0,1392(s5)
9d001a70:	1040000a 	beqz	v0,9d001a9c <_Z8readTimev+0x80>
9d001a74:	00009821 	move	s3,zero
9d001a78:	26b20570 	addiu	s2,s5,1392
9d001a7c:	02602821 	move	a1,s3
9d001a80:	0f4007d0 	jal	9d001f40 <_ZN6SPIRAM4readEm>
9d001a84:	02402021 	move	a0,s2
9d001a88:	8ea20570 	lw	v0,1392(s5)
9d001a8c:	26730001 	addiu	s3,s3,1
9d001a90:	0262102b 	sltu	v0,s3,v0
9d001a94:	5440fffa 	bnezl	v0,9d001a80 <_Z8readTimev+0x64>
9d001a98:	02602821 	move	a1,s3
9d001a9c:	0f400a63 	jal	9d00298c <millis>
9d001aa0:	3c169d00 	lui	s6,0x9d00
9d001aa4:	00518823 	subu	s1,v0,s1
9d001aa8:	26040628 	addiu	a0,s0,1576
9d001aac:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d001ab0:	26c565d8 	addiu	a1,s6,26072
9d001ab4:	3c129d00 	lui	s2,0x9d00
9d001ab8:	2406000a 	li	a2,10
9d001abc:	26040628 	addiu	a0,s0,1576
9d001ac0:	0f400e1b 	jal	9d00386c <_ZN5Print5printEmi>
9d001ac4:	02202821 	move	a1,s1
9d001ac8:	264565dc 	addiu	a1,s2,26076
9d001acc:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d001ad0:	26040628 	addiu	a0,s0,1576
9d001ad4:	8ea40570 	lw	a0,1392(s5)
9d001ad8:	3c139d00 	lui	s3,0x9d00
9d001adc:	0f400f21 	jal	9d003c84 <__floatunsisf>
9d001ae0:	3c149d00 	lui	s4,0x9d00
9d001ae4:	0f4017fa 	jal	9d005fe8 <__extendsfdf2>
9d001ae8:	00402021 	move	a0,v0
9d001aec:	02202021 	move	a0,s1
9d001af0:	afa3041c 	sw	v1,1052(sp)
9d001af4:	0f400f21 	jal	9d003c84 <__floatunsisf>
9d001af8:	afa20418 	sw	v0,1048(sp)
9d001afc:	0f4017fa 	jal	9d005fe8 <__extendsfdf2>
9d001b00:	00402021 	move	a0,v0
9d001b04:	8e666640 	lw	a2,26176(s3)
9d001b08:	8e676644 	lw	a3,26180(s3)
9d001b0c:	00402021 	move	a0,v0
9d001b10:	0f40119c 	jal	9d004670 <__divdf3>
9d001b14:	00602821 	move	a1,v1
9d001b18:	8fa80418 	lw	t0,1048(sp)
9d001b1c:	8fa9041c 	lw	t1,1052(sp)
9d001b20:	00403021 	move	a2,v0
9d001b24:	01002021 	move	a0,t0
9d001b28:	01202821 	move	a1,t1
9d001b2c:	0f40119c 	jal	9d004670 <__divdf3>
9d001b30:	00603821 	move	a3,v1
9d001b34:	00602821 	move	a1,v1
9d001b38:	0f401834 	jal	9d0060d0 <__truncdfsf2>
9d001b3c:	00402021 	move	a0,v0
9d001b40:	0f4017fa 	jal	9d005fe8 <__extendsfdf2>
9d001b44:	00402021 	move	a0,v0
9d001b48:	00403021 	move	a2,v0
9d001b4c:	00603821 	move	a3,v1
9d001b50:	24020002 	li	v0,2
9d001b54:	26040628 	addiu	a0,s0,1576
9d001b58:	0f400eed 	jal	9d003bb4 <_ZN5Print5printEdi>
9d001b5c:	afa20010 	sw	v0,16(sp)
9d001b60:	26040628 	addiu	a0,s0,1576
9d001b64:	0f400e57 	jal	9d00395c <_ZN5Print7printlnEPKc>
9d001b68:	268565e4 	addiu	a1,s4,26084
9d001b6c:	3c059d00 	lui	a1,0x9d00
9d001b70:	26040628 	addiu	a0,s0,1576
9d001b74:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d001b78:	24a56624 	addiu	a1,a1,26148
9d001b7c:	0f400a63 	jal	9d00298c <millis>
9d001b80:	00000000 	nop
9d001b84:	0040b821 	move	s7,v0
9d001b88:	8ea20570 	lw	v0,1392(s5)
9d001b8c:	1040000c 	beqz	v0,9d001bc0 <_Z8readTimev+0x1a4>
9d001b90:	0000f021 	move	s8,zero
9d001b94:	26b10570 	addiu	s1,s5,1392
9d001b98:	03c02821 	move	a1,s8
9d001b9c:	02202021 	move	a0,s1
9d001ba0:	27a60018 	addiu	a2,sp,24
9d001ba4:	0f4007fc 	jal	9d001ff0 <_ZN6SPIRAM4readEmPhm>
9d001ba8:	24070400 	li	a3,1024
9d001bac:	8ea20570 	lw	v0,1392(s5)
9d001bb0:	27de0400 	addiu	s8,s8,1024
9d001bb4:	03c2102b 	sltu	v0,s8,v0
9d001bb8:	5440fff8 	bnezl	v0,9d001b9c <_Z8readTimev+0x180>
9d001bbc:	03c02821 	move	a1,s8
9d001bc0:	0f400a63 	jal	9d00298c <millis>
9d001bc4:	00000000 	nop
9d001bc8:	00578823 	subu	s1,v0,s7
9d001bcc:	26040628 	addiu	a0,s0,1576
9d001bd0:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d001bd4:	26c565d8 	addiu	a1,s6,26072
9d001bd8:	2406000a 	li	a2,10
9d001bdc:	26040628 	addiu	a0,s0,1576
9d001be0:	0f400e1b 	jal	9d00386c <_ZN5Print5printEmi>
9d001be4:	02202821 	move	a1,s1
9d001be8:	264565dc 	addiu	a1,s2,26076
9d001bec:	0f400de9 	jal	9d0037a4 <_ZN5Print5printEPKc>
9d001bf0:	26040628 	addiu	a0,s0,1576
9d001bf4:	0f400f21 	jal	9d003c84 <__floatunsisf>
9d001bf8:	8ea40570 	lw	a0,1392(s5)
9d001bfc:	0f4017fa 	jal	9d005fe8 <__extendsfdf2>
9d001c00:	00402021 	move	a0,v0
9d001c04:	02202021 	move	a0,s1
9d001c08:	0060b821 	move	s7,v1
9d001c0c:	0f400f21 	jal	9d003c84 <__floatunsisf>
9d001c10:	0040b021 	move	s6,v0
9d001c14:	0f4017fa 	jal	9d005fe8 <__extendsfdf2>
9d001c18:	00402021 	move	a0,v0
9d001c1c:	8e666640 	lw	a2,26176(s3)
9d001c20:	8e676644 	lw	a3,26180(s3)
9d001c24:	00402021 	move	a0,v0
9d001c28:	0f40119c 	jal	9d004670 <__divdf3>
9d001c2c:	00602821 	move	a1,v1
9d001c30:	00403021 	move	a2,v0
9d001c34:	00603821 	move	a3,v1
9d001c38:	02c02021 	move	a0,s6
9d001c3c:	0f40119c 	jal	9d004670 <__divdf3>
9d001c40:	02e02821 	move	a1,s7
9d001c44:	00602821 	move	a1,v1
9d001c48:	0f401834 	jal	9d0060d0 <__truncdfsf2>
9d001c4c:	00402021 	move	a0,v0
9d001c50:	0f4017fa 	jal	9d005fe8 <__extendsfdf2>
9d001c54:	00402021 	move	a0,v0
9d001c58:	00403021 	move	a2,v0
9d001c5c:	26040628 	addiu	a0,s0,1576
9d001c60:	24020002 	li	v0,2
9d001c64:	00603821 	move	a3,v1
9d001c68:	0f400eed 	jal	9d003bb4 <_ZN5Print5printEdi>
9d001c6c:	afa20010 	sw	v0,16(sp)
9d001c70:	26040628 	addiu	a0,s0,1576
9d001c74:	0f400e57 	jal	9d00395c <_ZN5Print7printlnEPKc>
9d001c78:	268565e4 	addiu	a1,s4,26084
9d001c7c:	8fbf0444 	lw	ra,1092(sp)
9d001c80:	8fbe0440 	lw	s8,1088(sp)
9d001c84:	8fb7043c 	lw	s7,1084(sp)
9d001c88:	8fb60438 	lw	s6,1080(sp)
9d001c8c:	8fb50434 	lw	s5,1076(sp)
9d001c90:	8fb40430 	lw	s4,1072(sp)
9d001c94:	8fb3042c 	lw	s3,1068(sp)
9d001c98:	8fb20428 	lw	s2,1064(sp)
9d001c9c:	8fb10424 	lw	s1,1060(sp)
9d001ca0:	8fb00420 	lw	s0,1056(sp)
9d001ca4:	03e00008 	jr	ra
9d001ca8:	27bd0448 	addiu	sp,sp,1096

9d001cac <loop>:
9d001cac:	27bdffe8 	addiu	sp,sp,-24
9d001cb0:	afbf0014 	sw	ra,20(sp)
9d001cb4:	0f40052b 	jal	9d0014ac <_Z10walkingBitv>
9d001cb8:	00000000 	nop
9d001cbc:	0f40058d 	jal	9d001634 <_Z12checkerboardv>
9d001cc0:	00000000 	nop
9d001cc4:	0f4005bd 	jal	9d0016f4 <_Z12randomValuesv>
9d001cc8:	00000000 	nop
9d001ccc:	0f4005e2 	jal	9d001788 <_Z9writeTimev>
9d001cd0:	00000000 	nop
9d001cd4:	0f400687 	jal	9d001a1c <_Z8readTimev>
9d001cd8:	00000000 	nop
9d001cdc:	3c04a000 	lui	a0,0xa000
9d001ce0:	0f400e49 	jal	9d003924 <_ZN5Print7printlnEv>
9d001ce4:	24840628 	addiu	a0,a0,1576
9d001ce8:	8fbf0014 	lw	ra,20(sp)
9d001cec:	240403e8 	li	a0,1000
9d001cf0:	0b400a66 	j	9d002998 <delay>
9d001cf4:	27bd0018 	addiu	sp,sp,24

9d001cf8 <_GLOBAL__I_spi>:
9d001cf8:	27bdffc8 	addiu	sp,sp,-56
9d001cfc:	afb00030 	sw	s0,48(sp)
9d001d00:	3c10a000 	lui	s0,0xa000
9d001d04:	afbf0034 	sw	ra,52(sp)
9d001d08:	0f4009a5 	jal	9d002694 <_ZN5DSPI0C1Ev>
9d001d0c:	26040544 	addiu	a0,s0,1348
9d001d10:	3c04a000 	lui	a0,0xa000
9d001d14:	26050544 	addiu	a1,s0,1348
9d001d18:	24840570 	addiu	a0,a0,1392
9d001d1c:	2406000a 	li	a2,10
9d001d20:	00003821 	move	a3,zero
9d001d24:	afa00010 	sw	zero,16(sp)
9d001d28:	afa00014 	sw	zero,20(sp)
9d001d2c:	afa00018 	sw	zero,24(sp)
9d001d30:	afa0001c 	sw	zero,28(sp)
9d001d34:	afa00020 	sw	zero,32(sp)
9d001d38:	afa00024 	sw	zero,36(sp)
9d001d3c:	0f400755 	jal	9d001d54 <_ZN6SPIRAMC1EP4DSPImhhhhhhhh>
9d001d40:	afa00028 	sw	zero,40(sp)
9d001d44:	8fbf0034 	lw	ra,52(sp)
9d001d48:	8fb00030 	lw	s0,48(sp)
9d001d4c:	03e00008 	jr	ra
9d001d50:	27bd0038 	addiu	sp,sp,56

9d001d54 <_ZN6SPIRAMC1EP4DSPImhhhhhhhh>:
#include <SPIRAM.h>

SPIRAM::SPIRAM(DSPI *spi, uint32_t s, uint8_t cs0, uint8_t cs1, uint8_t cs2, uint8_t cs3, uint8_t cs4, uint8_t cs5, uint8_t cs6, uint8_t cs7) {
9d001d54:	30e700ff 	andi	a3,a3,0xff
9d001d58:	93ac0010 	lbu	t4,16(sp)
9d001d5c:	93ab0014 	lbu	t3,20(sp)
9d001d60:	93aa0018 	lbu	t2,24(sp)
9d001d64:	93a9001c 	lbu	t1,28(sp)
9d001d68:	93a80020 	lbu	t0,32(sp)
9d001d6c:	93a30024 	lbu	v1,36(sp)
9d001d70:	93a20028 	lbu	v0,40(sp)
    _spi = spi;
9d001d74:	ac850014 	sw	a1,20(a0)
    _size = 0;
9d001d78:	ac800000 	sw	zero,0(a0)
    _chipsize = s;
9d001d7c:	ac860004 	sw	a2,4(a0)
    _chips = 0;

    if (cs0 != NOT_A_PIN) {
9d001d80:	10e00005 	beqz	a3,9d001d98 <_ZN6SPIRAMC1EP4DSPImhhhhhhhh+0x44>
9d001d84:	a0800008 	sb	zero,8(a0)
        _size += s;
        _cs[_chips] = cs0;
        _chips++;
9d001d88:	24050001 	li	a1,1
    _size = 0;
    _chipsize = s;
    _chips = 0;

    if (cs0 != NOT_A_PIN) {
        _size += s;
9d001d8c:	ac860000 	sw	a2,0(a0)
        _cs[_chips] = cs0;
9d001d90:	a0870009 	sb	a3,9(a0)
        _chips++;
9d001d94:	a0850008 	sb	a1,8(a0)
    }
        
    if (cs1 != NOT_A_PIN) {
9d001d98:	11800009 	beqz	t4,9d001dc0 <_ZN6SPIRAMC1EP4DSPImhhhhhhhh+0x6c>
9d001d9c:	00000000 	nop
        _size += s;
        _cs[_chips] = cs1;
9d001da0:	90850008 	lbu	a1,8(a0)
        _cs[_chips] = cs0;
        _chips++;
    }
        
    if (cs1 != NOT_A_PIN) {
        _size += s;
9d001da4:	8c8d0000 	lw	t5,0(a0)
        _cs[_chips] = cs1;
9d001da8:	00853821 	addu	a3,a0,a1
        _cs[_chips] = cs0;
        _chips++;
    }
        
    if (cs1 != NOT_A_PIN) {
        _size += s;
9d001dac:	01a66821 	addu	t5,t5,a2
        _cs[_chips] = cs1;
        _chips++;
9d001db0:	24a50001 	addiu	a1,a1,1
        _cs[_chips] = cs0;
        _chips++;
    }
        
    if (cs1 != NOT_A_PIN) {
        _size += s;
9d001db4:	ac8d0000 	sw	t5,0(a0)
        _cs[_chips] = cs1;
9d001db8:	a0ec0009 	sb	t4,9(a3)
        _chips++;
9d001dbc:	a0850008 	sb	a1,8(a0)
    }

    if (cs2 != NOT_A_PIN) {
9d001dc0:	11600009 	beqz	t3,9d001de8 <_ZN6SPIRAMC1EP4DSPImhhhhhhhh+0x94>
9d001dc4:	00000000 	nop
        _size += s;
        _cs[_chips] = cs2;
9d001dc8:	90850008 	lbu	a1,8(a0)
        _cs[_chips] = cs1;
        _chips++;
    }

    if (cs2 != NOT_A_PIN) {
        _size += s;
9d001dcc:	8c8c0000 	lw	t4,0(a0)
        _cs[_chips] = cs2;
9d001dd0:	00853821 	addu	a3,a0,a1
        _cs[_chips] = cs1;
        _chips++;
    }

    if (cs2 != NOT_A_PIN) {
        _size += s;
9d001dd4:	01866021 	addu	t4,t4,a2
        _cs[_chips] = cs2;
        _chips++;
9d001dd8:	24a50001 	addiu	a1,a1,1
        _cs[_chips] = cs1;
        _chips++;
    }

    if (cs2 != NOT_A_PIN) {
        _size += s;
9d001ddc:	ac8c0000 	sw	t4,0(a0)
        _cs[_chips] = cs2;
9d001de0:	a0eb0009 	sb	t3,9(a3)
        _chips++;
9d001de4:	a0850008 	sb	a1,8(a0)
    }

    if (cs3 != NOT_A_PIN) {
9d001de8:	11400009 	beqz	t2,9d001e10 <_ZN6SPIRAMC1EP4DSPImhhhhhhhh+0xbc>
9d001dec:	00000000 	nop
        _size += s;
        _cs[_chips] = cs3;
9d001df0:	90850008 	lbu	a1,8(a0)
        _cs[_chips] = cs2;
        _chips++;
    }

    if (cs3 != NOT_A_PIN) {
        _size += s;
9d001df4:	8c8b0000 	lw	t3,0(a0)
        _cs[_chips] = cs3;
9d001df8:	00853821 	addu	a3,a0,a1
        _cs[_chips] = cs2;
        _chips++;
    }

    if (cs3 != NOT_A_PIN) {
        _size += s;
9d001dfc:	01665821 	addu	t3,t3,a2
        _cs[_chips] = cs3;
        _chips++;
9d001e00:	24a50001 	addiu	a1,a1,1
        _cs[_chips] = cs2;
        _chips++;
    }

    if (cs3 != NOT_A_PIN) {
        _size += s;
9d001e04:	ac8b0000 	sw	t3,0(a0)
        _cs[_chips] = cs3;
9d001e08:	a0ea0009 	sb	t2,9(a3)
        _chips++;
9d001e0c:	a0850008 	sb	a1,8(a0)
    }
        
    if (cs4 != NOT_A_PIN) {
9d001e10:	11200009 	beqz	t1,9d001e38 <_ZN6SPIRAMC1EP4DSPImhhhhhhhh+0xe4>
9d001e14:	00000000 	nop
        _size += s;
        _cs[_chips] = cs4;
9d001e18:	90850008 	lbu	a1,8(a0)
        _cs[_chips] = cs3;
        _chips++;
    }
        
    if (cs4 != NOT_A_PIN) {
        _size += s;
9d001e1c:	8c8a0000 	lw	t2,0(a0)
        _cs[_chips] = cs4;
9d001e20:	00853821 	addu	a3,a0,a1
        _cs[_chips] = cs3;
        _chips++;
    }
        
    if (cs4 != NOT_A_PIN) {
        _size += s;
9d001e24:	01465021 	addu	t2,t2,a2
        _cs[_chips] = cs4;
        _chips++;
9d001e28:	24a50001 	addiu	a1,a1,1
        _cs[_chips] = cs3;
        _chips++;
    }
        
    if (cs4 != NOT_A_PIN) {
        _size += s;
9d001e2c:	ac8a0000 	sw	t2,0(a0)
        _cs[_chips] = cs4;
9d001e30:	a0e90009 	sb	t1,9(a3)
        _chips++;
9d001e34:	a0850008 	sb	a1,8(a0)
    }
        
    if (cs5 != NOT_A_PIN) {
9d001e38:	11000009 	beqz	t0,9d001e60 <_ZN6SPIRAMC1EP4DSPImhhhhhhhh+0x10c>
9d001e3c:	00000000 	nop
        _size += s;
        _cs[_chips] = cs5;
9d001e40:	90850008 	lbu	a1,8(a0)
        _cs[_chips] = cs4;
        _chips++;
    }
        
    if (cs5 != NOT_A_PIN) {
        _size += s;
9d001e44:	8c890000 	lw	t1,0(a0)
        _cs[_chips] = cs5;
9d001e48:	00853821 	addu	a3,a0,a1
        _cs[_chips] = cs4;
        _chips++;
    }
        
    if (cs5 != NOT_A_PIN) {
        _size += s;
9d001e4c:	01264821 	addu	t1,t1,a2
        _cs[_chips] = cs5;
        _chips++;
9d001e50:	24a50001 	addiu	a1,a1,1
        _cs[_chips] = cs4;
        _chips++;
    }
        
    if (cs5 != NOT_A_PIN) {
        _size += s;
9d001e54:	ac890000 	sw	t1,0(a0)
        _cs[_chips] = cs5;
9d001e58:	a0e80009 	sb	t0,9(a3)
        _chips++;
9d001e5c:	a0850008 	sb	a1,8(a0)
    }
        
    if (cs6 != NOT_A_PIN) {
9d001e60:	10600009 	beqz	v1,9d001e88 <_ZN6SPIRAMC1EP4DSPImhhhhhhhh+0x134>
9d001e64:	00000000 	nop
        _size += s;
        _cs[_chips] = cs6;
9d001e68:	90850008 	lbu	a1,8(a0)
        _cs[_chips] = cs5;
        _chips++;
    }
        
    if (cs6 != NOT_A_PIN) {
        _size += s;
9d001e6c:	8c880000 	lw	t0,0(a0)
        _cs[_chips] = cs6;
9d001e70:	00853821 	addu	a3,a0,a1
        _cs[_chips] = cs5;
        _chips++;
    }
        
    if (cs6 != NOT_A_PIN) {
        _size += s;
9d001e74:	01064021 	addu	t0,t0,a2
        _cs[_chips] = cs6;
        _chips++;
9d001e78:	24a50001 	addiu	a1,a1,1
        _cs[_chips] = cs5;
        _chips++;
    }
        
    if (cs6 != NOT_A_PIN) {
        _size += s;
9d001e7c:	ac880000 	sw	t0,0(a0)
        _cs[_chips] = cs6;
9d001e80:	a0e30009 	sb	v1,9(a3)
        _chips++;
9d001e84:	a0850008 	sb	a1,8(a0)
    }
        
    if (cs7 != NOT_A_PIN) {
9d001e88:	10400009 	beqz	v0,9d001eb0 <_ZN6SPIRAMC1EP4DSPImhhhhhhhh+0x15c>
9d001e8c:	00000000 	nop
        _size += s;
        _cs[_chips] = cs7;
9d001e90:	90830008 	lbu	v1,8(a0)
        _cs[_chips] = cs6;
        _chips++;
    }
        
    if (cs7 != NOT_A_PIN) {
        _size += s;
9d001e94:	8c870000 	lw	a3,0(a0)
        _cs[_chips] = cs7;
9d001e98:	00832821 	addu	a1,a0,v1
        _cs[_chips] = cs6;
        _chips++;
    }
        
    if (cs7 != NOT_A_PIN) {
        _size += s;
9d001e9c:	00e63021 	addu	a2,a3,a2
        _cs[_chips] = cs7;
        _chips++;
9d001ea0:	24630001 	addiu	v1,v1,1
        _cs[_chips] = cs6;
        _chips++;
    }
        
    if (cs7 != NOT_A_PIN) {
        _size += s;
9d001ea4:	ac860000 	sw	a2,0(a0)
        _cs[_chips] = cs7;
9d001ea8:	a0a20009 	sb	v0,9(a1)
        _chips++;
9d001eac:	a0830008 	sb	v1,8(a0)
9d001eb0:	03e00008 	jr	ra
9d001eb4:	00000000 	nop

9d001eb8 <_ZN6SPIRAM5beginEv>:
    }
}


void SPIRAM::begin() {
9d001eb8:	27bdffe0 	addiu	sp,sp,-32
9d001ebc:	afb00010 	sw	s0,16(sp)
9d001ec0:	00808021 	move	s0,a0
    _spi->begin();
9d001ec4:	8c840014 	lw	a0,20(a0)
        _chips++;
    }
}


void SPIRAM::begin() {
9d001ec8:	afbf001c 	sw	ra,28(sp)
9d001ecc:	afb20018 	sw	s2,24(sp)
    _spi->begin();
9d001ed0:	0f400916 	jal	9d002458 <_ZN4DSPI5beginEv>
9d001ed4:	afb10014 	sw	s1,20(sp)
    _spi->setSpeed(12000000UL);
9d001ed8:	8e040014 	lw	a0,20(s0)
9d001edc:	3c0500b7 	lui	a1,0xb7
9d001ee0:	0f4008b7 	jal	9d0022dc <_ZN4DSPI8setSpeedEm>
9d001ee4:	24a51b00 	addiu	a1,a1,6912
    for (int i = 0; i < _chips; i++) {
9d001ee8:	92020008 	lbu	v0,8(s0)
9d001eec:	1040000e 	beqz	v0,9d001f28 <_ZN6SPIRAM5beginEv+0x70>
9d001ef0:	02008821 	move	s1,s0
9d001ef4:	00009021 	move	s2,zero
        pinMode(_cs[i], OUTPUT);
9d001ef8:	92240009 	lbu	a0,9(s1)
9d001efc:	24050001 	li	a1,1
9d001f00:	0f400aa8 	jal	9d002aa0 <pinMode>
9d001f04:	26520001 	addiu	s2,s2,1
        digitalWrite(_cs[i], HIGH);
9d001f08:	92240009 	lbu	a0,9(s1)
9d001f0c:	24050001 	li	a1,1
9d001f10:	0f400b0e 	jal	9d002c38 <digitalWrite>
9d001f14:	26310001 	addiu	s1,s1,1


void SPIRAM::begin() {
    _spi->begin();
    _spi->setSpeed(12000000UL);
    for (int i = 0; i < _chips; i++) {
9d001f18:	92020008 	lbu	v0,8(s0)
9d001f1c:	0242102a 	slt	v0,s2,v0
9d001f20:	5440fff6 	bnezl	v0,9d001efc <_ZN6SPIRAM5beginEv+0x44>
9d001f24:	92240009 	lbu	a0,9(s1)
        pinMode(_cs[i], OUTPUT);
        digitalWrite(_cs[i], HIGH);
    }
}
9d001f28:	8fbf001c 	lw	ra,28(sp)
9d001f2c:	8fb20018 	lw	s2,24(sp)
9d001f30:	8fb10014 	lw	s1,20(sp)
9d001f34:	8fb00010 	lw	s0,16(sp)
9d001f38:	03e00008 	jr	ra
9d001f3c:	27bd0020 	addiu	sp,sp,32

9d001f40 <_ZN6SPIRAM4readEm>:

uint8_t SPIRAM::read(uint32_t address) {
    uint8_t b;  

    uint32_t chipno = (address / _chipsize);
9d001f40:	8c820004 	lw	v0,4(a0)
        pinMode(_cs[i], OUTPUT);
        digitalWrite(_cs[i], HIGH);
    }
}

uint8_t SPIRAM::read(uint32_t address) {
9d001f44:	27bdffd8 	addiu	sp,sp,-40
9d001f48:	afb1001c 	sw	s1,28(sp)
9d001f4c:	00a08821 	move	s1,a1
    uint8_t b;  

    uint32_t chipno = (address / _chipsize);
9d001f50:	0222001b 	divu	zero,s1,v0
9d001f54:	004001f4 	teq	v0,zero,0x7
        pinMode(_cs[i], OUTPUT);
        digitalWrite(_cs[i], HIGH);
    }
}

uint8_t SPIRAM::read(uint32_t address) {
9d001f58:	afb20020 	sw	s2,32(sp)
9d001f5c:	afbf0024 	sw	ra,36(sp)
9d001f60:	afb00018 	sw	s0,24(sp)
9d001f64:	00808021 	move	s0,a0
    uint8_t b;  

    uint32_t chipno = (address / _chipsize);
    uint32_t chipaddress = address - (chipno * _chipsize);

    digitalWrite(_cs[chipno], LOW);
9d001f68:	00002821 	move	a1,zero
}

uint8_t SPIRAM::read(uint32_t address) {
    uint8_t b;  

    uint32_t chipno = (address / _chipsize);
9d001f6c:	00009012 	mflo	s2
    uint32_t chipaddress = address - (chipno * _chipsize);
9d001f70:	72421802 	mul	v1,s2,v0

    digitalWrite(_cs[chipno], LOW);
9d001f74:	00929021 	addu	s2,a0,s2
9d001f78:	92440009 	lbu	a0,9(s2)
9d001f7c:	0f400b0e 	jal	9d002c38 <digitalWrite>
9d001f80:	02238823 	subu	s1,s1,v1
    _spi->transfer(0x03);
9d001f84:	8e040014 	lw	a0,20(s0)
9d001f88:	0f400918 	jal	9d002460 <_ZN4DSPI8transferEm>
9d001f8c:	24050003 	li	a1,3
    _spi->transfer((chipaddress >> 16) & 0xFF);
9d001f90:	8e040014 	lw	a0,20(s0)
9d001f94:	0f400918 	jal	9d002460 <_ZN4DSPI8transferEm>
9d001f98:	7e253c00 	ext	a1,s1,0x10,0x8
    _spi->transfer((chipaddress >> 8) & 0xFF);
9d001f9c:	8e040014 	lw	a0,20(s0)
9d001fa0:	0f400918 	jal	9d002460 <_ZN4DSPI8transferEm>
9d001fa4:	7e253a00 	ext	a1,s1,0x8,0x8
    _spi->transfer((chipaddress >> 0) & 0xFF);
9d001fa8:	8e040014 	lw	a0,20(s0)
9d001fac:	0f400918 	jal	9d002460 <_ZN4DSPI8transferEm>
9d001fb0:	322500ff 	andi	a1,s1,0xff
    b = _spi->transfer(0x00);
9d001fb4:	8e040014 	lw	a0,20(s0)
9d001fb8:	0f400918 	jal	9d002460 <_ZN4DSPI8transferEm>
9d001fbc:	00002821 	move	a1,zero
    digitalWrite(_cs[chipno], HIGH);
9d001fc0:	92440009 	lbu	a0,9(s2)
9d001fc4:	24050001 	li	a1,1
9d001fc8:	0f400b0e 	jal	9d002c38 <digitalWrite>
9d001fcc:	afa20010 	sw	v0,16(sp)
    return b;
}
9d001fd0:	8fa20010 	lw	v0,16(sp)
9d001fd4:	8fbf0024 	lw	ra,36(sp)
9d001fd8:	8fb20020 	lw	s2,32(sp)
9d001fdc:	304200ff 	andi	v0,v0,0xff
9d001fe0:	8fb1001c 	lw	s1,28(sp)
9d001fe4:	8fb00018 	lw	s0,24(sp)
9d001fe8:	03e00008 	jr	ra
9d001fec:	27bd0028 	addiu	sp,sp,40

9d001ff0 <_ZN6SPIRAM4readEmPhm>:

void SPIRAM::read(uint32_t address, uint8_t *b, uint32_t len) {
9d001ff0:	27bdffc8 	addiu	sp,sp,-56
9d001ff4:	afb7002c 	sw	s7,44(sp)
9d001ff8:	afb40020 	sw	s4,32(sp)
9d001ffc:	afb3001c 	sw	s3,28(sp)
9d002000:	afb00010 	sw	s0,16(sp)
9d002004:	afbf0034 	sw	ra,52(sp)
9d002008:	afbe0030 	sw	s8,48(sp)
9d00200c:	afb60028 	sw	s6,40(sp)
9d002010:	afb50024 	sw	s5,36(sp)
9d002014:	afb20018 	sw	s2,24(sp)
9d002018:	afb10014 	sw	s1,20(sp)
9d00201c:	00e09821 	move	s3,a3
9d002020:	00808021 	move	s0,a0
9d002024:	00a0a021 	move	s4,a1
    uint32_t ptr = 0;
    while (len > 0) {
9d002028:	10e0002d 	beqz	a3,9d0020e0 <_ZN6SPIRAM4readEmPhm+0xf0>
9d00202c:	00c0b821 	move	s7,a2
9d002030:	0000b021 	move	s6,zero
        uint32_t chipno = (address / _chipsize);
9d002034:	8e110004 	lw	s1,4(s0)
        uint32_t chipaddress = address - (chipno * _chipsize);
        uint32_t chipleft = _chipsize - chipaddress;
        
        uint32_t toread = (chipleft < len) ? chipleft : len;
        digitalWrite(_cs[chipno], LOW);
9d002038:	00002821 	move	a1,zero
}

void SPIRAM::read(uint32_t address, uint8_t *b, uint32_t len) {
    uint32_t ptr = 0;
    while (len > 0) {
        uint32_t chipno = (address / _chipsize);
9d00203c:	0291001b 	divu	zero,s4,s1
9d002040:	022001f4 	teq	s1,zero,0x7
9d002044:	0000a812 	mflo	s5
        uint32_t chipaddress = address - (chipno * _chipsize);
9d002048:	72b11002 	mul	v0,s5,s1
        uint32_t chipleft = _chipsize - chipaddress;
        
        uint32_t toread = (chipleft < len) ? chipleft : len;
        digitalWrite(_cs[chipno], LOW);
9d00204c:	0215a821 	addu	s5,s0,s5
9d002050:	92a40009 	lbu	a0,9(s5)

void SPIRAM::read(uint32_t address, uint8_t *b, uint32_t len) {
    uint32_t ptr = 0;
    while (len > 0) {
        uint32_t chipno = (address / _chipsize);
        uint32_t chipaddress = address - (chipno * _chipsize);
9d002054:	02829023 	subu	s2,s4,v0
        uint32_t chipleft = _chipsize - chipaddress;
9d002058:	02328823 	subu	s1,s1,s2

void SPIRAM::read(uint32_t address, uint8_t *b, uint32_t len) {
    uint32_t ptr = 0;
    while (len > 0) {
        uint32_t chipno = (address / _chipsize);
        uint32_t chipaddress = address - (chipno * _chipsize);
9d00205c:	0271102b 	sltu	v0,s3,s1
        uint32_t chipleft = _chipsize - chipaddress;
        
        uint32_t toread = (chipleft < len) ? chipleft : len;
        digitalWrite(_cs[chipno], LOW);
9d002060:	0f400b0e 	jal	9d002c38 <digitalWrite>
9d002064:	0262880b 	movn	s1,s3,v0
        _spi->transfer(0x03);
9d002068:	8e040014 	lw	a0,20(s0)
9d00206c:	0f400918 	jal	9d002460 <_ZN4DSPI8transferEm>
9d002070:	24050003 	li	a1,3
        _spi->transfer((chipaddress >> 16) & 0xFF);
9d002074:	8e040014 	lw	a0,20(s0)
9d002078:	0f400918 	jal	9d002460 <_ZN4DSPI8transferEm>
9d00207c:	7e453c00 	ext	a1,s2,0x10,0x8
        _spi->transfer((chipaddress >> 8) & 0xFF);
9d002080:	8e040014 	lw	a0,20(s0)
9d002084:	0f400918 	jal	9d002460 <_ZN4DSPI8transferEm>
9d002088:	7e453a00 	ext	a1,s2,0x8,0x8
        _spi->transfer((chipaddress >> 0) & 0xFF);
9d00208c:	8e040014 	lw	a0,20(s0)
9d002090:	0f400918 	jal	9d002460 <_ZN4DSPI8transferEm>
9d002094:	324500ff 	andi	a1,s2,0xff
        for (uint32_t i = 0; i < toread; i++) {
9d002098:	1220000b 	beqz	s1,9d0020c8 <_ZN6SPIRAM4readEmPhm+0xd8>
9d00209c:	00009021 	move	s2,zero
    b = _spi->transfer(0x00);
    digitalWrite(_cs[chipno], HIGH);
    return b;
}

void SPIRAM::read(uint32_t address, uint8_t *b, uint32_t len) {
9d0020a0:	02f6f021 	addu	s8,s7,s6
        _spi->transfer(0x03);
        _spi->transfer((chipaddress >> 16) & 0xFF);
        _spi->transfer((chipaddress >> 8) & 0xFF);
        _spi->transfer((chipaddress >> 0) & 0xFF);
        for (uint32_t i = 0; i < toread; i++) {
            b[ptr++] = _spi->transfer(0x00);
9d0020a4:	8e040014 	lw	a0,20(s0)
9d0020a8:	00002821 	move	a1,zero
9d0020ac:	0f400918 	jal	9d002460 <_ZN4DSPI8transferEm>
9d0020b0:	26520001 	addiu	s2,s2,1
        digitalWrite(_cs[chipno], LOW);
        _spi->transfer(0x03);
        _spi->transfer((chipaddress >> 16) & 0xFF);
        _spi->transfer((chipaddress >> 8) & 0xFF);
        _spi->transfer((chipaddress >> 0) & 0xFF);
        for (uint32_t i = 0; i < toread; i++) {
9d0020b4:	0251182b 	sltu	v1,s2,s1
            b[ptr++] = _spi->transfer(0x00);
9d0020b8:	a3c20000 	sb	v0,0(s8)
        digitalWrite(_cs[chipno], LOW);
        _spi->transfer(0x03);
        _spi->transfer((chipaddress >> 16) & 0xFF);
        _spi->transfer((chipaddress >> 8) & 0xFF);
        _spi->transfer((chipaddress >> 0) & 0xFF);
        for (uint32_t i = 0; i < toread; i++) {
9d0020bc:	1460fff9 	bnez	v1,9d0020a4 <_ZN6SPIRAM4readEmPhm+0xb4>
9d0020c0:	27de0001 	addiu	s8,s8,1
9d0020c4:	02d1b021 	addu	s6,s6,s1
            b[ptr++] = _spi->transfer(0x00);
        }
        digitalWrite(_cs[chipno], HIGH);
9d0020c8:	92a40009 	lbu	a0,9(s5)
        address += toread;
        len -= toread;
9d0020cc:	02719823 	subu	s3,s3,s1
        _spi->transfer((chipaddress >> 8) & 0xFF);
        _spi->transfer((chipaddress >> 0) & 0xFF);
        for (uint32_t i = 0; i < toread; i++) {
            b[ptr++] = _spi->transfer(0x00);
        }
        digitalWrite(_cs[chipno], HIGH);
9d0020d0:	0f400b0e 	jal	9d002c38 <digitalWrite>
9d0020d4:	24050001 	li	a1,1
    return b;
}

void SPIRAM::read(uint32_t address, uint8_t *b, uint32_t len) {
    uint32_t ptr = 0;
    while (len > 0) {
9d0020d8:	1660ffd6 	bnez	s3,9d002034 <_ZN6SPIRAM4readEmPhm+0x44>
9d0020dc:	0291a021 	addu	s4,s4,s1
        }
        digitalWrite(_cs[chipno], HIGH);
        address += toread;
        len -= toread;
    }
}
9d0020e0:	8fbf0034 	lw	ra,52(sp)
9d0020e4:	8fbe0030 	lw	s8,48(sp)
9d0020e8:	8fb7002c 	lw	s7,44(sp)
9d0020ec:	8fb60028 	lw	s6,40(sp)
9d0020f0:	8fb50024 	lw	s5,36(sp)
9d0020f4:	8fb40020 	lw	s4,32(sp)
9d0020f8:	8fb3001c 	lw	s3,28(sp)
9d0020fc:	8fb20018 	lw	s2,24(sp)
9d002100:	8fb10014 	lw	s1,20(sp)
9d002104:	8fb00010 	lw	s0,16(sp)
9d002108:	03e00008 	jr	ra
9d00210c:	27bd0038 	addiu	sp,sp,56

9d002110 <_ZN6SPIRAM5writeEmh>:

void SPIRAM::write(uint32_t address, uint8_t b) {

    uint32_t chipno = (address / _chipsize);
9d002110:	8c820004 	lw	v0,4(a0)
        address += toread;
        len -= toread;
    }
}

void SPIRAM::write(uint32_t address, uint8_t b) {
9d002114:	27bdffd8 	addiu	sp,sp,-40
9d002118:	afb10018 	sw	s1,24(sp)
9d00211c:	00a08821 	move	s1,a1

    uint32_t chipno = (address / _chipsize);
9d002120:	0222001b 	divu	zero,s1,v0
9d002124:	004001f4 	teq	v0,zero,0x7
        address += toread;
        len -= toread;
    }
}

void SPIRAM::write(uint32_t address, uint8_t b) {
9d002128:	afb2001c 	sw	s2,28(sp)
9d00212c:	afbf0024 	sw	ra,36(sp)
9d002130:	afb30020 	sw	s3,32(sp)
9d002134:	afb00014 	sw	s0,20(sp)
9d002138:	00808021 	move	s0,a0

    uint32_t chipno = (address / _chipsize);
    uint32_t chipaddress = address - (chipno * _chipsize);

    digitalWrite(_cs[chipno], LOW);
9d00213c:	00002821 	move	a1,zero
        address += toread;
        len -= toread;
    }
}

void SPIRAM::write(uint32_t address, uint8_t b) {
9d002140:	30d300ff 	andi	s3,a2,0xff

    uint32_t chipno = (address / _chipsize);
9d002144:	00009012 	mflo	s2
    uint32_t chipaddress = address - (chipno * _chipsize);
9d002148:	72421802 	mul	v1,s2,v0

    digitalWrite(_cs[chipno], LOW);
9d00214c:	00929021 	addu	s2,a0,s2
9d002150:	92440009 	lbu	a0,9(s2)
9d002154:	0f400b0e 	jal	9d002c38 <digitalWrite>
9d002158:	02238823 	subu	s1,s1,v1
    _spi->transfer(0x02);
9d00215c:	8e040014 	lw	a0,20(s0)
9d002160:	0f400918 	jal	9d002460 <_ZN4DSPI8transferEm>
9d002164:	24050002 	li	a1,2
    _spi->transfer((chipaddress >> 16) & 0xFF);
9d002168:	8e040014 	lw	a0,20(s0)
9d00216c:	0f400918 	jal	9d002460 <_ZN4DSPI8transferEm>
9d002170:	7e253c00 	ext	a1,s1,0x10,0x8
    _spi->transfer((chipaddress >> 8) & 0xFF);
9d002174:	8e040014 	lw	a0,20(s0)
9d002178:	0f400918 	jal	9d002460 <_ZN4DSPI8transferEm>
9d00217c:	7e253a00 	ext	a1,s1,0x8,0x8
    _spi->transfer((chipaddress >> 0) & 0xFF);
9d002180:	8e040014 	lw	a0,20(s0)
9d002184:	0f400918 	jal	9d002460 <_ZN4DSPI8transferEm>
9d002188:	322500ff 	andi	a1,s1,0xff
    _spi->transfer(b);
9d00218c:	8e040014 	lw	a0,20(s0)
9d002190:	0f400918 	jal	9d002460 <_ZN4DSPI8transferEm>
9d002194:	02602821 	move	a1,s3
    digitalWrite(_cs[chipno], HIGH);
9d002198:	92440009 	lbu	a0,9(s2)
}
9d00219c:	8fbf0024 	lw	ra,36(sp)
9d0021a0:	8fb30020 	lw	s3,32(sp)
9d0021a4:	8fb2001c 	lw	s2,28(sp)
9d0021a8:	8fb10018 	lw	s1,24(sp)
9d0021ac:	8fb00014 	lw	s0,20(sp)
    _spi->transfer(0x02);
    _spi->transfer((chipaddress >> 16) & 0xFF);
    _spi->transfer((chipaddress >> 8) & 0xFF);
    _spi->transfer((chipaddress >> 0) & 0xFF);
    _spi->transfer(b);
    digitalWrite(_cs[chipno], HIGH);
9d0021b0:	24050001 	li	a1,1
9d0021b4:	0b400b0e 	j	9d002c38 <digitalWrite>
9d0021b8:	27bd0028 	addiu	sp,sp,40

9d0021bc <_ZN6SPIRAM5writeEmPhm>:
}

void SPIRAM::write(uint32_t address, uint8_t *b, uint32_t len) {
9d0021bc:	27bdffc8 	addiu	sp,sp,-56
9d0021c0:	afb7002c 	sw	s7,44(sp)
9d0021c4:	afb40020 	sw	s4,32(sp)
9d0021c8:	afb3001c 	sw	s3,28(sp)
9d0021cc:	afb00010 	sw	s0,16(sp)
9d0021d0:	afbf0034 	sw	ra,52(sp)
9d0021d4:	afbe0030 	sw	s8,48(sp)
9d0021d8:	afb60028 	sw	s6,40(sp)
9d0021dc:	afb50024 	sw	s5,36(sp)
9d0021e0:	afb20018 	sw	s2,24(sp)
9d0021e4:	afb10014 	sw	s1,20(sp)
9d0021e8:	00e09821 	move	s3,a3
9d0021ec:	00808021 	move	s0,a0
9d0021f0:	00a0a021 	move	s4,a1
    uint32_t ptr = 0;
    while (len > 0) {
9d0021f4:	10e0002d 	beqz	a3,9d0022ac <_ZN6SPIRAM5writeEmPhm+0xf0>
9d0021f8:	00c0b821 	move	s7,a2
9d0021fc:	0000b021 	move	s6,zero
        uint32_t chipno = (address / _chipsize);
9d002200:	8e110004 	lw	s1,4(s0)
        uint32_t chipaddress = address - (chipno * _chipsize);
        uint32_t chipleft = _chipsize - chipaddress;
        
        uint32_t towrite = (chipleft < len) ? chipleft : len;
        digitalWrite(_cs[chipno], LOW);
9d002204:	00002821 	move	a1,zero
}

void SPIRAM::write(uint32_t address, uint8_t *b, uint32_t len) {
    uint32_t ptr = 0;
    while (len > 0) {
        uint32_t chipno = (address / _chipsize);
9d002208:	0291001b 	divu	zero,s4,s1
9d00220c:	022001f4 	teq	s1,zero,0x7
9d002210:	0000a812 	mflo	s5
        uint32_t chipaddress = address - (chipno * _chipsize);
9d002214:	72b11002 	mul	v0,s5,s1
        uint32_t chipleft = _chipsize - chipaddress;
        
        uint32_t towrite = (chipleft < len) ? chipleft : len;
        digitalWrite(_cs[chipno], LOW);
9d002218:	0215a821 	addu	s5,s0,s5
9d00221c:	92a40009 	lbu	a0,9(s5)

void SPIRAM::write(uint32_t address, uint8_t *b, uint32_t len) {
    uint32_t ptr = 0;
    while (len > 0) {
        uint32_t chipno = (address / _chipsize);
        uint32_t chipaddress = address - (chipno * _chipsize);
9d002220:	02829023 	subu	s2,s4,v0
        uint32_t chipleft = _chipsize - chipaddress;
9d002224:	02328823 	subu	s1,s1,s2

void SPIRAM::write(uint32_t address, uint8_t *b, uint32_t len) {
    uint32_t ptr = 0;
    while (len > 0) {
        uint32_t chipno = (address / _chipsize);
        uint32_t chipaddress = address - (chipno * _chipsize);
9d002228:	0271102b 	sltu	v0,s3,s1
        uint32_t chipleft = _chipsize - chipaddress;
        
        uint32_t towrite = (chipleft < len) ? chipleft : len;
        digitalWrite(_cs[chipno], LOW);
9d00222c:	0f400b0e 	jal	9d002c38 <digitalWrite>
9d002230:	0262880b 	movn	s1,s3,v0
        _spi->transfer(0x02);
9d002234:	8e040014 	lw	a0,20(s0)
9d002238:	0f400918 	jal	9d002460 <_ZN4DSPI8transferEm>
9d00223c:	24050002 	li	a1,2
        _spi->transfer((chipaddress >> 16) & 0xFF);
9d002240:	8e040014 	lw	a0,20(s0)
9d002244:	0f400918 	jal	9d002460 <_ZN4DSPI8transferEm>
9d002248:	7e453c00 	ext	a1,s2,0x10,0x8
        _spi->transfer((chipaddress >> 8) & 0xFF);
9d00224c:	8e040014 	lw	a0,20(s0)
9d002250:	0f400918 	jal	9d002460 <_ZN4DSPI8transferEm>
9d002254:	7e453a00 	ext	a1,s2,0x8,0x8
        _spi->transfer((chipaddress >> 0) & 0xFF);
9d002258:	8e040014 	lw	a0,20(s0)
9d00225c:	0f400918 	jal	9d002460 <_ZN4DSPI8transferEm>
9d002260:	324500ff 	andi	a1,s2,0xff
        for (uint32_t i = 0; i < towrite; i++) {
9d002264:	1220000b 	beqz	s1,9d002294 <_ZN6SPIRAM5writeEmPhm+0xd8>
9d002268:	00009021 	move	s2,zero
    _spi->transfer((chipaddress >> 0) & 0xFF);
    _spi->transfer(b);
    digitalWrite(_cs[chipno], HIGH);
}

void SPIRAM::write(uint32_t address, uint8_t *b, uint32_t len) {
9d00226c:	02f6f021 	addu	s8,s7,s6
        _spi->transfer(0x02);
        _spi->transfer((chipaddress >> 16) & 0xFF);
        _spi->transfer((chipaddress >> 8) & 0xFF);
        _spi->transfer((chipaddress >> 0) & 0xFF);
        for (uint32_t i = 0; i < towrite; i++) {
            _spi->transfer(b[ptr++]);
9d002270:	93c50000 	lbu	a1,0(s8)
9d002274:	8e040014 	lw	a0,20(s0)
        digitalWrite(_cs[chipno], LOW);
        _spi->transfer(0x02);
        _spi->transfer((chipaddress >> 16) & 0xFF);
        _spi->transfer((chipaddress >> 8) & 0xFF);
        _spi->transfer((chipaddress >> 0) & 0xFF);
        for (uint32_t i = 0; i < towrite; i++) {
9d002278:	26520001 	addiu	s2,s2,1
            _spi->transfer(b[ptr++]);
9d00227c:	0f400918 	jal	9d002460 <_ZN4DSPI8transferEm>
9d002280:	27de0001 	addiu	s8,s8,1
        digitalWrite(_cs[chipno], LOW);
        _spi->transfer(0x02);
        _spi->transfer((chipaddress >> 16) & 0xFF);
        _spi->transfer((chipaddress >> 8) & 0xFF);
        _spi->transfer((chipaddress >> 0) & 0xFF);
        for (uint32_t i = 0; i < towrite; i++) {
9d002284:	0251102b 	sltu	v0,s2,s1
9d002288:	5440fffa 	bnezl	v0,9d002274 <_ZN6SPIRAM5writeEmPhm+0xb8>
9d00228c:	93c50000 	lbu	a1,0(s8)
9d002290:	02d1b021 	addu	s6,s6,s1
            _spi->transfer(b[ptr++]);
        }
        digitalWrite(_cs[chipno], HIGH);
9d002294:	92a40009 	lbu	a0,9(s5)
        address += towrite;
        len -= towrite;
9d002298:	02719823 	subu	s3,s3,s1
        _spi->transfer((chipaddress >> 8) & 0xFF);
        _spi->transfer((chipaddress >> 0) & 0xFF);
        for (uint32_t i = 0; i < towrite; i++) {
            _spi->transfer(b[ptr++]);
        }
        digitalWrite(_cs[chipno], HIGH);
9d00229c:	0f400b0e 	jal	9d002c38 <digitalWrite>
9d0022a0:	24050001 	li	a1,1
    digitalWrite(_cs[chipno], HIGH);
}

void SPIRAM::write(uint32_t address, uint8_t *b, uint32_t len) {
    uint32_t ptr = 0;
    while (len > 0) {
9d0022a4:	1660ffd6 	bnez	s3,9d002200 <_ZN6SPIRAM5writeEmPhm+0x44>
9d0022a8:	0291a021 	addu	s4,s4,s1
        }
        digitalWrite(_cs[chipno], HIGH);
        address += towrite;
        len -= towrite;
    }
}
9d0022ac:	8fbf0034 	lw	ra,52(sp)
9d0022b0:	8fbe0030 	lw	s8,48(sp)
9d0022b4:	8fb7002c 	lw	s7,44(sp)
9d0022b8:	8fb60028 	lw	s6,40(sp)
9d0022bc:	8fb50024 	lw	s5,36(sp)
9d0022c0:	8fb40020 	lw	s4,32(sp)
9d0022c4:	8fb3001c 	lw	s3,28(sp)
9d0022c8:	8fb20018 	lw	s2,24(sp)
9d0022cc:	8fb10014 	lw	s1,20(sp)
9d0022d0:	8fb00010 	lw	s0,16(sp)
9d0022d4:	03e00008 	jr	ra
9d0022d8:	27bd0038 	addiu	sp,sp,56

9d0022dc <_ZN4DSPI8setSpeedEm>:

	uint16_t	brg;

	/* Compute the baud rate divider for this frequency.
	*/
	brg = (uint16_t)((F_CPU / (2 * spd)) - 1);
9d0022dc:	3c0204c4 	lui	v0,0x4c4
9d0022e0:	3442b400 	ori	v0,v0,0xb400
9d0022e4:	00052840 	sll	a1,a1,0x1
9d0022e8:	0045001b 	divu	zero,v0,a1
9d0022ec:	00a001f4 	teq	a1,zero,0x7

	/* That the baud rate value is in the correct range.
	*/
	if (brg == 0xFFFF) {
9d0022f0:	3403ffff 	li	v1,0xffff

	uint16_t	brg;

	/* Compute the baud rate divider for this frequency.
	*/
	brg = (uint16_t)((F_CPU / (2 * spd)) - 1);
9d0022f4:	00001012 	mflo	v0
9d0022f8:	2442ffff 	addiu	v0,v0,-1
9d0022fc:	3042ffff 	andi	v0,v0,0xffff

	/* That the baud rate value is in the correct range.
	*/
	if (brg == 0xFFFF) {
9d002300:	1043000a 	beq	v0,v1,9d00232c <_ZN4DSPI8setSpeedEm+0x50>
9d002304:	2c430200 	sltiu	v1,v0,512
		** Set it to the highest supported frequency.
		*/
		brg = 0;
	}

	if (brg > 0x1FF) {
9d002308:	14600009 	bnez	v1,9d002330 <_ZN4DSPI8setSpeedEm+0x54>
9d00230c:	240501ff 	li	a1,511

	/* Write the value to the SPI baud rate register. Section 23. SPI
	** of the PIC32 Family Reference Manual says to disable the SPI
	** controller before writing to the baud register
	*/
	pspi->sxCon.clr = (1 << _SPICON_ON);	// disable SPI
9d002310:	8c820020 	lw	v0,32(a0)
9d002314:	34038000 	li	v1,0x8000
9d002318:	ac430004 	sw	v1,4(v0)
	pspi->sxBrg.reg = brg;
9d00231c:	ac450030 	sw	a1,48(v0)
	pspi->sxCon.set = (1 << _SPICON_ON);	// enable SPI
9d002320:	ac430008 	sw	v1,8(v0)

}
9d002324:	03e00008 	jr	ra
9d002328:	00000000 	nop
	*/
	if (brg == 0xFFFF) {
		/* The user tried to set a frequency that is too high to support.
		** Set it to the highest supported frequency.
		*/
		brg = 0;
9d00232c:	00001021 	move	v0,zero
	}

	if (brg > 0x1FF) {
9d002330:	00402821 	move	a1,v0

	/* Write the value to the SPI baud rate register. Section 23. SPI
	** of the PIC32 Family Reference Manual says to disable the SPI
	** controller before writing to the baud register
	*/
	pspi->sxCon.clr = (1 << _SPICON_ON);	// disable SPI
9d002334:	8c820020 	lw	v0,32(a0)
9d002338:	34038000 	li	v1,0x8000
9d00233c:	ac430004 	sw	v1,4(v0)
	pspi->sxBrg.reg = brg;
9d002340:	ac450030 	sw	a1,48(v0)
	pspi->sxCon.set = (1 << _SPICON_ON);	// enable SPI
9d002344:	ac430008 	sw	v1,8(v0)

}
9d002348:	03e00008 	jr	ra
9d00234c:	00000000 	nop

9d002350 <_ZN4DSPI12setPinSelectEh>:
**		pin be an output driving high. This pin will then be use
**		by the setSelect method.
*/

void
DSPI::setPinSelect(uint8_t pin) {
9d002350:	27bdffe8 	addiu	sp,sp,-24
9d002354:	afb00010 	sw	s0,16(sp)
9d002358:	30a200ff 	andi	v0,a1,0xff
9d00235c:	00808021 	move	s0,a0
9d002360:	afbf0014 	sw	ra,20(sp)

	pinSS = pin;

	pinMode(pinSS, OUTPUT);
9d002364:	00402021 	move	a0,v0
9d002368:	24050001 	li	a1,1
9d00236c:	0f400aa8 	jal	9d002aa0 <pinMode>
9d002370:	a202002a 	sb	v0,42(s0)
	digitalWrite(pinSS, HIGH);
9d002374:	9204002a 	lbu	a0,42(s0)

}
9d002378:	8fbf0014 	lw	ra,20(sp)
9d00237c:	8fb00010 	lw	s0,16(sp)
DSPI::setPinSelect(uint8_t pin) {

	pinSS = pin;

	pinMode(pinSS, OUTPUT);
	digitalWrite(pinSS, HIGH);
9d002380:	24050001 	li	a1,1
9d002384:	0b400b0e 	j	9d002c38 <digitalWrite>
9d002388:	27bd0018 	addiu	sp,sp,24

9d00238c <_ZN4DSPI5beginEh>:
**		will set the clock rate to the default speed and the
**		pin for SS to the specified pin.
*/

void
DSPI::begin(uint8_t pinT) {
9d00238c:	27bdffe0 	addiu	sp,sp,-32
9d002390:	afbf001c 	sw	ra,28(sp)
9d002394:	afb10018 	sw	s1,24(sp)
9d002398:	afb00014 	sw	s0,20(sp)
9d00239c:	00808021 	move	s0,a0
9d0023a0:	30b100ff 	andi	s1,a1,0xff
	*/
    mapPps(pinMOSI, ppsMOSI);
#endif

    // set up the interrupt handler 
    setIntVector(vec, isr);
9d0023a4:	90840028 	lbu	a0,40(a0)
9d0023a8:	0f400bf5 	jal	9d002fd4 <setIntVector>
9d0023ac:	8e050024 	lw	a1,36(s0)
/* Initialize the pins. The pin directions for SDO, SDI and SCK
	** are set automatically when the SPI controller is enabled. The
	** SS pin isn't explicitly used by the SPI controller when in
	** master mode, so we need to initialize it ourselves.
	*/
	setPinSelect(pinT);
9d0023b0:	02002021 	move	a0,s0
9d0023b4:	0f4008d4 	jal	9d002350 <_ZN4DSPI12setPinSelectEh>
9d0023b8:	02202821 	move	a1,s1

	/* Disable interrupts on this SPI controller.
	*/
	pregIec->clr = bitErr + bitRx + bitTx;
9d0023bc:	8e07000c 	lw	a3,12(s0)
9d0023c0:	8e030008 	lw	v1,8(s0)
9d0023c4:	8e060010 	lw	a2,16(s0)
9d0023c8:	8e050004 	lw	a1,4(s0)

	/* Disable and reset the SPI controller.
	*/
	pspi->sxCon.reg = 0;
9d0023cc:	8e020020 	lw	v0,32(s0)
	*/
	bTmp = pspi->sxBuf.reg;

	/* Clear all SPI interrupt flags.
	*/
	pregIfs->clr = bitErr + bitRx + bitTx;
9d0023d0:	8e040000 	lw	a0,0(s0)
	*/
	setPinSelect(pinT);

	/* Disable interrupts on this SPI controller.
	*/
	pregIec->clr = bitErr + bitRx + bitTx;
9d0023d4:	00e31821 	addu	v1,a3,v1
9d0023d8:	00661821 	addu	v1,v1,a2
9d0023dc:	aca30004 	sw	v1,4(a1)

	/* Disable and reset the SPI controller.
	*/
	pspi->sxCon.reg = 0;
9d0023e0:	ac400000 	sw	zero,0(v0)

	/* Clear the receive buffer.
	*/
	bTmp = pspi->sxBuf.reg;
9d0023e4:	8c450020 	lw	a1,32(v0)

	/* Clear all SPI interrupt flags.
	*/
	pregIfs->clr = bitErr + bitRx + bitTx;
9d0023e8:	ac830004 	sw	v1,4(a0)

	/* Compute the address of the interrupt priority control register
	** used by this SPI controller.
	*/
	pregIpc = ((p32_regset *)&IPC0) + (vec / 4);	// interrupt priority control register
9d0023ec:	92040028 	lbu	a0,40(s0)
9d0023f0:	3c03bf88 	lui	v1,0xbf88
9d0023f4:	24631090 	addiu	v1,v1,4240
9d0023f8:	00042882 	srl	a1,a0,0x2
9d0023fc:	00052900 	sll	a1,a1,0x4

	/* Compute the bit position of the interrupt priority bits for
	** this interrupt vector.
	*/
	bnVec = 8 * (vec % 4);
9d002400:	30840003 	andi	a0,a0,0x3
	pregIfs->clr = bitErr + bitRx + bitTx;

	/* Compute the address of the interrupt priority control register
	** used by this SPI controller.
	*/
	pregIpc = ((p32_regset *)&IPC0) + (vec / 4);	// interrupt priority control register
9d002404:	00651821 	addu	v1,v1,a1

	/* Compute the bit position of the interrupt priority bits for
	** this interrupt vector.
	*/
	bnVec = 8 * (vec % 4);
9d002408:	000420c0 	sll	a0,a0,0x3
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	pregIpc->clr = (0x1F << bnVec);
9d00240c:	2405001f 	li	a1,31
9d002410:	00852804 	sllv	a1,a1,a0
9d002414:	ac650004 	sw	a1,4(v1)
	pregIpc->set = ipl << bnVec;
9d002418:	92050029 	lbu	a1,41(s0)
9d00241c:	00852004 	sllv	a0,a1,a0
9d002420:	ac640008 	sw	a0,8(v1)

	/* Set the default baud rate.
	*/
	brg = (uint16_t)((F_CPU / (2 * _DSPI_SPD_DEFAULT)) - 1);
	pspi->sxBrg.reg = brg;
9d002424:	24030027 	li	v1,39
9d002428:	ac430030 	sw	v1,48(v0)

	/* Clear the receive overflow bit and receive overflow error flag
	*/
	pspi->sxStat.clr = (1 << _SPISTAT_SPIROV);
9d00242c:	24030040 	li	v1,64
9d002430:	ac430014 	sw	v1,20(v0)
	fRov = 0;
9d002434:	a200001f 	sb	zero,31(s0)
	** the SS pin MUST be kept as OUTPUT.
	*/
	pspi->sxCon.reg = 0;
	pspi->sxCon.set = (1 << _SPICON_ON) + (1 << _SPICON_MSTEN) + DSPI_MODE0;

}	
9d002438:	8fbf001c 	lw	ra,28(sp)
	** Warning: if the SS pin ever becomes a LOW INPUT then SPI 
	** automatically switches to Slave, so the data direction of 
	** the SS pin MUST be kept as OUTPUT.
	*/
	pspi->sxCon.reg = 0;
	pspi->sxCon.set = (1 << _SPICON_ON) + (1 << _SPICON_MSTEN) + DSPI_MODE0;
9d00243c:	34038120 	li	v1,0x8120
	/* Enable the SPI controller.
	** Warning: if the SS pin ever becomes a LOW INPUT then SPI 
	** automatically switches to Slave, so the data direction of 
	** the SS pin MUST be kept as OUTPUT.
	*/
	pspi->sxCon.reg = 0;
9d002440:	ac400000 	sw	zero,0(v0)
	pspi->sxCon.set = (1 << _SPICON_ON) + (1 << _SPICON_MSTEN) + DSPI_MODE0;

}	
9d002444:	8fb10018 	lw	s1,24(sp)
9d002448:	8fb00014 	lw	s0,20(sp)
	** Warning: if the SS pin ever becomes a LOW INPUT then SPI 
	** automatically switches to Slave, so the data direction of 
	** the SS pin MUST be kept as OUTPUT.
	*/
	pspi->sxCon.reg = 0;
	pspi->sxCon.set = (1 << _SPICON_ON) + (1 << _SPICON_MSTEN) + DSPI_MODE0;
9d00244c:	ac430008 	sw	v1,8(v0)

}	
9d002450:	03e00008 	jr	ra
9d002454:	27bd0020 	addiu	sp,sp,32

9d002458 <_ZN4DSPI5beginEv>:
void
DSPI::begin() {

	/* Use the default pin specified in the constructor.
	*/
	begin(pinSS);
9d002458:	0b4008e3 	j	9d00238c <_ZN4DSPI5beginEh>
9d00245c:	9085002a 	lbu	a1,42(a0)

9d002460 <_ZN4DSPI8transferEm>:
**		Send the specified byte to the SPI slave device, returning
**		the byte received from the slave device.
*/

uint32_t
DSPI::transfer(uint32_t bVal) {
9d002460:	8c820020 	lw	v0,32(a0)

	while ((pspi->sxStat.reg & (1 << _SPISTAT_SPITBE)) == 0) {
9d002464:	8c430010 	lw	v1,16(v0)
9d002468:	30630008 	andi	v1,v1,0x8
9d00246c:	1060fffd 	beqz	v1,9d002464 <_ZN4DSPI8transferEm+0x4>
9d002470:	00000000 	nop
	}
	pspi->sxBuf.reg = bVal;
9d002474:	ac450020 	sw	a1,32(v0)

	while ((pspi->sxStat.reg & (1 << _SPISTAT_SPIRBF)) == 0) {
9d002478:	8c430010 	lw	v1,16(v0)
9d00247c:	30630001 	andi	v1,v1,0x1
9d002480:	1060fffd 	beqz	v1,9d002478 <_ZN4DSPI8transferEm+0x18>
9d002484:	00000000 	nop
	}

	return pspi->sxBuf.reg;
9d002488:	8c420020 	lw	v0,32(v0)

}
9d00248c:	03e00008 	jr	ra
9d002490:	00000000 	nop

9d002494 <_ZN4DSPI15doDspiInterruptEv>:
	uint8_t		bTmp;
	uint32_t	regIfs;

	/* Get the interrupt flag status.
	*/
	regIfs = pregIfs->reg;
9d002494:	8c820000 	lw	v0,0(a0)

	/* Check for and handle overrun error interrupt.
	*/
	if ((regIfs & bitErr) != 0) {
9d002498:	8c830008 	lw	v1,8(a0)
	uint8_t		bTmp;
	uint32_t	regIfs;

	/* Get the interrupt flag status.
	*/
	regIfs = pregIfs->reg;
9d00249c:	8c450000 	lw	a1,0(v0)

	/* Check for and handle overrun error interrupt.
	*/
	if ((regIfs & bitErr) != 0) {
9d0024a0:	00653024 	and	a2,v1,a1
9d0024a4:	50c00008 	beqzl	a2,9d0024c8 <_ZN4DSPI15doDspiInterruptEv+0x34>
9d0024a8:	8c83000c 	lw	v1,12(a0)
		fRov = 1;				// set the receive overflow error flag;
		pspi->sxStat.clr = (1 << _SPISTAT_SPIROV);	//clear status bit
9d0024ac:	8c860020 	lw	a2,32(a0)
	regIfs = pregIfs->reg;

	/* Check for and handle overrun error interrupt.
	*/
	if ((regIfs & bitErr) != 0) {
		fRov = 1;				// set the receive overflow error flag;
9d0024b0:	24070001 	li	a3,1
9d0024b4:	a087001f 	sb	a3,31(a0)
		pspi->sxStat.clr = (1 << _SPISTAT_SPIROV);	//clear status bit
9d0024b8:	24070040 	li	a3,64
9d0024bc:	acc70014 	sw	a3,20(a2)
		pregIfs->clr = bitErr;
9d0024c0:	ac430004 	sw	v1,4(v0)
	}

	/* Check for and handle receive interrupt.
	*/
	if ((regIfs & bitRx) != 0) {
9d0024c4:	8c83000c 	lw	v1,12(a0)
9d0024c8:	00a32824 	and	a1,a1,v1
9d0024cc:	10a0001d 	beqz	a1,9d002544 <_ZN4DSPI15doDspiInterruptEv+0xb0>
9d0024d0:	00000000 	nop

		/* Get the received character.
		*/
		bTmp = pspi->sxBuf.reg;		//read next byte from SPI controller
9d0024d4:	8c860020 	lw	a2,32(a0)
		cbCur -= 1;					//count this byte as received

		/* Are we storing it? pbRcvCur is 0 if we are sending only
		** and ignoring the received data.
		*/
		if (pbRcvCur != 0) {
9d0024d8:	8c850018 	lw	a1,24(a0)
	*/
	if ((regIfs & bitRx) != 0) {

		/* Get the received character.
		*/
		bTmp = pspi->sxBuf.reg;		//read next byte from SPI controller
9d0024dc:	8cc70020 	lw	a3,32(a2)
		cbCur -= 1;					//count this byte as received
9d0024e0:	9486001c 	lhu	a2,28(a0)
9d0024e4:	24c6ffff 	addiu	a2,a2,-1
9d0024e8:	30c6ffff 	andi	a2,a2,0xffff
9d0024ec:	a486001c 	sh	a2,28(a0)

		/* Are we storing it? pbRcvCur is 0 if we are sending only
		** and ignoring the received data.
		*/
		if (pbRcvCur != 0) {
9d0024f0:	10a00006 	beqz	a1,9d00250c <_ZN4DSPI15doDspiInterruptEv+0x78>
9d0024f4:	30e700ff 	andi	a3,a3,0xff
			*pbRcvCur++ = bTmp;		//store the received byte into output buffer
9d0024f8:	a0a70000 	sb	a3,0(a1)
9d0024fc:	8c820000 	lw	v0,0(a0)
9d002500:	8c83000c 	lw	v1,12(a0)
9d002504:	24a50001 	addiu	a1,a1,1
9d002508:	ac850018 	sw	a1,24(a0)
		}

		/* Send the next byte to the slave. pbSndCur is 0 if we are
		** receiving only. In this case send the pad byte.
		*/
		if (cbCur > 0) {
9d00250c:	9485001c 	lhu	a1,28(a0)
9d002510:	30a5ffff 	andi	a1,a1,0xffff
9d002514:	10a0000a 	beqz	a1,9d002540 <_ZN4DSPI15doDspiInterruptEv+0xac>
9d002518:	00000000 	nop
			bTmp = (pbSndCur != 0) ? *pbSndCur++ : bPad;
9d00251c:	8c850014 	lw	a1,20(a0)
9d002520:	50a0000a 	beqzl	a1,9d00254c <_ZN4DSPI15doDspiInterruptEv+0xb8>
9d002524:	9085001e 	lbu	a1,30(a0)
9d002528:	90a60000 	lbu	a2,0(a1)
9d00252c:	24a50001 	addiu	a1,a1,1
9d002530:	ac850014 	sw	a1,20(a0)
			pspi->sxBuf.reg = bTmp;
9d002534:	8c840020 	lw	a0,32(a0)

		/* Send the next byte to the slave. pbSndCur is 0 if we are
		** receiving only. In this case send the pad byte.
		*/
		if (cbCur > 0) {
			bTmp = (pbSndCur != 0) ? *pbSndCur++ : bPad;
9d002538:	30c500ff 	andi	a1,a2,0xff
			pspi->sxBuf.reg = bTmp;
9d00253c:	ac850020 	sw	a1,32(a0)
		}

		pregIfs->clr = bitRx;		//clear the receive interrupt flag
9d002540:	ac430004 	sw	v1,4(v0)
9d002544:	03e00008 	jr	ra
9d002548:	00000000 	nop
		/* Send the next byte to the slave. pbSndCur is 0 if we are
		** receiving only. In this case send the pad byte.
		*/
		if (cbCur > 0) {
			bTmp = (pbSndCur != 0) ? *pbSndCur++ : bPad;
			pspi->sxBuf.reg = bTmp;
9d00254c:	8c840020 	lw	a0,32(a0)
9d002550:	ac850020 	sw	a1,32(a0)
9d002554:	0b400950 	j	9d002540 <_ZN4DSPI15doDspiInterruptEv+0xac>
9d002558:	00000000 	nop

9d00255c <IntDspi0Handler>:
**		logical SPI port DSPI0
*/
#if defined(_DSPI0_VECTOR)

void __attribute__((interrupt(), nomips16)) IntDspi0Handler(void)
{
9d00255c:	415de800 	rdpgpr	sp,sp
9d002560:	401b7000 	mfc0	k1,c0_epc
9d002564:	401a6002 	mfc0	k0,c0_srsctl
9d002568:	27bdff90 	addiu	sp,sp,-112
9d00256c:	afbb006c 	sw	k1,108(sp)
9d002570:	401b6000 	mfc0	k1,c0_status
9d002574:	afba0068 	sw	k0,104(sp)
9d002578:	401a6800 	mfc0	k0,c0_cause
9d00257c:	001ad282 	srl	k0,k0,0xa
9d002580:	afbb0064 	sw	k1,100(sp)
9d002584:	7f5b7a84 	ins	k1,k0,0xa,0x6
9d002588:	7c1b2044 	ins	k1,zero,0x1,0x4
9d00258c:	409b6000 	mtc0	k1,c0_status
9d002590:	afa30018 	sw	v1,24(sp)
9d002594:	8fa30068 	lw	v1,104(sp)
9d002598:	3063000f 	andi	v1,v1,0xf
9d00259c:	14600011 	bnez	v1,9d0025e4 <IntDspi0Handler+0x88>
9d0025a0:	afa20014 	sw	v0,20(sp)
9d0025a4:	afbf0054 	sw	ra,84(sp)
9d0025a8:	afb90050 	sw	t9,80(sp)
9d0025ac:	afb8004c 	sw	t8,76(sp)
9d0025b0:	afaf0048 	sw	t7,72(sp)
9d0025b4:	afae0044 	sw	t6,68(sp)
9d0025b8:	afad0040 	sw	t5,64(sp)
9d0025bc:	afac003c 	sw	t4,60(sp)
9d0025c0:	afab0038 	sw	t3,56(sp)
9d0025c4:	afaa0034 	sw	t2,52(sp)
9d0025c8:	afa90030 	sw	t1,48(sp)
9d0025cc:	afa8002c 	sw	t0,44(sp)
9d0025d0:	afa70028 	sw	a3,40(sp)
9d0025d4:	afa60024 	sw	a2,36(sp)
9d0025d8:	afa50020 	sw	a1,32(sp)
9d0025dc:	afa4001c 	sw	a0,28(sp)
9d0025e0:	afa10010 	sw	at,16(sp)
	if (pdspi0 != 0) {
9d0025e4:	8f848018 	lw	a0,-32744(gp)
**		logical SPI port DSPI0
*/
#if defined(_DSPI0_VECTOR)

void __attribute__((interrupt(), nomips16)) IntDspi0Handler(void)
{
9d0025e8:	00001012 	mflo	v0
9d0025ec:	afa2005c 	sw	v0,92(sp)
9d0025f0:	00001810 	mfhi	v1
	if (pdspi0 != 0) {
9d0025f4:	10800003 	beqz	a0,9d002604 <IntDspi0Handler+0xa8>
9d0025f8:	afa30058 	sw	v1,88(sp)
		pdspi0->doDspiInterrupt();
9d0025fc:	0f400925 	jal	9d002494 <_ZN4DSPI15doDspiInterruptEv>
9d002600:	00000000 	nop
	}
}
9d002604:	8fa2005c 	lw	v0,92(sp)
9d002608:	8fa30058 	lw	v1,88(sp)
9d00260c:	00400013 	mtlo	v0
9d002610:	8fa20068 	lw	v0,104(sp)
9d002614:	3042000f 	andi	v0,v0,0xf
9d002618:	14400013 	bnez	v0,9d002668 <IntDspi0Handler+0x10c>
9d00261c:	00600011 	mthi	v1
9d002620:	8fbf0054 	lw	ra,84(sp)
9d002624:	8fb90050 	lw	t9,80(sp)
9d002628:	8fb8004c 	lw	t8,76(sp)
9d00262c:	8faf0048 	lw	t7,72(sp)
9d002630:	8fae0044 	lw	t6,68(sp)
9d002634:	8fad0040 	lw	t5,64(sp)
9d002638:	8fac003c 	lw	t4,60(sp)
9d00263c:	8fab0038 	lw	t3,56(sp)
9d002640:	8faa0034 	lw	t2,52(sp)
9d002644:	8fa90030 	lw	t1,48(sp)
9d002648:	8fa8002c 	lw	t0,44(sp)
9d00264c:	8fa70028 	lw	a3,40(sp)
9d002650:	8fa60024 	lw	a2,36(sp)
9d002654:	8fa50020 	lw	a1,32(sp)
9d002658:	8fa4001c 	lw	a0,28(sp)
9d00265c:	8fa30018 	lw	v1,24(sp)
9d002660:	8fa20014 	lw	v0,20(sp)
9d002664:	8fa10010 	lw	at,16(sp)
9d002668:	41606000 	di
9d00266c:	000000c0 	ehb
9d002670:	8fba006c 	lw	k0,108(sp)
9d002674:	8fbb0064 	lw	k1,100(sp)
9d002678:	409a7000 	mtc0	k0,c0_epc
9d00267c:	8fba0068 	lw	k0,104(sp)
9d002680:	27bd0070 	addiu	sp,sp,112
9d002684:	409a6002 	mtc0	k0,c0_srsctl
9d002688:	41dde800 	wrpgpr	sp,sp
9d00268c:	409b6000 	mtc0	k1,c0_status
9d002690:	42000018 	eret

9d002694 <_ZN5DSPI0C1Ev>:
#else
DSPI0::DSPI0() 
#endif
{

	pspi = (p32_spi *) _DSPI0_BASE;
9d002694:	3c02bf80 	lui	v0,0xbf80
9d002698:	24425a00 	addiu	v0,v0,23040
9d00269c:	ac820020 	sw	v0,32(a0)
	vec = _DSPI0_VECTOR;
9d0026a0:	2402001f 	li	v0,31
9d0026a4:	a0820028 	sb	v0,40(a0)
	ipl = ((_DSPI0_IPL & 0x07) << 2) + (_DSPI0_SPL & 0x03);
9d0026a8:	2402000c 	li	v0,12
9d0026ac:	a0820029 	sb	v0,41(a0)
	pinSS = PIN_DSPI0_SS;
9d0026b0:	2402000a 	li	v0,10
9d0026b4:	a082002a 	sb	v0,42(a0)
	** and IEC register. For each IFS register, there is a SET, CLR,
	** and INV register, so the distance (in dwords) from IFS0 to IFS1
	** is 4. This code assumes that all of the enable control and flag
	** bits for an SPI controller are in the same IEC and IFS registers.
	*/
	pregIec = ((p32_regset *)&IEC0) + (irqErr / 32);	// interrupt enable control register
9d0026b8:	3c02bf88 	lui	v0,0xbf88
9d0026bc:	24421070 	addiu	v0,v0,4208
9d0026c0:	ac820004 	sw	v0,4(a0)
	pregIfs = ((p32_regset *)&IFS0) + (irqErr / 32);	// interrupt flag register
9d0026c4:	3c02bf88 	lui	v0,0xbf88
9d0026c8:	24421040 	addiu	v0,v0,4160
9d0026cc:	ac820000 	sw	v0,0(a0)

	bitErr = 1 << (irqErr % 32);	// error interrupt flag/enable bit
9d0026d0:	24020020 	li	v0,32
9d0026d4:	ac820008 	sw	v0,8(a0)
	bitRx  = 1 << (irqRx % 32);		// rx interrupt flag/enable bit
9d0026d8:	24020040 	li	v0,64
9d0026dc:	ac82000c 	sw	v0,12(a0)
	bitTx  = 1 << (irqTx % 32);		// tx interrupt flag/enable bit
9d0026e0:	24020080 	li	v0,128
9d0026e4:	ac820010 	sw	v0,16(a0)

    isr = isrHandler;
9d0026e8:	3c029d00 	lui	v0,0x9d00
9d0026ec:	2442255c 	addiu	v0,v0,9564
DSPI::DSPI()
#endif
 {

	pspi = 0;
	cbCur = 0;
9d0026f0:	a480001c 	sh	zero,28(a0)
	vec = _DSPI0_VECTOR;
	ipl = ((_DSPI0_IPL & 0x07) << 2) + (_DSPI0_SPL & 0x03);
	pinSS = PIN_DSPI0_SS;

	init(_DSPI0_ERR_IRQ, _DSPI0_RX_IRQ, _DSPI0_TX_IRQ, IntDspi0Handler);
}
9d0026f4:	03e00008 	jr	ra
9d0026f8:	ac820024 	sw	v0,36(a0)

9d0026fc <millisecondCoreTimerService>:
*/
uint32_t millisecondCoreTimerService(uint32_t curTime)
{
    static nextInt = 0;
    uint32_t relWait = 0;
    uint32_t relTime = curTime - nextInt;
9d0026fc:	8f858028 	lw	a1,-32728(gp)
    uint32_t millisLocal = gTimer0_millis;  // defeat volatility
9d002700:	8f83801c 	lw	v1,-32740(gp)
**
*/
uint32_t millisecondCoreTimerService(uint32_t curTime)
{
    static nextInt = 0;
    uint32_t relWait = 0;
9d002704:	00001021 	move	v0,zero
    uint32_t relTime = curTime - nextInt;
9d002708:	00852023 	subu	a0,a0,a1

    // catch-up up to current time; we may have fallen behind due to interrupts being diabled.
    while(relWait <= relTime)
    {
        millisLocal++;                      // add a ms to our time
        relWait += CORE_TICK_RATE;          // add a ms to our next ISR time
9d00270c:	34079c40 	li	a3,0x9c40
9d002710:	00471021 	addu	v0,v0,a3
    uint32_t relWait = 0;
    uint32_t relTime = curTime - nextInt;
    uint32_t millisLocal = gTimer0_millis;  // defeat volatility

    // catch-up up to current time; we may have fallen behind due to interrupts being diabled.
    while(relWait <= relTime)
9d002714:	0082302b 	sltu	a2,a0,v0
9d002718:	10c0fffd 	beqz	a2,9d002710 <millisecondCoreTimerService+0x14>
9d00271c:	24630001 	addiu	v1,v1,1
        millisLocal++;                      // add a ms to our time
        relWait += CORE_TICK_RATE;          // add a ms to our next ISR time
     }

    // set when we want to be called again
    nextInt += relWait;                     // calculate the absolute interrupt time we want.
9d002720:	00451021 	addu	v0,v0,a1

    // we want to sync gCore_timer_last_val with the last millisecond "count" value
    // curTime may not be exactly on a millisecond boundary, but we know where that is
    // we know nextInt is our next millisecond boundary, so less 1 CORE_TICK_RATE will be our last one
    // gCore_timer_last_val = curTime;         // This is the original bogus code
    gCore_timer_last_val =  nextInt - CORE_TICK_RATE;
9d002724:	34049c40 	li	a0,0x9c40
9d002728:	00442023 	subu	a0,v0,a0
9d00272c:	af848020 	sw	a0,-32736(gp)
        millisLocal++;                      // add a ms to our time
        relWait += CORE_TICK_RATE;          // add a ms to our next ISR time
     }

    // set when we want to be called again
    nextInt += relWait;                     // calculate the absolute interrupt time we want.
9d002730:	af828028 	sw	v0,-32728(gp)
    // we know nextInt is our next millisecond boundary, so less 1 CORE_TICK_RATE will be our last one
    // gCore_timer_last_val = curTime;         // This is the original bogus code
    gCore_timer_last_val =  nextInt - CORE_TICK_RATE;

    // update the global millisecond counter.
    gTimer0_millis = millisLocal;           // Total number of ms
9d002734:	af83801c 	sw	v1,-32740(gp)

    return(nextInt);
}
9d002738:	03e00008 	jr	ra
9d00273c:	00000000 	nop

9d002740 <CoreTimerHandler>:
**      each service's logical compare values. And then the next and soonest logical compare value is searched for and set as
**      the real compare value to be interrupted to notify the Serivces when count hits that value.
**
*/
void __attribute__((interrupt(),nomips16)) CoreTimerHandler(void)
{
9d002740:	415de800 	rdpgpr	sp,sp
9d002744:	401b7000 	mfc0	k1,c0_epc
9d002748:	401a6002 	mfc0	k0,c0_srsctl
9d00274c:	27bdff58 	addiu	sp,sp,-168
9d002750:	afbb00a4 	sw	k1,164(sp)
9d002754:	401b6000 	mfc0	k1,c0_status
9d002758:	afba00a0 	sw	k0,160(sp)
9d00275c:	401a6800 	mfc0	k0,c0_cause
9d002760:	001ad282 	srl	k0,k0,0xa
9d002764:	afbb009c 	sw	k1,156(sp)
9d002768:	7f5b7a84 	ins	k1,k0,0xa,0x6
9d00276c:	7c1b2044 	ins	k1,zero,0x1,0x4
9d002770:	409b6000 	mtc0	k1,c0_status
9d002774:	afa3002c 	sw	v1,44(sp)
9d002778:	8fa300a0 	lw	v1,160(sp)
9d00277c:	3063000f 	andi	v1,v1,0xf
9d002780:	1460001a 	bnez	v1,9d0027ec <CoreTimerHandler+0xac>
9d002784:	afa20028 	sw	v0,40(sp)
9d002788:	afbf008c 	sw	ra,140(sp)
9d00278c:	afbe0088 	sw	s8,136(sp)
9d002790:	afb90084 	sw	t9,132(sp)
9d002794:	afb80080 	sw	t8,128(sp)
9d002798:	afb7007c 	sw	s7,124(sp)
9d00279c:	afb60078 	sw	s6,120(sp)
9d0027a0:	afb50074 	sw	s5,116(sp)
9d0027a4:	afb40070 	sw	s4,112(sp)
9d0027a8:	afb3006c 	sw	s3,108(sp)
9d0027ac:	afb20068 	sw	s2,104(sp)
9d0027b0:	afb10064 	sw	s1,100(sp)
9d0027b4:	afb00060 	sw	s0,96(sp)
9d0027b8:	afaf005c 	sw	t7,92(sp)
9d0027bc:	afae0058 	sw	t6,88(sp)
9d0027c0:	afad0054 	sw	t5,84(sp)
9d0027c4:	afac0050 	sw	t4,80(sp)
9d0027c8:	afab004c 	sw	t3,76(sp)
9d0027cc:	afaa0048 	sw	t2,72(sp)
9d0027d0:	afa90044 	sw	t1,68(sp)
9d0027d4:	afa80040 	sw	t0,64(sp)
9d0027d8:	afa7003c 	sw	a3,60(sp)
9d0027dc:	afa60038 	sw	a2,56(sp)
9d0027e0:	afa50034 	sw	a1,52(sp)
9d0027e4:	afa40030 	sw	a0,48(sp)
9d0027e8:	afa10024 	sw	at,36(sp)
9d0027ec:	00001012 	mflo	v0
9d0027f0:	afa20094 	sw	v0,148(sp)
9d0027f4:	00001810 	mfhi	v1
9d0027f8:	afa30090 	sw	v1,144(sp)

    // we know that count >= compare, otherwise we would not have been interrupted
    // we also know that count and compare >= gLastBaseCount as this was our last count value.

    // get our current time; this will establish our next base
    read_count(curTime); 
9d0027fc:	40134800 	mfc0	s3,c0_count
    relCurTime = curTime - gLastBaseCount;
9d002800:	8f9e8024 	lw	s8,-32732(gp)
9d002804:	3c10a000 	lui	s0,0xa000
        {
            // if the serivce exists
            if(gCoreTimerInfo[i].serivce != NULL)
            {
                // if their time has come up
                relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
9d002808:	3c05a000 	lui	a1,0xa000
    // we know that count >= compare, otherwise we would not have been interrupted
    // we also know that count and compare >= gLastBaseCount as this was our last count value.

    // get our current time; this will establish our next base
    read_count(curTime); 
    relCurTime = curTime - gLastBaseCount;
9d00280c:	027ef023 	subu	s8,s3,s8

    // we know that count >= compare, otherwise we would not have been interrupted
    // we also know that count and compare >= gLastBaseCount as this was our last count value.

    // get our current time; this will establish our next base
    read_count(curTime); 
9d002810:	02603021 	move	a2,s3
9d002814:	2610000c 	addiu	s0,s0,12
9d002818:	3c12bf88 	lui	s2,0xbf88
        {
            // if the serivce exists
            if(gCoreTimerInfo[i].serivce != NULL)
            {
                // if their time has come up
                relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
9d00281c:	24a50008 	addiu	a1,a1,8
    {
        // make sure we find the lowest int to set
        relNextInt = 0xFFFFFFFF;

        // check to see who all we need to call
        for(i=0; i<MaxNbrOfCoreTimerServices; i++)
9d002820:	24030003 	li	v1,3
        // we need to apply our base to convert from relative values to an absolute time.
        compare = relNextInt + gLastBaseCount;
        write_comp(compare); 

        // clear the CT flag
        mCTClearIntFlag();
9d002824:	24110001 	li	s1,1
    // we know that count >= compare, otherwise we would not have been interrupted
    // we also know that count and compare >= gLastBaseCount as this was our last count value.

    // get our current time; this will establish our next base
    read_count(curTime); 
    relCurTime = curTime - gLastBaseCount;
9d002828:	0200b021 	move	s6,s0
    {
        // make sure we find the lowest int to set
        relNextInt = 0xFFFFFFFF;

        // check to see who all we need to call
        for(i=0; i<MaxNbrOfCoreTimerServices; i++)
9d00282c:	0000a021 	move	s4,zero
    nextBase = curTime;

    do
    {
        // make sure we find the lowest int to set
        relNextInt = 0xFFFFFFFF;
9d002830:	2415ffff 	li	s5,-1

        // check to see who all we need to call
        for(i=0; i<MaxNbrOfCoreTimerServices; i++)
        {
            // if the serivce exists
            if(gCoreTimerInfo[i].serivce != NULL)
9d002834:	8ec20000 	lw	v0,0(s6)
            {
                // if their time has come up
                relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
9d002838:	0014b8c0 	sll	s7,s4,0x3
9d00283c:	02e5b821 	addu	s7,s7,a1
    {
        // make sure we find the lowest int to set
        relNextInt = 0xFFFFFFFF;

        // check to see who all we need to call
        for(i=0; i<MaxNbrOfCoreTimerServices; i++)
9d002840:	26940001 	addiu	s4,s4,1
        {
            // if the serivce exists
            if(gCoreTimerInfo[i].serivce != NULL)
9d002844:	10400009 	beqz	v0,9d00286c <CoreTimerHandler+0x12c>
9d002848:	26d60008 	addiu	s6,s6,8
            {
                // if their time has come up
                relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
9d00284c:	8ee70000 	lw	a3,0(s7)
9d002850:	8f848024 	lw	a0,-32732(gp)
9d002854:	00e42023 	subu	a0,a3,a0
                if(relInt <= relCurTime)
9d002858:	03c4382b 	sltu	a3,s8,a0
9d00285c:	50e0003d 	beqzl	a3,9d002954 <CoreTimerHandler+0x214>
9d002860:	00c02021 	move	a0,a2
                    relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
                }

                // see if this is the next interrupt we want to set
                // we are looking for the closest/lowest int to set.
                if(relInt < relNextInt)
9d002864:	0095102b 	sltu	v0,a0,s5
9d002868:	0082a80b 	movn	s5,a0,v0
    {
        // make sure we find the lowest int to set
        relNextInt = 0xFFFFFFFF;

        // check to see who all we need to call
        for(i=0; i<MaxNbrOfCoreTimerServices; i++)
9d00286c:	5683fff2 	bnel	s4,v1,9d002838 <CoreTimerHandler+0xf8>
9d002870:	8ec20000 	lw	v0,0(s6)
        // other service may cause the compare value to be set for an earlier time; but we always know there will be a compare time
        // to set, so we know that relNextInt has a value other than 0xFFFFFFFF in it.

        // Go ahead and set the compare register to the next interrupt we want.
        // we need to apply our base to convert from relative values to an absolute time.
        compare = relNextInt + gLastBaseCount;
9d002874:	8f828024 	lw	v0,-32732(gp)
9d002878:	02a21021 	addu	v0,s5,v0
        write_comp(compare); 
9d00287c:	40825800 	mtc0	v0,c0_compare

        // clear the CT flag
        mCTClearIntFlag();
9d002880:	ae511034 	sw	s1,4148(s2)

        // read the count after the CT flag has been set so we can make sure count has not passed compare
        // during our processing of this int
        read_count(curTime); 
9d002884:	40064800 	mfc0	a2,c0_count

        // get the relative time so we can operate in the linear portion of our uint32.
        relCurTime = curTime - gLastBaseCount;
9d002888:	8f9e8024 	lw	s8,-32732(gp)
9d00288c:	00def023 	subu	s8,a2,s8

        // if the current time has passed our interrupt time, then we basically hit the interrupt again
        // so we probabaly missed the CT flag being set and we need to reprocess this interrupt and find the next one to set.
    } while(relNextInt <= relCurTime);
9d002890:	03d5a82b 	sltu	s5,s8,s5
9d002894:	52a0ffe5 	beqzl	s5,9d00282c <CoreTimerHandler+0xec>
9d002898:	0200b021 	move	s6,s0
    // otherwise the next interrupt time (compare time) is after the current time and CT will catch it when count == compare.
    // we can safely exit the ISR.

    // but first we must set our new base so the next time we come into this routine we
    // have a valid lower base to shift our times to for comparisons.
    gLastBaseCount = nextBase;
9d00289c:	af938024 	sw	s3,-32732(gp)
}
9d0028a0:	8fa20094 	lw	v0,148(sp)
9d0028a4:	8fa30090 	lw	v1,144(sp)
9d0028a8:	00400013 	mtlo	v0
9d0028ac:	8fa200a0 	lw	v0,160(sp)
9d0028b0:	3042000f 	andi	v0,v0,0xf
9d0028b4:	1440001c 	bnez	v0,9d002928 <CoreTimerHandler+0x1e8>
9d0028b8:	00600011 	mthi	v1
9d0028bc:	8fbf008c 	lw	ra,140(sp)
9d0028c0:	8fbe0088 	lw	s8,136(sp)
9d0028c4:	8fb90084 	lw	t9,132(sp)
9d0028c8:	8fb80080 	lw	t8,128(sp)
9d0028cc:	8fb7007c 	lw	s7,124(sp)
9d0028d0:	8fb60078 	lw	s6,120(sp)
9d0028d4:	8fb50074 	lw	s5,116(sp)
9d0028d8:	8fb40070 	lw	s4,112(sp)
9d0028dc:	8fb3006c 	lw	s3,108(sp)
9d0028e0:	8fb20068 	lw	s2,104(sp)
9d0028e4:	8fb10064 	lw	s1,100(sp)
9d0028e8:	8fb00060 	lw	s0,96(sp)
9d0028ec:	8faf005c 	lw	t7,92(sp)
9d0028f0:	8fae0058 	lw	t6,88(sp)
9d0028f4:	8fad0054 	lw	t5,84(sp)
9d0028f8:	8fac0050 	lw	t4,80(sp)
9d0028fc:	8fab004c 	lw	t3,76(sp)
9d002900:	8faa0048 	lw	t2,72(sp)
9d002904:	8fa90044 	lw	t1,68(sp)
9d002908:	8fa80040 	lw	t0,64(sp)
9d00290c:	8fa7003c 	lw	a3,60(sp)
9d002910:	8fa60038 	lw	a2,56(sp)
9d002914:	8fa50034 	lw	a1,52(sp)
9d002918:	8fa40030 	lw	a0,48(sp)
9d00291c:	8fa3002c 	lw	v1,44(sp)
9d002920:	8fa20028 	lw	v0,40(sp)
9d002924:	8fa10024 	lw	at,36(sp)
9d002928:	41606000 	di
9d00292c:	000000c0 	ehb
9d002930:	8fba00a4 	lw	k0,164(sp)
9d002934:	8fbb009c 	lw	k1,156(sp)
9d002938:	409a7000 	mtc0	k0,c0_epc
9d00293c:	8fba00a0 	lw	k0,160(sp)
9d002940:	27bd00a8 	addiu	sp,sp,168
9d002944:	409a6002 	mtc0	k0,c0_srsctl
9d002948:	41dde800 	wrpgpr	sp,sp
9d00294c:	409b6000 	mtc0	k1,c0_status
9d002950:	42000018 	eret
                // if their time has come up
                relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
                if(relInt <= relCurTime)
                {
                    // call their routine to get their next interrupt time
                    gCoreTimerInfo[i].nextInt = gCoreTimerInfo[i].serivce(curTime);
9d002954:	afa30018 	sw	v1,24(sp)
9d002958:	afa50014 	sw	a1,20(sp)
9d00295c:	0040f809 	jalr	v0
9d002960:	afa60010 	sw	a2,16(sp)
9d002964:	aee20000 	sw	v0,0(s7)

                    // recalculate the relative time of thier next int
                    // so we can see if this is the next int we need to set
                    relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
9d002968:	8ee40000 	lw	a0,0(s7)
9d00296c:	8f828024 	lw	v0,-32732(gp)
9d002970:	8fa60010 	lw	a2,16(sp)
9d002974:	8fa50014 	lw	a1,20(sp)
9d002978:	00822023 	subu	a0,a0,v0
                }

                // see if this is the next interrupt we want to set
                // we are looking for the closest/lowest int to set.
                if(relInt < relNextInt)
9d00297c:	0095102b 	sltu	v0,a0,s5
                    // call their routine to get their next interrupt time
                    gCoreTimerInfo[i].nextInt = gCoreTimerInfo[i].serivce(curTime);

                    // recalculate the relative time of thier next int
                    // so we can see if this is the next int we need to set
                    relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
9d002980:	8fa30018 	lw	v1,24(sp)
                }

                // see if this is the next interrupt we want to set
                // we are looking for the closest/lowest int to set.
                if(relInt < relNextInt)
9d002984:	0b400a1b 	j	9d00286c <CoreTimerHandler+0x12c>
9d002988:	0082a80b 	movn	s5,a0,v0

9d00298c <millis>:
uint8_t ppsGlobalLock = false;

//************************************************************************
unsigned long millis()
{
	return(gTimer0_millis);
9d00298c:	8f82801c 	lw	v0,-32740(gp)
}
9d002990:	03e00008 	jr	ra
9d002994:	00000000 	nop

9d002998 <delay>:
}

//************************************************************************
// Delay for a given number of milliseconds.
void delay(unsigned long ms)
{
9d002998:	27bdffe0 	addiu	sp,sp,-32
9d00299c:	afb10018 	sw	s1,24(sp)
unsigned long	startMillis;

	startMillis	=	gTimer0_millis;
9d0029a0:	8f91801c 	lw	s1,-32740(gp)
	while ((gTimer0_millis - startMillis) < ms)
9d0029a4:	8f82801c 	lw	v0,-32740(gp)
}

//************************************************************************
// Delay for a given number of milliseconds.
void delay(unsigned long ms)
{
9d0029a8:	afb00014 	sw	s0,20(sp)
9d0029ac:	afbf001c 	sw	ra,28(sp)
unsigned long	startMillis;

	startMillis	=	gTimer0_millis;
	while ((gTimer0_millis - startMillis) < ms)
9d0029b0:	00511023 	subu	v0,v0,s1
9d0029b4:	0044102b 	sltu	v0,v0,a0
9d0029b8:	10400008 	beqz	v0,9d0029dc <delay+0x44>
9d0029bc:	00808021 	move	s0,a0
	{
		_scheduleTask();
9d0029c0:	0f400b72 	jal	9d002dc8 <_scheduleTask>
9d0029c4:	00000000 	nop
void delay(unsigned long ms)
{
unsigned long	startMillis;

	startMillis	=	gTimer0_millis;
	while ((gTimer0_millis - startMillis) < ms)
9d0029c8:	8f82801c 	lw	v0,-32740(gp)
9d0029cc:	00511023 	subu	v0,v0,s1
9d0029d0:	0050102b 	sltu	v0,v0,s0
9d0029d4:	1440fffa 	bnez	v0,9d0029c0 <delay+0x28>
9d0029d8:	00000000 	nop
	{
		_scheduleTask();
	}
}
9d0029dc:	8fbf001c 	lw	ra,28(sp)
9d0029e0:	8fb10018 	lw	s1,24(sp)
9d0029e4:	8fb00014 	lw	s0,20(sp)
9d0029e8:	03e00008 	jr	ra
9d0029ec:	27bd0020 	addiu	sp,sp,32

9d0029f0 <init>:
	__PIC32_pbClk	=	SYSTEMConfigPerformance(F_CPU);
#endif
#endif

	// Configure the processor for the proper number of wait states and caching.
	_configSystem(F_CPU);
9d0029f0:	3c0404c4 	lui	a0,0x4c4
}


//************************************************************************
void init()
{
9d0029f4:	27bdffe8 	addiu	sp,sp,-24
9d0029f8:	afbf0014 	sw	ra,20(sp)
	__PIC32_pbClk	=	SYSTEMConfigPerformance(F_CPU);
#endif
#endif

	// Configure the processor for the proper number of wait states and caching.
	_configSystem(F_CPU);
9d0029fc:	0f400c2c 	jal	9d0030b0 <_configSystem>
9d002a00:	3484b400 	ori	a0,a0,0xb400

	// Enable multi-vector interrupts
	_enableMultiVectorInterrupts();
9d002a04:	0f400c4d 	jal	9d003134 <_enableMultiVectorInterrupts>
9d002a08:	00000000 	nop

	// Initialize the core timer for use to maintain the system timer tick.
	_initCoreTimer(CORE_TICK_RATE);
9d002a0c:	0f400c56 	jal	9d003158 <_initCoreTimer>
9d002a10:	34049c40 	li	a0,0x9c40

    initIntVector();
9d002a14:	0f400be0 	jal	9d002f80 <initIntVector>
9d002a18:	00000000 	nop

	setIntPriority(_CORE_TIMER_VECTOR, _CT_IPL_IPC, _CT_SPL_IPC);
9d002a1c:	00003021 	move	a2,zero
9d002a20:	00002021 	move	a0,zero
9d002a24:	0f400c0e 	jal	9d003038 <setIntPriority>
9d002a28:	24050007 	li	a1,7
	setIntVector(_CORE_TIMER_VECTOR, CoreTimerHandler);
9d002a2c:	3c059d00 	lui	a1,0x9d00
9d002a30:	24a52740 	addiu	a1,a1,10048
9d002a34:	0f400bf5 	jal	9d002fd4 <setIntVector>
9d002a38:	00002021 	move	a0,zero
	setIntEnable(_CORE_TIMER_IRQ);
9d002a3c:	0f400c00 	jal	9d003000 <setIntEnable>
9d002a40:	00002021 	move	a0,zero

	// Save the peripheral bus frequency for later use.
	__PIC32_pbClk = getPeripheralClock();
9d002a44:	0f400c25 	jal	9d003094 <getPeripheralClock>
9d002a48:	00000000 	nop

   // allow for debugging, this will stop the core timer when the debugger takes control
    _CP0_BIC_DEBUG(_CP0_DEBUG_COUNTDM_MASK); 
9d002a4c:	3c030200 	lui	v1,0x200
	setIntPriority(_CORE_TIMER_VECTOR, _CT_IPL_IPC, _CT_SPL_IPC);
	setIntVector(_CORE_TIMER_VECTOR, CoreTimerHandler);
	setIntEnable(_CORE_TIMER_IRQ);

	// Save the peripheral bus frequency for later use.
	__PIC32_pbClk = getPeripheralClock();
9d002a50:	af82803c 	sw	v0,-32708(gp)

   // allow for debugging, this will stop the core timer when the debugger takes control
    _CP0_BIC_DEBUG(_CP0_DEBUG_COUNTDM_MASK); 
9d002a54:	4002b800 	mfc0	v0,c0_debug
9d002a58:	00031827 	nor	v1,zero,v1
9d002a5c:	00431824 	and	v1,v0,v1
9d002a60:	4083b800 	mtc0	v1,c0_debug
9d002a64:	000000c0 	ehb
	RtccSetTimeDate(0x10073000, 0x10101701);
	// please note that the rsvd field has to be 0 in the time field!
#endif
#endif

	delay(50);
9d002a68:	0f400a66 	jal	9d002998 <delay>
9d002a6c:	24040032 	li	a0,50
#if defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)
	CFGCONbits.JTAGEN = 0;
	//CFGCONbits.TDOEN = 0;
	//OSCCONbits.SOSCEN = 0;
#else
	DDPCONbits.JTAGEN	=	0;
9d002a70:	3c02bf81 	lui	v0,0xbf81
9d002a74:	8c43f200 	lw	v1,-3584(v0)
9d002a78:	7c0318c4 	ins	v1,zero,0x3,0x1
9d002a7c:	ac43f200 	sw	v1,-3584(v0)
void	_board_init(void);
	_board_init();
#endif

	//* Initialize the periodic task manager
	_initTaskManager();
9d002a80:	0f400b65 	jal	9d002d94 <_initTaskManager>
9d002a84:	00000000 	nop
#if defined(_SER0_BASE)
	p32_uart *	uart;
	uart = (p32_uart *)_SER0_BASE;
	uart->uxMode.clr = (1 << _UARTMODE_ON);
#endif
}
9d002a88:	8fbf0014 	lw	ra,20(sp)
	//*	Issue #84
	//*	disable the uart so that the pins can be used as general purpose I/O
#if defined(_SER0_BASE)
	p32_uart *	uart;
	uart = (p32_uart *)_SER0_BASE;
	uart->uxMode.clr = (1 << _UARTMODE_ON);
9d002a8c:	34038000 	li	v1,0x8000
9d002a90:	3c02bf80 	lui	v0,0xbf80
9d002a94:	ac436004 	sw	v1,24580(v0)
#endif
}
9d002a98:	03e00008 	jr	ra
9d002a9c:	27bd0018 	addiu	sp,sp,24

9d002aa0 <pinMode>:
#include "wiring_private.h"
#include "pins_arduino.h"

//************************************************************************
void pinMode(uint8_t pin, uint8_t mode)
{
9d002aa0:	308400ff 	andi	a0,a0,0xff
9d002aa4:	27bdffe0 	addiu	sp,sp,-32
uint8_t		            timer;
uint32_t                cn;

	/* Check if pin number is in valid range.
	*/
	if (pin >= NUM_DIGITAL_PINS_EXTENDED)
9d002aa8:	2c82002f 	sltiu	v0,a0,47
#include "wiring_private.h"
#include "pins_arduino.h"

//************************************************************************
void pinMode(uint8_t pin, uint8_t mode)
{
9d002aac:	afbf001c 	sw	ra,28(sp)
9d002ab0:	afb10018 	sw	s1,24(sp)
9d002ab4:	afb00014 	sw	s0,20(sp)
uint8_t		            timer;
uint32_t                cn;

	/* Check if pin number is in valid range.
	*/
	if (pin >= NUM_DIGITAL_PINS_EXTENDED)
9d002ab8:	1040002d 	beqz	v0,9d002b70 <pinMode+0xd0>
9d002abc:	30a500ff 	andi	a1,a1,0xff
		return;
	}
#endif	// OPT_BOARD_DIGITAL_IO

	//* Get the port number for this pin.
	if ((port = digitalPinToPort(pin)) == NOT_A_PIN)
9d002ac0:	3c029d00 	lui	v0,0x9d00
9d002ac4:	2442666c 	addiu	v0,v0,26220
9d002ac8:	00441021 	addu	v0,v0,a0
9d002acc:	90420000 	lbu	v0,0(v0)
9d002ad0:	10400027 	beqz	v0,9d002b70 <pinMode+0xd0>
9d002ad4:	00023080 	sll	a2,v0,0x2
	{
		return;
	}

	//* Obtain pointer to the registers for this io port.
	iop = portRegisters(port);
9d002ad8:	3c079d00 	lui	a3,0x9d00
9d002adc:	24e76648 	addiu	a3,a3,26184
9d002ae0:	00c73821 	addu	a3,a2,a3

	//* Obtain bit mask for the specific bit for this pin.
	bit = digitalPinToBitMask(pin);
9d002ae4:	3c069d00 	lui	a2,0x9d00
9d002ae8:	00041840 	sll	v1,a0,0x1
9d002aec:	24c6669c 	addiu	a2,a2,26268
9d002af0:	00c33021 	addu	a2,a2,v1
9d002af4:	94d00000 	lhu	s0,0(a2)
	// analog input capable pins.
	// Clear the bit in the ANSELx register to ensure that the pin is in
	// digital input mode.
	iop->ansel.clr = bit;
#else
	if (port == _IOPORT_PB)
9d002af8:	24060002 	li	a2,2
9d002afc:	1046003a 	beq	v0,a2,9d002be8 <pinMode+0x148>
9d002b00:	8cf10000 	lw	s1,0(a3)

	}
#endif	// defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)

	// Set the pin to the requested mode.
    switch (mode) {
9d002b04:	24020002 	li	v0,2
9d002b08:	10a20030 	beq	a1,v0,9d002bcc <pinMode+0x12c>
9d002b0c:	2ca20003 	sltiu	v0,a1,3
9d002b10:	1040001c 	beqz	v0,9d002b84 <pinMode+0xe4>
9d002b14:	2ca20006 	sltiu	v0,a1,6
9d002b18:	14a0001d 	bnez	a1,9d002b90 <pinMode+0xf0>
9d002b1c:	3c029d00 	lui	v0,0x9d00
            } else {
                iop->cnpu.clr = bit;
                iop->cnpd.clr = bit;
            }
#else
            if (mode == INPUT_PULLUP) {
9d002b20:	24020003 	li	v0,3
9d002b24:	10a2003a 	beq	a1,v0,9d002c10 <pinMode+0x170>
9d002b28:	3c029d00 	lui	v0,0x9d00
                cn = digitalPinToCN(pin);
                if (cn != NOT_CN_PIN) {
                    CNPUESET = cn;
                } 
            } else {
                cn = digitalPinToCN(pin);
9d002b2c:	2442675c 	addiu	v0,v0,26460
9d002b30:	00042080 	sll	a0,a0,0x2
9d002b34:	00822021 	addu	a0,a0,v0
9d002b38:	8c820000 	lw	v0,0(a0)
                if (cn != NOT_CN_PIN) {
9d002b3c:	240400ff 	li	a0,255
9d002b40:	10440002 	beq	v0,a0,9d002b4c <pinMode+0xac>
9d002b44:	3c04bf88 	lui	a0,0xbf88
                    CNPUECLR = cn;
9d002b48:	ac8261e4 	sw	v0,25060(a0)
            }
#endif
            // continue into INPUT case
            //* Determine if this is an output compare pin. If so,
            //* we need to make sure PWM output is off.
            timer = digitalPinToTimerOC(pin) >> _BN_TIMER_OC;
9d002b4c:	3c029d00 	lui	v0,0x9d00
9d002b50:	244266fc 	addiu	v0,v0,26364
9d002b54:	00431821 	addu	v1,v0,v1
9d002b58:	90640000 	lbu	a0,0(v1)
9d002b5c:	3084000f 	andi	a0,a0,0xf
            if (timer != NOT_ON_TIMER)
9d002b60:	14800025 	bnez	a0,9d002bf8 <pinMode+0x158>
9d002b64:	00000000 	nop
            }

            //*	May  1,	2011
            //*	according to item #26 in PIC32MX5XX-6XX-7XX Errata.pdf 
            //*	if we are setting to input, set the data bit to zero first
            iop->lat.clr  = bit;	//clear to output bit		
9d002b68:	ae300024 	sw	s0,36(s1)
            iop->tris.set = bit;	//make the pin an input
9d002b6c:	ae300008 	sw	s0,8(s1)
            } 
#endif
            iop->tris.clr = bit;	//make the pin an output
            iop->odc.clr  = bit;	//make sure it isn't open drain
	}
}
9d002b70:	8fbf001c 	lw	ra,28(sp)
9d002b74:	8fb10018 	lw	s1,24(sp)
9d002b78:	8fb00014 	lw	s0,20(sp)
9d002b7c:	03e00008 	jr	ra
9d002b80:	27bd0020 	addiu	sp,sp,32

	}
#endif	// defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)

	// Set the pin to the requested mode.
    switch (mode) {
9d002b84:	1440ffe7 	bnez	v0,9d002b24 <pinMode+0x84>
9d002b88:	24020003 	li	v0,3
            // than error checking the input value.
#if defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)
            iop->cnpu.clr = bit;
            iop->cnpd.clr = bit;
#else
            cn = digitalPinToCN(pin);
9d002b8c:	3c029d00 	lui	v0,0x9d00
9d002b90:	2442675c 	addiu	v0,v0,26460
9d002b94:	00042080 	sll	a0,a0,0x2
9d002b98:	00822021 	addu	a0,a0,v0
9d002b9c:	8c820000 	lw	v0,0(a0)
            if (cn != NOT_CN_PIN) {
9d002ba0:	240300ff 	li	v1,255
9d002ba4:	10430002 	beq	v0,v1,9d002bb0 <pinMode+0x110>
9d002ba8:	3c03bf88 	lui	v1,0xbf88
                CNPUECLR = cn;
9d002bac:	ac6261e4 	sw	v0,25060(v1)
            } 
#endif
            iop->tris.clr = bit;	//make the pin an output
            iop->odc.clr  = bit;	//make sure it isn't open drain
	}
}
9d002bb0:	8fbf001c 	lw	ra,28(sp)
            cn = digitalPinToCN(pin);
            if (cn != NOT_CN_PIN) {
                CNPUECLR = cn;
            } 
#endif
            iop->tris.clr = bit;	//make the pin an output
9d002bb4:	ae300004 	sw	s0,4(s1)
            iop->odc.clr  = bit;	//make sure it isn't open drain
9d002bb8:	ae300034 	sw	s0,52(s1)
	}
}
9d002bbc:	8fb10018 	lw	s1,24(sp)
9d002bc0:	8fb00014 	lw	s0,20(sp)
9d002bc4:	03e00008 	jr	ra
9d002bc8:	27bd0020 	addiu	sp,sp,32
9d002bcc:	8fbf001c 	lw	ra,28(sp)
            //*	if we are setting to input, set the data bit to zero first
            iop->lat.clr  = bit;	//clear to output bit		
            iop->tris.set = bit;	//make the pin an input
            break;
        case OPEN:
            iop->tris.clr = bit;	//OPEN implies output, make the pin an output
9d002bd0:	ae300004 	sw	s0,4(s1)
            iop->odc.set  = bit;	//make the pin open drain
9d002bd4:	ae300038 	sw	s0,56(s1)
            } 
#endif
            iop->tris.clr = bit;	//make the pin an output
            iop->odc.clr  = bit;	//make sure it isn't open drain
	}
}
9d002bd8:	8fb10018 	lw	s1,24(sp)
9d002bdc:	8fb00014 	lw	s0,20(sp)
9d002be0:	03e00008 	jr	ra
9d002be4:	27bd0020 	addiu	sp,sp,32
		//	You have to set the bit in the AD1PCFG for an analog pin to be used as a 
		//	digital input. They come up after reset as analog input with the digital 
		//	input disabled. For the PORTB pins you switch between analog input and 
		//	digital input using AD1PCFG.

		AD1PCFGSET = bit;
9d002be8:	3c02bf81 	lui	v0,0xbf81
9d002bec:	ac509068 	sw	s0,-28568(v0)

	}
#endif	// defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)

	// Set the pin to the requested mode.
    switch (mode) {
9d002bf0:	0b400ac2 	j	9d002b08 <pinMode+0x68>
9d002bf4:	24020002 	li	v0,2
            //* Determine if this is an output compare pin. If so,
            //* we need to make sure PWM output is off.
            timer = digitalPinToTimerOC(pin) >> _BN_TIMER_OC;
            if (timer != NOT_ON_TIMER)
            {
                turnOffPWM(timer);
9d002bf8:	0f400b52 	jal	9d002d48 <turnOffPWM>
9d002bfc:	00000000 	nop
            }

            //*	May  1,	2011
            //*	according to item #26 in PIC32MX5XX-6XX-7XX Errata.pdf 
            //*	if we are setting to input, set the data bit to zero first
            iop->lat.clr  = bit;	//clear to output bit		
9d002c00:	ae300024 	sw	s0,36(s1)
            iop->tris.set = bit;	//make the pin an input
9d002c04:	ae300008 	sw	s0,8(s1)
            } 
#endif
            iop->tris.clr = bit;	//make the pin an output
            iop->odc.clr  = bit;	//make sure it isn't open drain
	}
}
9d002c08:	0b400add 	j	9d002b74 <pinMode+0xd4>
9d002c0c:	8fbf001c 	lw	ra,28(sp)
                iop->cnpu.clr = bit;
                iop->cnpd.clr = bit;
            }
#else
            if (mode == INPUT_PULLUP) {
                cn = digitalPinToCN(pin);
9d002c10:	2442675c 	addiu	v0,v0,26460
9d002c14:	00042080 	sll	a0,a0,0x2
9d002c18:	00822021 	addu	a0,a0,v0
9d002c1c:	8c820000 	lw	v0,0(a0)
                if (cn != NOT_CN_PIN) {
9d002c20:	240400ff 	li	a0,255
9d002c24:	1044ffc9 	beq	v0,a0,9d002b4c <pinMode+0xac>
9d002c28:	3c04bf88 	lui	a0,0xbf88
                    CNPUESET = cn;
9d002c2c:	ac8261e8 	sw	v0,25064(a0)
            }
#endif
            // continue into INPUT case
            //* Determine if this is an output compare pin. If so,
            //* we need to make sure PWM output is off.
            timer = digitalPinToTimerOC(pin) >> _BN_TIMER_OC;
9d002c30:	0b400ad4 	j	9d002b50 <pinMode+0xb0>
9d002c34:	3c029d00 	lui	v0,0x9d00

9d002c38 <digitalWrite>:
//*	Reading from PORT gives you a snapshot of the actual pins state regardless of how, 
//*	if at all, the PIC is trying to drive them.  
//*	Reading from LAT gives you the values last written to the pins, whether thru LAT or PORT.
//************************************************************************
void digitalWrite(uint8_t pin, uint8_t val)
{
9d002c38:	308400ff 	andi	a0,a0,0xff
9d002c3c:	27bdffd8 	addiu	sp,sp,-40
uint8_t					timer;
uint32_t                cn;

	/* Check if pin number is in valid range.
	*/
	if (pin >= NUM_DIGITAL_PINS_EXTENDED)
9d002c40:	2c82002f 	sltiu	v0,a0,47
//*	Reading from PORT gives you a snapshot of the actual pins state regardless of how, 
//*	if at all, the PIC is trying to drive them.  
//*	Reading from LAT gives you the values last written to the pins, whether thru LAT or PORT.
//************************************************************************
void digitalWrite(uint8_t pin, uint8_t val)
{
9d002c44:	afbf0024 	sw	ra,36(sp)
9d002c48:	afb10020 	sw	s1,32(sp)
9d002c4c:	afb0001c 	sw	s0,28(sp)
uint8_t					timer;
uint32_t                cn;

	/* Check if pin number is in valid range.
	*/
	if (pin >= NUM_DIGITAL_PINS_EXTENDED)
9d002c50:	10400020 	beqz	v0,9d002cd4 <digitalWrite+0x9c>
9d002c54:	30a500ff 	andi	a1,a1,0xff
		return;
	}
#endif		// OPT_BOARD_DIGITAL_IO

	//* Get the port number for this pin.
	if ((port = digitalPinToPort(pin)) == NOT_A_PIN)
9d002c58:	3c029d00 	lui	v0,0x9d00
9d002c5c:	2442666c 	addiu	v0,v0,26220
9d002c60:	00821021 	addu	v0,a0,v0
9d002c64:	90420000 	lbu	v0,0(v0)
9d002c68:	1040001a 	beqz	v0,9d002cd4 <digitalWrite+0x9c>
9d002c6c:	3c039d00 	lui	v1,0x9d00
	{
		return;
	}

	//* Obtain pointer to the registers for this io port.
	iop = portRegisters(port);
9d002c70:	24636648 	addiu	v1,v1,26184
9d002c74:	00021080 	sll	v0,v0,0x2
9d002c78:	00431021 	addu	v0,v0,v1
9d002c7c:	8c500000 	lw	s0,0(v0)

	//* Obtain bit mask for the specific bit for this pin.
	bit = digitalPinToBitMask(pin);
9d002c80:	3c069d00 	lui	a2,0x9d00
9d002c84:	00041040 	sll	v0,a0,0x1
9d002c88:	24c6669c 	addiu	a2,a2,26268
9d002c8c:	00463021 	addu	a2,v0,a2

    //* If the port is in input mode and we write a value to it
    //* we must be enabling or disabling the internal pull-up
    //* resistor.  Only works for pins that have an associated
    //* change notification pin.
    if (iop->tris.reg & bit) {
9d002c90:	8e030000 	lw	v1,0(s0)
9d002c94:	94d10000 	lhu	s1,0(a2)
9d002c98:	02231824 	and	v1,s1,v1
9d002c9c:	10600012 	beqz	v1,9d002ce8 <digitalWrite+0xb0>
9d002ca0:	3c039d00 	lui	v1,0x9d00
        } else {
            iop->cnpu.set = bit;
            iop->cnpd.clr = bit;
        }
#else
        cn = digitalPinToCN(pin);
9d002ca4:	3c029d00 	lui	v0,0x9d00
9d002ca8:	2442675c 	addiu	v0,v0,26460
9d002cac:	00042080 	sll	a0,a0,0x2
9d002cb0:	00822021 	addu	a0,a0,v0
9d002cb4:	8c820000 	lw	v0,0(a0)
        if (cn != NOT_CN_PIN) {
9d002cb8:	240300ff 	li	v1,255
9d002cbc:	10430006 	beq	v0,v1,9d002cd8 <digitalWrite+0xa0>
9d002cc0:	8fbf0024 	lw	ra,36(sp)
            if (val == LOW) {
9d002cc4:	14a0001a 	bnez	a1,9d002d30 <digitalWrite+0xf8>
9d002cc8:	3c03bf88 	lui	v1,0xbf88
                CNPUECLR = cn;
9d002ccc:	3c03bf88 	lui	v1,0xbf88
9d002cd0:	ac6261e4 	sw	v0,25060(v1)
        else
        {
            iop->lat.set = bit;
        }
    }
}
9d002cd4:	8fbf0024 	lw	ra,36(sp)
9d002cd8:	8fb10020 	lw	s1,32(sp)
9d002cdc:	8fb0001c 	lw	s0,28(sp)
9d002ce0:	03e00008 	jr	ra
9d002ce4:	27bd0028 	addiu	sp,sp,40
#endif

    } else {
        //* Determine if this is an output compare pin. If so,
        //* we need to make sure PWM output is off.
        timer = digitalPinToTimerOC(pin);
9d002ce8:	246366fc 	addiu	v1,v1,26364
9d002cec:	00431021 	addu	v0,v0,v1
9d002cf0:	90440000 	lbu	a0,0(v0)
9d002cf4:	3084000f 	andi	a0,a0,0xf
        if (timer != NOT_ON_TIMER)
9d002cf8:	14800009 	bnez	a0,9d002d20 <digitalWrite+0xe8>
9d002cfc:	00000000 	nop
        {
            turnOffPWM(timer);
        }

        //* Set the pin state
        if (val == LOW)
9d002d00:	10a0000e 	beqz	a1,9d002d3c <digitalWrite+0x104>
9d002d04:	00000000 	nop
        else
        {
            iop->lat.set = bit;
        }
    }
}
9d002d08:	8fbf0024 	lw	ra,36(sp)
        {
            iop->lat.clr = bit;
        }
        else
        {
            iop->lat.set = bit;
9d002d0c:	ae110028 	sw	s1,40(s0)
        }
    }
}
9d002d10:	8fb10020 	lw	s1,32(sp)
9d002d14:	8fb0001c 	lw	s0,28(sp)
9d002d18:	03e00008 	jr	ra
9d002d1c:	27bd0028 	addiu	sp,sp,40
        //* Determine if this is an output compare pin. If so,
        //* we need to make sure PWM output is off.
        timer = digitalPinToTimerOC(pin);
        if (timer != NOT_ON_TIMER)
        {
            turnOffPWM(timer);
9d002d20:	0f400b52 	jal	9d002d48 <turnOffPWM>
9d002d24:	afa50010 	sw	a1,16(sp)
9d002d28:	0b400b40 	j	9d002d00 <digitalWrite+0xc8>
9d002d2c:	8fa50010 	lw	a1,16(sp)
        cn = digitalPinToCN(pin);
        if (cn != NOT_CN_PIN) {
            if (val == LOW) {
                CNPUECLR = cn;
            } else {
                CNPUESET = cn;
9d002d30:	ac6261e8 	sw	v0,25064(v1)
        else
        {
            iop->lat.set = bit;
        }
    }
}
9d002d34:	0b400b36 	j	9d002cd8 <digitalWrite+0xa0>
9d002d38:	8fbf0024 	lw	ra,36(sp)
        }

        //* Set the pin state
        if (val == LOW)
        {
            iop->lat.clr = bit;
9d002d3c:	ae110024 	sw	s1,36(s0)
        else
        {
            iop->lat.set = bit;
        }
    }
}
9d002d40:	0b400b36 	j	9d002cd8 <digitalWrite+0xa0>
9d002d44:	8fbf0024 	lw	ra,36(sp)

9d002d48 <turnOffPWM>:
}


//************************************************************************
void turnOffPWM(uint8_t timer)
{
9d002d48:	308400ff 	andi	a0,a0,0xff
	*/
	ocp = (p32_oc *)(_OCMP1_BASE_ADDRESS + (0x200 * (timer - (_TIMER_OC1 >> _BN_TIMER_OC))));
	ocp->ocxCon.clr = OCCON_ON;

	// Turn off the bit saying that this PWM is active.
	pwm_active &= ~(1 << (timer - (_TIMER_OC1 >> _BN_TIMER_OC)));
9d002d4c:	2482ffff 	addiu	v0,a0,-1
9d002d50:	24030001 	li	v1,1
9d002d54:	9385802c 	lbu	a1,-32724(gp)
9d002d58:	00431004 	sllv	v0,v1,v0
{
	p32_oc *	ocp;

	/* Disable the output compare.
	*/
	ocp = (p32_oc *)(_OCMP1_BASE_ADDRESS + (0x200 * (timer - (_TIMER_OC1 >> _BN_TIMER_OC))));
9d002d5c:	3c03005f 	lui	v1,0x5f
9d002d60:	3463c017 	ori	v1,v1,0xc017
9d002d64:	00832021 	addu	a0,a0,v1
	ocp->ocxCon.clr = OCCON_ON;

	// Turn off the bit saying that this PWM is active.
	pwm_active &= ~(1 << (timer - (_TIMER_OC1 >> _BN_TIMER_OC)));
9d002d68:	00021027 	nor	v0,zero,v0
{
	p32_oc *	ocp;

	/* Disable the output compare.
	*/
	ocp = (p32_oc *)(_OCMP1_BASE_ADDRESS + (0x200 * (timer - (_TIMER_OC1 >> _BN_TIMER_OC))));
9d002d6c:	00042240 	sll	a0,a0,0x9
	ocp->ocxCon.clr = OCCON_ON;
9d002d70:	34038000 	li	v1,0x8000

	// Turn off the bit saying that this PWM is active.
	pwm_active &= ~(1 << (timer - (_TIMER_OC1 >> _BN_TIMER_OC)));
9d002d74:	00451024 	and	v0,v0,a1
	p32_oc *	ocp;

	/* Disable the output compare.
	*/
	ocp = (p32_oc *)(_OCMP1_BASE_ADDRESS + (0x200 * (timer - (_TIMER_OC1 >> _BN_TIMER_OC))));
	ocp->ocxCon.clr = OCCON_ON;
9d002d78:	ac830004 	sw	v1,4(a0)

	// Turn off the bit saying that this PWM is active.
	pwm_active &= ~(1 << (timer - (_TIMER_OC1 >> _BN_TIMER_OC)));

	// If no PWM are active, turn off the timer.
	if (pwm_active == 0)
9d002d7c:	14400003 	bnez	v0,9d002d8c <turnOffPWM+0x44>
9d002d80:	a382802c 	sb	v0,-32724(gp)
	{
    	T2CONCLR = TBCON_ON;
9d002d84:	3c02bf80 	lui	v0,0xbf80
9d002d88:	ac430804 	sw	v1,2052(v0)
9d002d8c:	03e00008 	jr	ra
9d002d90:	00000000 	nop

9d002d94 <_initTaskManager>:
void
_initTaskManager() {
	int		id;

	for (id = 0; id < NUM_TASKS; id++) {
		rgtaskTable[id].pfnTask = 0;
9d002d94:	3c03a000 	lui	v1,0xa000
9d002d98:	24620588 	addiu	v0,v1,1416
9d002d9c:	ac600588 	sw	zero,1416(v1)
9d002da0:	ac400014 	sw	zero,20(v0)
9d002da4:	ac400028 	sw	zero,40(v0)
9d002da8:	ac40003c 	sw	zero,60(v0)
9d002dac:	ac400050 	sw	zero,80(v0)
9d002db0:	ac400064 	sw	zero,100(v0)
9d002db4:	ac400078 	sw	zero,120(v0)
9d002db8:	ac40008c 	sw	zero,140(v0)
	}

	tmsLastEvent = 0;
9d002dbc:	af808038 	sw	zero,-32712(gp)
	tmsNextEvent = 0;

}
9d002dc0:	03e00008 	jr	ra
9d002dc4:	af808034 	sw	zero,-32716(gp)

9d002dc8 <_scheduleTask>:
	unsigned long	tmsCur;		//current system time
	unsigned long	tmsNxt;		//time for next event for this task
	unsigned long	dtmsNext;
	unsigned long	dtms;

	if (cntActiveTask == 0) {
9d002dc8:	8f828030 	lw	v0,-32720(gp)
**	xxxN..C..........................................Lxx
**		current time and next time have wrapped: (N < L) && (C >= N)
*/

void
_scheduleTask() {
9d002dcc:	27bdffc8 	addiu	sp,sp,-56
9d002dd0:	afbf0034 	sw	ra,52(sp)
9d002dd4:	afb50030 	sw	s5,48(sp)
9d002dd8:	afb4002c 	sw	s4,44(sp)
9d002ddc:	afb30028 	sw	s3,40(sp)
9d002de0:	afb20024 	sw	s2,36(sp)
9d002de4:	afb10020 	sw	s1,32(sp)
	unsigned long	tmsCur;		//current system time
	unsigned long	tmsNxt;		//time for next event for this task
	unsigned long	dtmsNext;
	unsigned long	dtms;

	if (cntActiveTask == 0) {
9d002de8:	1440000a 	bnez	v0,9d002e14 <_scheduleTask+0x4c>
9d002dec:	afb0001c 	sw	s0,28(sp)

	/* Compute when the next event time will be by adding the event
	** time delta to the current time.
	*/
	tmsNextEvent = tmsCur + dtmsNext;
}
9d002df0:	8fbf0034 	lw	ra,52(sp)
9d002df4:	8fb50030 	lw	s5,48(sp)
9d002df8:	8fb4002c 	lw	s4,44(sp)
9d002dfc:	8fb30028 	lw	s3,40(sp)
9d002e00:	8fb20024 	lw	s2,36(sp)
9d002e04:	8fb10020 	lw	s1,32(sp)
9d002e08:	8fb0001c 	lw	s0,28(sp)
9d002e0c:	03e00008 	jr	ra
9d002e10:	27bd0038 	addiu	sp,sp,56

	if (cntActiveTask == 0) {
		return;
	}

	tmsCur = millis();
9d002e14:	0f400a63 	jal	9d00298c <millis>
9d002e18:	00000000 	nop

	/* The system millisecond timer will overflow every 49.71 days. The complexity of
	** this conditional is to account for the cases where either the next event time has
	** wrapped around or the current time has wrapped around.
	*/
	if ( ((tmsNextEvent >= tmsLastEvent) &&
9d002e1c:	8f848034 	lw	a0,-32716(gp)
9d002e20:	8f838038 	lw	v1,-32712(gp)
9d002e24:	0083282b 	sltu	a1,a0,v1
9d002e28:	14a00048 	bnez	a1,9d002f4c <_scheduleTask+0x184>
9d002e2c:	0043182b 	sltu	v1,v0,v1
9d002e30:	14600004 	bnez	v1,9d002e44 <_scheduleTask+0x7c>
9d002e34:	3c10a000 	lui	s0,0xa000
				((tmsCur >= tmsLastEvent) && (tmsCur < tmsNextEvent))) ||
9d002e38:	0044202b 	sltu	a0,v0,a0
9d002e3c:	1480ffec 	bnez	a0,9d002df0 <_scheduleTask+0x28>
9d002e40:	3c10a000 	lui	s0,0xa000
9d002e44:	26100598 	addiu	s0,s0,1432
**	xxxN..C..........................................Lxx
**		current time and next time have wrapped: (N < L) && (C >= N)
*/

void
_scheduleTask() {
9d002e48:	2413ffff 	li	s3,-1
9d002e4c:	00008821 	move	s1,zero

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
			(*rgtaskTable[id].pfnTask)(id, rgtaskTable[id].varTask);
			rgtaskTable[id].fsFlags &= ~fsBusy;
9d002e50:	2415fffe 	li	s5,-2

			/* Decrement the repeat count.
			*/
			if ((rgtaskTable[id].stTask > 0) &&
9d002e54:	3414fffe 	li	s4,0xfffe
	** the table for all events that have elapsed and call their
	** associated functions, update their next event timers, and then
	** figure out when the next event time is.
	*/
	dtmsNext = 0xFFFFFFFF;
	for (id = 0; id < NUM_TASKS; id++) {
9d002e58:	24120008 	li	s2,8
		/* If this isn't an active task, go to the next one.
		*/
		if ((rgtaskTable[id].pfnTask == 0) || 
9d002e5c:	8e03fff0 	lw	v1,-16(s0)
9d002e60:	5060002c 	beqzl	v1,9d002f14 <_scheduleTask+0x14c>
9d002e64:	26310001 	addiu	s1,s1,1
9d002e68:	96040000 	lhu	a0,0(s0)
9d002e6c:	50800029 	beqzl	a0,9d002f14 <_scheduleTask+0x14c>
9d002e70:	26310001 	addiu	s1,s1,1
		** occur if a user task function calls delay() or any other
		** function that causes _scheduleTask to be called recursively.
		** This prevents the task function from being called recursively
		** until the system crashes.
		*/
		if ((rgtaskTable[id].fsFlags & fsBusy) != 0) {
9d002e74:	96040002 	lhu	a0,2(s0)
9d002e78:	30840001 	andi	a0,a0,0x1
9d002e7c:	54800025 	bnezl	a0,9d002f14 <_scheduleTask+0x14c>
9d002e80:	26310001 	addiu	s1,s1,1
			continue;
		}

		/* Check if this task's period has timed out.
		*/
		tmsNxt = rgtaskTable[id].tmsNext;
9d002e84:	8e04fff8 	lw	a0,-8(s0)
		if ( ((tmsNxt >= tmsLastEvent) && 
9d002e88:	8f858038 	lw	a1,-32712(gp)
9d002e8c:	0085302b 	sltu	a2,a0,a1
9d002e90:	10c00032 	beqz	a2,9d002f5c <_scheduleTask+0x194>
9d002e94:	0044302b 	sltu	a2,v0,a0
						((tmsCur >= tmsNxt) || (tmsCur < tmsLastEvent))) ||
			 ((tmsNxt <  tmsLastEvent) && 
9d002e98:	54c0001b 	bnezl	a2,9d002f08 <_scheduleTask+0x140>
9d002e9c:	00822023 	subu	a0,a0,v0
						((tmsCur >= tmsNxt) && (tmsCur < tmsLastEvent))) ) {
9d002ea0:	0045282b 	sltu	a1,v0,a1
9d002ea4:	50a00018 	beqzl	a1,9d002f08 <_scheduleTask+0x140>
9d002ea8:	00822023 	subu	a0,a0,v0
			*/
			rgtaskTable[id].tmsNext += rgtaskTable[id].tmsPeriod;

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
9d002eac:	96060002 	lhu	a2,2(s0)
						((tmsCur >= tmsNxt) && (tmsCur < tmsLastEvent))) ) {

			/* This task event has timed out. Update the event time for the
			** next event on this task.
			*/
			rgtaskTable[id].tmsNext += rgtaskTable[id].tmsPeriod;
9d002eb0:	8e07fff4 	lw	a3,-12(s0)

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
			(*rgtaskTable[id].pfnTask)(id, rgtaskTable[id].varTask);
9d002eb4:	8e05fffc 	lw	a1,-4(s0)
			*/
			rgtaskTable[id].tmsNext += rgtaskTable[id].tmsPeriod;

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
9d002eb8:	34c60001 	ori	a2,a2,0x1
						((tmsCur >= tmsNxt) && (tmsCur < tmsLastEvent))) ) {

			/* This task event has timed out. Update the event time for the
			** next event on this task.
			*/
			rgtaskTable[id].tmsNext += rgtaskTable[id].tmsPeriod;
9d002ebc:	00e42021 	addu	a0,a3,a0
9d002ec0:	ae04fff8 	sw	a0,-8(s0)

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
			(*rgtaskTable[id].pfnTask)(id, rgtaskTable[id].varTask);
9d002ec4:	afa20010 	sw	v0,16(sp)
9d002ec8:	02202021 	move	a0,s1
9d002ecc:	0060f809 	jalr	v1
9d002ed0:	a6060002 	sh	a2,2(s0)
			rgtaskTable[id].fsFlags &= ~fsBusy;

			/* Decrement the repeat count.
			*/
			if ((rgtaskTable[id].stTask > 0) &&
9d002ed4:	96030000 	lhu	v1,0(s0)

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
			(*rgtaskTable[id].pfnTask)(id, rgtaskTable[id].varTask);
			rgtaskTable[id].fsFlags &= ~fsBusy;
9d002ed8:	96050002 	lhu	a1,2(s0)

			/* Decrement the repeat count.
			*/
			if ((rgtaskTable[id].stTask > 0) &&
9d002edc:	8fa20010 	lw	v0,16(sp)
9d002ee0:	2463ffff 	addiu	v1,v1,-1
9d002ee4:	3063ffff 	andi	v1,v1,0xffff

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
			(*rgtaskTable[id].pfnTask)(id, rgtaskTable[id].varTask);
			rgtaskTable[id].fsFlags &= ~fsBusy;
9d002ee8:	00b52824 	and	a1,a1,s5

			/* Decrement the repeat count.
			*/
			if ((rgtaskTable[id].stTask > 0) &&
9d002eec:	0074202b 	sltu	a0,v1,s4
9d002ef0:	10800003 	beqz	a0,9d002f00 <_scheduleTask+0x138>
9d002ef4:	a6050002 	sh	a1,2(s0)
				rgtaskTable[id].stTask -= 1;

				/* The task state counter has gone to 0. This task is now
				** disabled.
				*/
				if (rgtaskTable[id].stTask == 0) {
9d002ef8:	1060001c 	beqz	v1,9d002f6c <_scheduleTask+0x1a4>
9d002efc:	a6030000 	sh	v1,0(s0)
9d002f00:	8e04fff8 	lw	a0,-8(s0)
		}

		/* Compute delta of this event time from the current time and
		** remember it if it is less than the current delta.
		*/
		dtms = rgtaskTable[id].tmsNext - tmsCur;
9d002f04:	00822023 	subu	a0,a0,v0
		if (dtms < dtmsNext) {
9d002f08:	0093182b 	sltu	v1,a0,s3
9d002f0c:	0083980b 	movn	s3,a0,v1
	** the table for all events that have elapsed and call their
	** associated functions, update their next event timers, and then
	** figure out when the next event time is.
	*/
	dtmsNext = 0xFFFFFFFF;
	for (id = 0; id < NUM_TASKS; id++) {
9d002f10:	26310001 	addiu	s1,s1,1
9d002f14:	1632ffd1 	bne	s1,s2,9d002e5c <_scheduleTask+0x94>
9d002f18:	26100014 	addiu	s0,s0,20

	/* Compute when the next event time will be by adding the event
	** time delta to the current time.
	*/
	tmsNextEvent = tmsCur + dtmsNext;
}
9d002f1c:	8fbf0034 	lw	ra,52(sp)
	tmsLastEvent = tmsCur;

	/* Compute when the next event time will be by adding the event
	** time delta to the current time.
	*/
	tmsNextEvent = tmsCur + dtmsNext;
9d002f20:	02629821 	addu	s3,s3,v0
9d002f24:	af938034 	sw	s3,-32716(gp)
}
9d002f28:	8fb50030 	lw	s5,48(sp)
9d002f2c:	8fb4002c 	lw	s4,44(sp)
9d002f30:	8fb30028 	lw	s3,40(sp)
9d002f34:	8fb20024 	lw	s2,36(sp)
9d002f38:	8fb10020 	lw	s1,32(sp)
9d002f3c:	8fb0001c 	lw	s0,28(sp)
	}

	/* All done with event tasks. Update the last event time with
	** the current time.
	*/
	tmsLastEvent = tmsCur;
9d002f40:	af828038 	sw	v0,-32712(gp)

	/* Compute when the next event time will be by adding the event
	** time delta to the current time.
	*/
	tmsNextEvent = tmsCur + dtmsNext;
}
9d002f44:	03e00008 	jr	ra
9d002f48:	27bd0038 	addiu	sp,sp,56
	** this conditional is to account for the cases where either the next event time has
	** wrapped around or the current time has wrapped around.
	*/
	if ( ((tmsNextEvent >= tmsLastEvent) &&
				((tmsCur >= tmsLastEvent) && (tmsCur < tmsNextEvent))) ||
		 ((tmsNextEvent < tmsLastEvent) &&
9d002f4c:	5460ffbb 	bnezl	v1,9d002e3c <_scheduleTask+0x74>
9d002f50:	0044202b 	sltu	a0,v0,a0

	/* Compute when the next event time will be by adding the event
	** time delta to the current time.
	*/
	tmsNextEvent = tmsCur + dtmsNext;
}
9d002f54:	0b400b7d 	j	9d002df4 <_scheduleTask+0x2c>
9d002f58:	8fbf0034 	lw	ra,52(sp)
		}

		/* Check if this task's period has timed out.
		*/
		tmsNxt = rgtaskTable[id].tmsNext;
		if ( ((tmsNxt >= tmsLastEvent) && 
9d002f5c:	50c0ffd4 	beqzl	a2,9d002eb0 <_scheduleTask+0xe8>
9d002f60:	96060002 	lhu	a2,2(s0)
						((tmsCur >= tmsNxt) || (tmsCur < tmsLastEvent))) ||
			 ((tmsNxt <  tmsLastEvent) && 
						((tmsCur >= tmsNxt) && (tmsCur < tmsLastEvent))) ) {
9d002f64:	0b400ba9 	j	9d002ea4 <_scheduleTask+0xdc>
9d002f68:	0045282b 	sltu	a1,v0,a1
				/* The task state counter has gone to 0. This task is now
				** disabled.
				*/
				if (rgtaskTable[id].stTask == 0) {
					rgtaskTable[id].tmsNext = 0;
					cntActiveTask -= 1;
9d002f6c:	8f838030 	lw	v1,-32720(gp)

				/* The task state counter has gone to 0. This task is now
				** disabled.
				*/
				if (rgtaskTable[id].stTask == 0) {
					rgtaskTable[id].tmsNext = 0;
9d002f70:	ae00fff8 	sw	zero,-8(s0)
					cntActiveTask -= 1;
9d002f74:	2463ffff 	addiu	v1,v1,-1
					continue;
9d002f78:	0b400bc4 	j	9d002f10 <_scheduleTask+0x148>
9d002f7c:	af838030 	sw	v1,-32720(gp)

9d002f80 <initIntVector>:
*/
void initIntVector(void)
{
    const IMAGE_HEADER_INFO * pImageHeader = getImageHeaderInfoStructure();
    int i = 0;
    void * pvOrgIntVec = pImageHeader->pOrgVector0;
9d002f80:	3c029d00 	lui	v0,0x9d00
9d002f84:	244264bc 	addiu	v0,v0,25788
9d002f88:	88430043 	lwl	v1,67(v0)
9d002f8c:	8846004b 	lwl	a2,75(v0)
    {
        // If a compiler installed interrupt handler exits, pre-load it
        // and don't fool with the priority
        if(*((uint32_t *) pvOrgIntVec) != 0xFFFFFFFF)
        {
            _isr_primary_install[i] = (isrFunc) pvOrgIntVec;
9d002f90:	3c08a000 	lui	t0,0xa000
*/
void initIntVector(void)
{
    const IMAGE_HEADER_INFO * pImageHeader = getImageHeaderInfoStructure();
    int i = 0;
    void * pvOrgIntVec = pImageHeader->pOrgVector0;
9d002f94:	98430040 	lwr	v1,64(v0)
9d002f98:	98460048 	lwr	a2,72(v0)

    for(i=0; i<NUM_INT_VECTOR; i++)
    {
        // If a compiler installed interrupt handler exits, pre-load it
        // and don't fool with the priority
        if(*((uint32_t *) pvOrgIntVec) != 0xFFFFFFFF)
9d002f9c:	2409ffff 	li	t1,-1
{
    const IMAGE_HEADER_INFO * pImageHeader = getImageHeaderInfoStructure();
    int i = 0;
    void * pvOrgIntVec = pImageHeader->pOrgVector0;

    for(i=0; i<NUM_INT_VECTOR; i++)
9d002fa0:	00001021 	move	v0,zero
    {
        // If a compiler installed interrupt handler exits, pre-load it
        // and don't fool with the priority
        if(*((uint32_t *) pvOrgIntVec) != 0xFFFFFFFF)
        {
            _isr_primary_install[i] = (isrFunc) pvOrgIntVec;
9d002fa4:	25080020 	addiu	t0,t0,32
{
    const IMAGE_HEADER_INFO * pImageHeader = getImageHeaderInfoStructure();
    int i = 0;
    void * pvOrgIntVec = pImageHeader->pOrgVector0;

    for(i=0; i<NUM_INT_VECTOR; i++)
9d002fa8:	2407002d 	li	a3,45
    {
        // If a compiler installed interrupt handler exits, pre-load it
        // and don't fool with the priority
        if(*((uint32_t *) pvOrgIntVec) != 0xFFFFFFFF)
9d002fac:	8c640000 	lw	a0,0(v1)
        {
            _isr_primary_install[i] = (isrFunc) pvOrgIntVec;
9d002fb0:	00022880 	sll	a1,v0,0x2
9d002fb4:	00a82821 	addu	a1,a1,t0

    for(i=0; i<NUM_INT_VECTOR; i++)
    {
        // If a compiler installed interrupt handler exits, pre-load it
        // and don't fool with the priority
        if(*((uint32_t *) pvOrgIntVec) != 0xFFFFFFFF)
9d002fb8:	10890002 	beq	a0,t1,9d002fc4 <initIntVector+0x44>
9d002fbc:	24420001 	addiu	v0,v0,1
        {
            _isr_primary_install[i] = (isrFunc) pvOrgIntVec;
9d002fc0:	aca30000 	sw	v1,0(a1)
{
    const IMAGE_HEADER_INFO * pImageHeader = getImageHeaderInfoStructure();
    int i = 0;
    void * pvOrgIntVec = pImageHeader->pOrgVector0;

    for(i=0; i<NUM_INT_VECTOR; i++)
9d002fc4:	1447fff9 	bne	v0,a3,9d002fac <initIntVector+0x2c>
9d002fc8:	00661821 	addu	v1,v1,a2
9d002fcc:	03e00008 	jr	ra
9d002fd0:	00000000 	nop

9d002fd4 <setIntVector>:
isrFunc setIntVector(int vec, isrFunc func)
{
    const IMAGE_HEADER_INFO * pImageHeader = getImageHeaderInfoStructure();
    isrFunc t = 0;

    if (vec < NUM_INT_VECTOR)
9d002fd4:	2883002d 	slti	v1,a0,45
9d002fd8:	10600007 	beqz	v1,9d002ff8 <setIntVector+0x24>
9d002fdc:	00001021 	move	v0,zero
    {
        t = _isr_primary_install[vec];
9d002fe0:	3c02a000 	lui	v0,0xa000
9d002fe4:	24420020 	addiu	v0,v0,32
9d002fe8:	00042080 	sll	a0,a0,0x2
9d002fec:	00822021 	addu	a0,a0,v0
9d002ff0:	8c820000 	lw	v0,0(a0)
        _isr_primary_install[vec] = func;       
9d002ff4:	ac850000 	sw	a1,0(a0)
    }

    return t;
}
9d002ff8:	03e00008 	jr	ra
9d002ffc:	00000000 	nop

9d003000 <setIntEnable>:
uint32_t setIntEnable(int irq)
{
	p32_regset *	iec;
	uint32_t		st;

	iec = ((p32_regset *)&IEC0) + (irq / 32);
9d003000:	28830000 	slti	v1,a0,0
9d003004:	2482001f 	addiu	v0,a0,31
9d003008:	0083100a 	movz	v0,a0,v1
9d00300c:	00021143 	sra	v0,v0,0x5
9d003010:	3c03bf88 	lui	v1,0xbf88
9d003014:	00021100 	sll	v0,v0,0x4
	st = iec->reg;
	iec->set = 1 << (irq % 32);
9d003018:	24050001 	li	a1,1
uint32_t setIntEnable(int irq)
{
	p32_regset *	iec;
	uint32_t		st;

	iec = ((p32_regset *)&IEC0) + (irq / 32);
9d00301c:	24631060 	addiu	v1,v1,4192
9d003020:	00621821 	addu	v1,v1,v0
	st = iec->reg;
	iec->set = 1 << (irq % 32);
9d003024:	00852004 	sllv	a0,a1,a0
{
	p32_regset *	iec;
	uint32_t		st;

	iec = ((p32_regset *)&IEC0) + (irq / 32);
	st = iec->reg;
9d003028:	8c620000 	lw	v0,0(v1)
	iec->set = 1 << (irq % 32);
9d00302c:	ac640008 	sw	a0,8(v1)
	return st;
}
9d003030:	03e00008 	jr	ra
9d003034:	00000000 	nop

9d003038 <setIntPriority>:
	ipc = ((p32_regset *)&IPC0) + (vec / 4);

	/* Compute the number of bit positions to shift to get to the
	** correct position for the priority bits for this vector.
	*/
	bn = 8 * (vec % 4);
9d003038:	000417c3 	sra	v0,a0,0x1f
9d00303c:	00021782 	srl	v0,v0,0x1e
9d003040:	00821821 	addu	v1,a0,v0
	int				bn;

	/* Compute the address of the interrupt priority control register used
	** by this interrupt vector
	*/
	ipc = ((p32_regset *)&IPC0) + (vec / 4);
9d003044:	24870003 	addiu	a3,a0,3
9d003048:	28880000 	slti	t0,a0,0

	/* Compute the number of bit positions to shift to get to the
	** correct position for the priority bits for this vector.
	*/
	bn = 8 * (vec % 4);
9d00304c:	30630003 	andi	v1,v1,0x3
	int				bn;

	/* Compute the address of the interrupt priority control register used
	** by this interrupt vector
	*/
	ipc = ((p32_regset *)&IPC0) + (vec / 4);
9d003050:	00e8200b 	movn	a0,a3,t0

	/* Compute the number of bit positions to shift to get to the
	** correct position for the priority bits for this vector.
	*/
	bn = 8 * (vec % 4);
9d003054:	00621023 	subu	v0,v1,v0
	int				bn;

	/* Compute the address of the interrupt priority control register used
	** by this interrupt vector
	*/
	ipc = ((p32_regset *)&IPC0) + (vec / 4);
9d003058:	00042083 	sra	a0,a0,0x2
9d00305c:	3c03bf88 	lui	v1,0xbf88
9d003060:	24631090 	addiu	v1,v1,4240
	bn = 8 * (vec % 4);

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = (0x1F << bn);
	ipc->set = ((ipl << 2) + spl) << bn;
9d003064:	00052880 	sll	a1,a1,0x2
	int				bn;

	/* Compute the address of the interrupt priority control register used
	** by this interrupt vector
	*/
	ipc = ((p32_regset *)&IPC0) + (vec / 4);
9d003068:	00042100 	sll	a0,a0,0x4
9d00306c:	00642021 	addu	a0,v1,a0

	/* Compute the number of bit positions to shift to get to the
	** correct position for the priority bits for this vector.
	*/
	bn = 8 * (vec % 4);
9d003070:	000210c0 	sll	v0,v0,0x3

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = (0x1F << bn);
	ipc->set = ((ipl << 2) + spl) << bn;
9d003074:	00c52821 	addu	a1,a2,a1
	*/
	bn = 8 * (vec % 4);

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = (0x1F << bn);
9d003078:	2403001f 	li	v1,31
9d00307c:	00431804 	sllv	v1,v1,v0
	ipc->set = ((ipl << 2) + spl) << bn;
9d003080:	00451004 	sllv	v0,a1,v0
	*/
	bn = 8 * (vec % 4);

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = (0x1F << bn);
9d003084:	ac830004 	sw	v1,4(a0)
	ipc->set = ((ipl << 2) + spl) << bn;
9d003088:	ac820008 	sw	v0,8(a0)
}
9d00308c:	03e00008 	jr	ra
9d003090:	00000000 	nop

9d003094 <getPeripheralClock>:
uint32_t getPeripheralClock()
{
	uint32_t	clkPb;

    clkPb = F_CPU;
    clkPb >>= OSCCONbits.PBDIV;
9d003094:	3c02bf81 	lui	v0,0xbf81
9d003098:	8c43f000 	lw	v1,-4096(v0)

    return clkPb;

}
9d00309c:	3c0204c4 	lui	v0,0x4c4
9d0030a0:	3442b400 	ori	v0,v0,0xb400
uint32_t getPeripheralClock()
{
	uint32_t	clkPb;

    clkPb = F_CPU;
    clkPb >>= OSCCONbits.PBDIV;
9d0030a4:	7c630cc0 	ext	v1,v1,0x13,0x2

    return clkPb;

}
9d0030a8:	03e00008 	jr	ra
9d0030ac:	00621006 	srlv	v0,v0,v1

9d0030b0 <_configSystem>:

uint32_t __attribute__((nomips16)) disableInterrupts(void)
{
    uint32_t status = 0;

    asm volatile("di    %0" : "=r"(status));
9d0030b0:	41686000 	di	t0

	stInt = disableInterrupts();

	/* Disable wait states in data ram.
	*/
	BMXCONCLR = (1 << _BMXCON_BMXWSDRM_POSITION);
9d0030b4:	24030040 	li	v1,64
9d0030b8:	3c02bf88 	lui	v0,0xbf88
9d0030bc:	ac432004 	sw	v1,8196(v0)

#ifdef _PCACHE

	stCache = CHECON;
9d0030c0:	3c07bf88 	lui	a3,0xbf88
9d0030c4:	8ce94000 	lw	t1,16384(a3)
    stCache |= (3 << _CHECON_PREFEN_POSITION);

	/* Turn on caching for KSEG0
	*/
	asm("mfc0 %0,$16,0" :  "=r"(tmp));
	tmp = (tmp & ~7) | 3;
9d0030c8:	2402fff8 	li	v0,-8
	*/
    stCache |= (3 << _CHECON_PREFEN_POSITION);

	/* Turn on caching for KSEG0
	*/
	asm("mfc0 %0,$16,0" :  "=r"(tmp));
9d0030cc:	40038000 	mfc0	v1,c0_config
	tmp = (tmp & ~7) | 3;
9d0030d0:	00621024 	and	v0,v1,v0
	stCache = CHECON;

	/* Configure predictive prefetch caching for both cached and
	** non-cached memory regions.
	*/
    stCache |= (3 << _CHECON_PREFEN_POSITION);
9d0030d4:	35290030 	ori	t1,t1,0x30

	/* Turn on caching for KSEG0
	*/
	asm("mfc0 %0,$16,0" :  "=r"(tmp));
	tmp = (tmp & ~7) | 3;
9d0030d8:	34420003 	ori	v0,v0,0x3
	asm("mtc0 %0,$16,0" :: "r" (tmp));
9d0030dc:	40828000 	mtc0	v0,c0_config

	/* Configure the number of wait states in the program flash
	*/
    wait = 0;

    while(clk > FLASH_SPEED_HZ)
9d0030e0:	3c0501c9 	lui	a1,0x1c9
9d0030e4:	34a5c381 	ori	a1,a1,0xc381
9d0030e8:	0085182b 	sltu	v1,a0,a1
9d0030ec:	14600007 	bnez	v1,9d00310c <_configSystem+0x5c>
9d0030f0:	00001021 	move	v0,zero
    {
        wait += 1;
        clk -= FLASH_SPEED_HZ;
9d0030f4:	3c06fe36 	lui	a2,0xfe36
9d0030f8:	24c63c80 	addiu	a2,a2,15488
9d0030fc:	00862021 	addu	a0,a0,a2

	/* Configure the number of wait states in the program flash
	*/
    wait = 0;

    while(clk > FLASH_SPEED_HZ)
9d003100:	0085182b 	sltu	v1,a0,a1
9d003104:	1060fffd 	beqz	v1,9d0030fc <_configSystem+0x4c>
9d003108:	24420001 	addiu	v0,v0,1
    {
        wait += 1;
        clk -= FLASH_SPEED_HZ;
    }

    stCache &= ~_CHECON_PFMWS_MASK;
9d00310c:	2404fff8 	li	a0,-8
9d003110:	01241824 	and	v1,t1,a0
	stCache |= (wait << _CHECON_PFMWS_POSITION);
9d003114:	00431025 	or	v0,v0,v1
**		enableInterrupts() or disableInterrupts().
*/

void __attribute__((nomips16))  restoreInterrupts(uint32_t st)
{
    if (st & 0x00000001)
9d003118:	31030001 	andi	v1,t0,0x1
    }

    stCache &= ~_CHECON_PFMWS_MASK;
	stCache |= (wait << _CHECON_PFMWS_POSITION);

	CHECON = stCache;
9d00311c:	14600003 	bnez	v1,9d00312c <_configSystem+0x7c>
**		enableInterrupts() or disableInterrupts().
*/

void __attribute__((nomips16))  restoreInterrupts(uint32_t st)
{
    if (st & 0x00000001)
9d003120:	ace24000 	sw	v0,16384(a3)
	{
        asm volatile("ei");
	}
    else
	{
        asm volatile("di");
9d003124:	03e00008 	jr	ra
9d003128:	41606000 	di

void __attribute__((nomips16))  restoreInterrupts(uint32_t st)
{
    if (st & 0x00000001)
	{
        asm volatile("ei");
9d00312c:	03e00008 	jr	ra
9d003130:	41606020 	ei

9d003134 <_enableMultiVectorInterrupts>:
    unsigned int val;

    /* Set the CP0 bit so that interrupt exceptions use the
	** special interrupt vector and not the general exception vector.
	*/
    asm volatile("mfc0   %0,$13" : "=r"(val));
9d003134:	40036800 	mfc0	v1,c0_cause
    val |= 0x00800000;
9d003138:	3c020080 	lui	v0,0x80
9d00313c:	00621025 	or	v0,v1,v0
    asm volatile("mtc0   %0,$13" : "+r"(val));
9d003140:	40826800 	mtc0	v0,c0_cause

	/* Turn on multi-vectored interrupts.
	*/
    INTCONSET = _INTCON_MVEC_MASK;
9d003144:	24031000 	li	v1,4096
9d003148:	3c02bf88 	lui	v0,0xbf88
9d00314c:	ac431008 	sw	v1,4104(v0)

uint32_t __attribute__((nomips16))  enableInterrupts(void)
{
    uint32_t status = 0;

    asm volatile("ei    %0" : "=r"(status));
9d003150:	03e00008 	jr	ra

    /* Enable interrupts.
	*/
    enableInterrupts();

}
9d003154:	41626020 	ei	v0

9d003158 <_initCoreTimer>:

void __attribute__((nomips16)) _initCoreTimer(uint32_t prd)
{
	/* Clear the core timer counter
	*/
    asm volatile("mtc0   $0,$9");
9d003158:	40804800 	mtc0	zero,c0_count

    /* Store the requested value in the compare register
	*/
    asm volatile("mtc0   %0,$11" : "+r"(prd));
9d00315c:	03e00008 	jr	ra
}
9d003160:	40845800 	mtc0	a0,c0_compare

9d003164 <_ZN14HardwareSerial9availableEv>:
**		receive buffer.
*/

int HardwareSerial::available(void)
{
	return (RX_BUFFER_SIZE + rx_buffer.head - rx_buffer.tail) % RX_BUFFER_SIZE;
9d003164:	8c820224 	lw	v0,548(a0)
9d003168:	8c830228 	lw	v1,552(a0)
9d00316c:	24420200 	addiu	v0,v0,512
9d003170:	00431023 	subu	v0,v0,v1
9d003174:	00021fc3 	sra	v1,v0,0x1f
9d003178:	00031dc2 	srl	v1,v1,0x17
9d00317c:	00431021 	addu	v0,v0,v1
9d003180:	304201ff 	andi	v0,v0,0x1ff
}
9d003184:	03e00008 	jr	ra
9d003188:	00431023 	subu	v0,v0,v1

9d00318c <_ZN14HardwareSerial4peekEv>:
**		removing it from the buffer, or -1 if no characters are in the buffer.
*/

int HardwareSerial::peek()
{
	if (rx_buffer.head == rx_buffer.tail)
9d00318c:	8c830228 	lw	v1,552(a0)
9d003190:	8c850224 	lw	a1,548(a0)
9d003194:	10a30003 	beq	a1,v1,9d0031a4 <_ZN14HardwareSerial4peekEv+0x18>
9d003198:	2402ffff 	li	v0,-1
	{
		return -1;
	}
	else
	{
		return rx_buffer.buffer[rx_buffer.tail];
9d00319c:	00832021 	addu	a0,a0,v1
9d0031a0:	90820024 	lbu	v0,36(a0)
	}
}
9d0031a4:	03e00008 	jr	ra
9d0031a8:	00000000 	nop

9d0031ac <_ZN14HardwareSerial4readEv>:
int HardwareSerial::read(void)
{
	unsigned char theChar;

	// if the head isn't ahead of the tail, we don't have any characters
	if (rx_buffer.head == rx_buffer.tail)
9d0031ac:	8c830228 	lw	v1,552(a0)
9d0031b0:	8c850224 	lw	a1,548(a0)
9d0031b4:	10a3000a 	beq	a1,v1,9d0031e0 <_ZN14HardwareSerial4readEv+0x34>
9d0031b8:	2402ffff 	li	v0,-1
		return -1;
	}
	else
	{
		theChar			= rx_buffer.buffer[rx_buffer.tail];
		rx_buffer.tail	= (rx_buffer.tail + 1) % RX_BUFFER_SIZE;
9d0031bc:	24660001 	addiu	a2,v1,1
9d0031c0:	00062fc3 	sra	a1,a2,0x1f
9d0031c4:	00052dc2 	srl	a1,a1,0x17
9d0031c8:	00c53021 	addu	a2,a2,a1
	{
		return -1;
	}
	else
	{
		theChar			= rx_buffer.buffer[rx_buffer.tail];
9d0031cc:	00831821 	addu	v1,a0,v1
		rx_buffer.tail	= (rx_buffer.tail + 1) % RX_BUFFER_SIZE;
9d0031d0:	30c601ff 	andi	a2,a2,0x1ff
	{
		return -1;
	}
	else
	{
		theChar			= rx_buffer.buffer[rx_buffer.tail];
9d0031d4:	90620024 	lbu	v0,36(v1)
		rx_buffer.tail	= (rx_buffer.tail + 1) % RX_BUFFER_SIZE;
9d0031d8:	00c52823 	subu	a1,a2,a1
9d0031dc:	ac850228 	sw	a1,552(a0)
		return (theChar);
	}
}
9d0031e0:	03e00008 	jr	ra
9d0031e4:	00000000 	nop

9d0031e8 <_ZN14HardwareSerial5flushEv>:
**	Description:
**		Empty the send buffer by waiting for the
**		fifo to empty and the transmitter to become idle
*/
void HardwareSerial::flush()
{
9d0031e8:	8c830004 	lw	v1,4(a0)
	while ((uart->uxSta.reg & (1 << _UARTSTA_TMRT)) == 0)	//check the TRMT bit
9d0031ec:	8c620010 	lw	v0,16(v1)
9d0031f0:	30420100 	andi	v0,v0,0x100
9d0031f4:	1040fffd 	beqz	v0,9d0031ec <_ZN14HardwareSerial5flushEv+0x4>
9d0031f8:	00000000 	nop
	{
		//* wait for the transmitter to be clear
	}
}
9d0031fc:	03e00008 	jr	ra
9d003200:	00000000 	nop

9d003204 <_ZN14HardwareSerial5purgeEv>:
	// don't reverse this or there may be problems if the RX interrupt
	// occurs after reading the value of rx_buffer_head but before writing
	// the value to rx_buffer_tail; the previous value of rx_buffer_head
	// may be written to rx_buffer_tail, making it appear as if the buffer
	// were full, not empty.
	rx_buffer.head = rx_buffer.tail;
9d003204:	8c820228 	lw	v0,552(a0)
}
9d003208:	03e00008 	jr	ra
9d00320c:	ac820224 	sw	v0,548(a0)

9d003210 <_ZN14HardwareSerial5writeEh>:
**		Wait until the transmitter is idle, and then transmit the
**		specified character.
*/

void HardwareSerial::write(uint8_t theChar)
{
9d003210:	8c820004 	lw	v0,4(a0)
9d003214:	30a500ff 	andi	a1,a1,0xff

	while ((uart->uxSta.reg & (1 << _UARTSTA_UTXBF)) != 0)	//check the UTXBF bit
9d003218:	8c430010 	lw	v1,16(v0)
9d00321c:	30630200 	andi	v1,v1,0x200
9d003220:	1460fffd 	bnez	v1,9d003218 <_ZN14HardwareSerial5writeEh+0x8>
9d003224:	00000000 	nop
  {
		//* wait for the transmitter buffer to have room
	}

	uart->uxTx.reg = theChar;
9d003228:	ac450020 	sw	a1,32(v0)
}
9d00322c:	03e00008 	jr	ra
9d003230:	00000000 	nop

9d003234 <_ZN14HardwareSerial5beginEm>:
	p32_regset *	ipc;	//interrupt priority control register set
	int				irq_shift;

	/* Initialize the receive buffer.
	*/
	purge();
9d003234:	8c820000 	lw	v0,0(a0)
**		Initialize the UART for use, setting the baud rate to the
**		requested value, data size of 8-bits, and no parity.
*/

void HardwareSerial::begin(unsigned long baudRate)
{
9d003238:	27bdffe0 	addiu	sp,sp,-32
9d00323c:	afbf001c 	sw	ra,28(sp)
	p32_regset *	ipc;	//interrupt priority control register set
	int				irq_shift;

	/* Initialize the receive buffer.
	*/
	purge();
9d003240:	8c42001c 	lw	v0,28(v0)
**		Initialize the UART for use, setting the baud rate to the
**		requested value, data size of 8-bits, and no parity.
*/

void HardwareSerial::begin(unsigned long baudRate)
{
9d003244:	afb10018 	sw	s1,24(sp)
9d003248:	afb00014 	sw	s0,20(sp)
9d00324c:	00808021 	move	s0,a0
	p32_regset *	ipc;	//interrupt priority control register set
	int				irq_shift;

	/* Initialize the receive buffer.
	*/
	purge();
9d003250:	0040f809 	jalr	v0
9d003254:	00a08821 	move	s1,a1
	/* Map the UART RX to the appropriate pin.
	*/
    mapPps(pinRx, ppsRx);
#endif

    setIntVector(vec, isr);
9d003258:	9204000d 	lbu	a0,13(s0)
9d00325c:	0f400bf5 	jal	9d002fd4 <setIntVector>
9d003260:	8e050008 	lw	a1,8(s0)

	/* Set the interrupt privilege level and sub-privilege level
	*/
	setIntPriority(vec, ipl, spl);
9d003264:	9204000d 	lbu	a0,13(s0)
9d003268:	9205000e 	lbu	a1,14(s0)
9d00326c:	0f400c0e 	jal	9d003038 <setIntPriority>
9d003270:	9206000f 	lbu	a2,15(s0)

	/* Clear the interrupt flags, and set the interrupt enables for the
	** interrupts used by this UART.
	*/
	ifs->clr = bit_rx + bit_tx + bit_err;	//clear all interrupt flags
9d003274:	8e04001c 	lw	a0,28(s0)
9d003278:	8e050020 	lw	a1,32(s0)
9d00327c:	8e060018 	lw	a2,24(s0)
9d003280:	8e070010 	lw	a3,16(s0)
9d003284:	00852821 	addu	a1,a0,a1

	iec->clr = bit_rx + bit_tx + bit_err;	//disable all interrupts
9d003288:	8e030014 	lw	v1,20(s0)

	/* Initialize the UART itself.
	**	http://www.chipkit.org/forum/viewtopic.php?f=7&t=213&p=948#p948
    ** Use high baud rate divisor for bauds over LOW_HIGH_BAUD_SPLIT
    */
	uart->uxSta.reg = 0;
9d00328c:	8e020004 	lw	v0,4(s0)
	setIntPriority(vec, ipl, spl);

	/* Clear the interrupt flags, and set the interrupt enables for the
	** interrupts used by this UART.
	*/
	ifs->clr = bit_rx + bit_tx + bit_err;	//clear all interrupt flags
9d003290:	00a62821 	addu	a1,a1,a2
	/* Initialize the UART itself.
	**	http://www.chipkit.org/forum/viewtopic.php?f=7&t=213&p=948#p948
    ** Use high baud rate divisor for bauds over LOW_HIGH_BAUD_SPLIT
    */
	uart->uxSta.reg = 0;
    if (baudRate < LOW_HIGH_BAUD_SPLIT)
9d003294:	3c060003 	lui	a2,0x3
9d003298:	24c60d40 	addiu	a2,a2,3392
9d00329c:	0226302b 	sltu	a2,s1,a2
	setIntPriority(vec, ipl, spl);

	/* Clear the interrupt flags, and set the interrupt enables for the
	** interrupts used by this UART.
	*/
	ifs->clr = bit_rx + bit_tx + bit_err;	//clear all interrupt flags
9d0032a0:	ace50004 	sw	a1,4(a3)

	iec->clr = bit_rx + bit_tx + bit_err;	//disable all interrupts
9d0032a4:	ac650004 	sw	a1,4(v1)
	iec->set = bit_rx;						//enable rx interrupts
9d0032a8:	ac640008 	sw	a0,8(v1)

	/* Initialize the UART itself.
	**	http://www.chipkit.org/forum/viewtopic.php?f=7&t=213&p=948#p948
    ** Use high baud rate divisor for bauds over LOW_HIGH_BAUD_SPLIT
    */
	uart->uxSta.reg = 0;
9d0032ac:	ac400010 	sw	zero,16(v0)
    if (baudRate < LOW_HIGH_BAUD_SPLIT)
9d0032b0:	14c00011 	bnez	a2,9d0032f8 <_ZN14HardwareSerial5beginEm+0xc4>
9d0032b4:	8f83803c 	lw	v1,-32708(gp)
    {
        uart->uxBrg.reg    = ((__PIC32_pbClk / 4 / baudRate) - 1);       // calculate actual BAUD generate value.
        uart->uxMode.reg = (1 << _UARTMODE_ON) | (1 << _UARTMODE_BRGH);  // enable UART module
    }
    uart->uxSta.reg  = (1 << _UARTSTA_UTXEN) + (1 << _UARTSTA_URXEN);    // enable transmitter and receiver
}
9d0032b8:	8fbf001c 	lw	ra,28(sp)
9d0032bc:	8fb00014 	lw	s0,20(sp)
        uart->uxBrg.reg    = ((__PIC32_pbClk / 16 / baudRate) - 1);      // calculate actual BAUD generate value.
        uart->uxMode.reg = (1 << _UARTMODE_ON);                          // enable UART module
    }
    else
    {
        uart->uxBrg.reg    = ((__PIC32_pbClk / 4 / baudRate) - 1);       // calculate actual BAUD generate value.
9d0032c0:	00031882 	srl	v1,v1,0x2
9d0032c4:	0071001b 	divu	zero,v1,s1
9d0032c8:	022001f4 	teq	s1,zero,0x7
        uart->uxMode.reg = (1 << _UARTMODE_ON) | (1 << _UARTMODE_BRGH);  // enable UART module
    }
    uart->uxSta.reg  = (1 << _UARTSTA_UTXEN) + (1 << _UARTSTA_URXEN);    // enable transmitter and receiver
}
9d0032cc:	8fb10018 	lw	s1,24(sp)
9d0032d0:	27bd0020 	addiu	sp,sp,32
        uart->uxBrg.reg    = ((__PIC32_pbClk / 16 / baudRate) - 1);      // calculate actual BAUD generate value.
        uart->uxMode.reg = (1 << _UARTMODE_ON);                          // enable UART module
    }
    else
    {
        uart->uxBrg.reg    = ((__PIC32_pbClk / 4 / baudRate) - 1);       // calculate actual BAUD generate value.
9d0032d4:	00001812 	mflo	v1
9d0032d8:	2463ffff 	addiu	v1,v1,-1
9d0032dc:	ac430040 	sw	v1,64(v0)
        uart->uxMode.reg = (1 << _UARTMODE_ON) | (1 << _UARTMODE_BRGH);  // enable UART module
9d0032e0:	34038008 	li	v1,0x8008
9d0032e4:	ac430000 	sw	v1,0(v0)
    }
    uart->uxSta.reg  = (1 << _UARTSTA_UTXEN) + (1 << _UARTSTA_URXEN);    // enable transmitter and receiver
9d0032e8:	24031400 	li	v1,5120
9d0032ec:	ac430010 	sw	v1,16(v0)
}
9d0032f0:	03e00008 	jr	ra
9d0032f4:	00000000 	nop
9d0032f8:	8fbf001c 	lw	ra,28(sp)
9d0032fc:	8fb00014 	lw	s0,20(sp)
    ** Use high baud rate divisor for bauds over LOW_HIGH_BAUD_SPLIT
    */
	uart->uxSta.reg = 0;
    if (baudRate < LOW_HIGH_BAUD_SPLIT)
    {
        uart->uxBrg.reg    = ((__PIC32_pbClk / 16 / baudRate) - 1);      // calculate actual BAUD generate value.
9d003300:	00031902 	srl	v1,v1,0x4
9d003304:	0071001b 	divu	zero,v1,s1
9d003308:	022001f4 	teq	s1,zero,0x7
    {
        uart->uxBrg.reg    = ((__PIC32_pbClk / 4 / baudRate) - 1);       // calculate actual BAUD generate value.
        uart->uxMode.reg = (1 << _UARTMODE_ON) | (1 << _UARTMODE_BRGH);  // enable UART module
    }
    uart->uxSta.reg  = (1 << _UARTSTA_UTXEN) + (1 << _UARTSTA_URXEN);    // enable transmitter and receiver
}
9d00330c:	8fb10018 	lw	s1,24(sp)
9d003310:	27bd0020 	addiu	sp,sp,32
    ** Use high baud rate divisor for bauds over LOW_HIGH_BAUD_SPLIT
    */
	uart->uxSta.reg = 0;
    if (baudRate < LOW_HIGH_BAUD_SPLIT)
    {
        uart->uxBrg.reg    = ((__PIC32_pbClk / 16 / baudRate) - 1);      // calculate actual BAUD generate value.
9d003314:	00001812 	mflo	v1
9d003318:	2463ffff 	addiu	v1,v1,-1
9d00331c:	ac430040 	sw	v1,64(v0)
        uart->uxMode.reg = (1 << _UARTMODE_ON);                          // enable UART module
9d003320:	34038000 	li	v1,0x8000
9d003324:	ac430000 	sw	v1,0(v0)
    else
    {
        uart->uxBrg.reg    = ((__PIC32_pbClk / 4 / baudRate) - 1);       // calculate actual BAUD generate value.
        uart->uxMode.reg = (1 << _UARTMODE_ON) | (1 << _UARTMODE_BRGH);  // enable UART module
    }
    uart->uxSta.reg  = (1 << _UARTSTA_UTXEN) + (1 << _UARTSTA_URXEN);    // enable transmitter and receiver
9d003328:	24031400 	li	v1,5120
9d00332c:	ac430010 	sw	v1,16(v0)
}
9d003330:	03e00008 	jr	ra
9d003334:	00000000 	nop

9d003338 <_ZN14HardwareSerial11doSerialIntEv>:
	uint8_t	ch;

	/* If it's a receive interrupt, get the character and store
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
9d003338:	8c820010 	lw	v0,16(a0)
9d00333c:	8c83001c 	lw	v1,28(a0)
9d003340:	8c450000 	lw	a1,0(v0)
9d003344:	00652824 	and	a1,v1,a1
9d003348:	10a00010 	beqz	a1,9d00338c <_ZN14HardwareSerial11doSerialIntEv+0x54>
9d00334c:	00000000 	nop
	{
		ch = uart->uxRx.reg;
		bufIndex	= (rx_buffer.head + 1) % RX_BUFFER_SIZE;
9d003350:	8c870224 	lw	a3,548(a0)
	/* If it's a receive interrupt, get the character and store
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
	{
		ch = uart->uxRx.reg;
9d003354:	8c890004 	lw	t1,4(a0)
		/* If we should be storing the received character into the location
		** just before the tail (meaning that the head would advance to the
		** current location of the tail), we're about to overflow the buffer
		** and so we don't write the character or advance the head.
		*/
		if (bufIndex != rx_buffer.tail)
9d003358:	8c880228 	lw	t0,552(a0)
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
	{
		ch = uart->uxRx.reg;
		bufIndex	= (rx_buffer.head + 1) % RX_BUFFER_SIZE;
9d00335c:	24e60001 	addiu	a2,a3,1
9d003360:	00062fc3 	sra	a1,a2,0x1f
9d003364:	00052dc2 	srl	a1,a1,0x17
9d003368:	00c53021 	addu	a2,a2,a1
9d00336c:	30c601ff 	andi	a2,a2,0x1ff
9d003370:	00c52823 	subu	a1,a2,a1
	/* If it's a receive interrupt, get the character and store
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
	{
		ch = uart->uxRx.reg;
9d003374:	8d260030 	lw	a2,48(t1)
		/* If we should be storing the received character into the location
		** just before the tail (meaning that the head would advance to the
		** current location of the tail), we're about to overflow the buffer
		** and so we don't write the character or advance the head.
		*/
		if (bufIndex != rx_buffer.tail)
9d003378:	11050003 	beq	t0,a1,9d003388 <_ZN14HardwareSerial11doSerialIntEv+0x50>
9d00337c:	00873821 	addu	a3,a0,a3
	/* If it's a receive interrupt, get the character and store
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
	{
		ch = uart->uxRx.reg;
9d003380:	a0e60024 	sb	a2,36(a3)
		** and so we don't write the character or advance the head.
		*/
		if (bufIndex != rx_buffer.tail)
		{
			rx_buffer.buffer[rx_buffer.head] = ch;
			rx_buffer.head = bufIndex;
9d003384:	ac850224 	sw	a1,548(a0)
		}

		/* Clear the interrupt flag.
		*/
		ifs->clr = bit_rx;
9d003388:	ac430004 	sw	v1,4(v0)
	}

	/* If it's a transmit interrupt, ignore it, as we don't current
	** have interrupt driven i/o on the transmit side.
	*/
	if ((ifs->reg & bit_tx) != 0)
9d00338c:	8c450000 	lw	a1,0(v0)
9d003390:	8c830020 	lw	v1,32(a0)
9d003394:	00652024 	and	a0,v1,a1
9d003398:	54800001 	bnezl	a0,9d0033a0 <_ZN14HardwareSerial11doSerialIntEv+0x68>
9d00339c:	ac430004 	sw	v1,4(v0)
9d0033a0:	03e00008 	jr	ra
9d0033a4:	00000000 	nop

9d0033a8 <IntSer1Handler>:
**		serial port 1.
*/
#if defined(_SER1_VECTOR)

void __attribute__((interrupt(), nomips16)) IntSer1Handler(void)
{
9d0033a8:	415de800 	rdpgpr	sp,sp
9d0033ac:	401b7000 	mfc0	k1,c0_epc
9d0033b0:	401a6002 	mfc0	k0,c0_srsctl
9d0033b4:	27bdff90 	addiu	sp,sp,-112
9d0033b8:	afbb006c 	sw	k1,108(sp)
9d0033bc:	401b6000 	mfc0	k1,c0_status
9d0033c0:	afba0068 	sw	k0,104(sp)
9d0033c4:	401a6800 	mfc0	k0,c0_cause
9d0033c8:	001ad282 	srl	k0,k0,0xa
9d0033cc:	afbb0064 	sw	k1,100(sp)
9d0033d0:	7f5b7a84 	ins	k1,k0,0xa,0x6
9d0033d4:	7c1b2044 	ins	k1,zero,0x1,0x4
9d0033d8:	409b6000 	mtc0	k1,c0_status
9d0033dc:	afa30018 	sw	v1,24(sp)
9d0033e0:	8fa30068 	lw	v1,104(sp)
9d0033e4:	3063000f 	andi	v1,v1,0xf
9d0033e8:	14600011 	bnez	v1,9d003430 <IntSer1Handler+0x88>
9d0033ec:	afa20014 	sw	v0,20(sp)
9d0033f0:	afbf0054 	sw	ra,84(sp)
9d0033f4:	afb90050 	sw	t9,80(sp)
9d0033f8:	afb8004c 	sw	t8,76(sp)
9d0033fc:	afaf0048 	sw	t7,72(sp)
9d003400:	afae0044 	sw	t6,68(sp)
9d003404:	afad0040 	sw	t5,64(sp)
9d003408:	afac003c 	sw	t4,60(sp)
9d00340c:	afab0038 	sw	t3,56(sp)
9d003410:	afaa0034 	sw	t2,52(sp)
9d003414:	afa90030 	sw	t1,48(sp)
9d003418:	afa8002c 	sw	t0,44(sp)
9d00341c:	afa70028 	sw	a3,40(sp)
9d003420:	afa60024 	sw	a2,36(sp)
9d003424:	afa50020 	sw	a1,32(sp)
9d003428:	afa4001c 	sw	a0,28(sp)
9d00342c:	afa10010 	sw	at,16(sp)
	Serial1.doSerialInt();
9d003430:	3c04a000 	lui	a0,0xa000
**		serial port 1.
*/
#if defined(_SER1_VECTOR)

void __attribute__((interrupt(), nomips16)) IntSer1Handler(void)
{
9d003434:	00001012 	mflo	v0
	Serial1.doSerialInt();
9d003438:	24840854 	addiu	a0,a0,2132
**		serial port 1.
*/
#if defined(_SER1_VECTOR)

void __attribute__((interrupt(), nomips16)) IntSer1Handler(void)
{
9d00343c:	afa2005c 	sw	v0,92(sp)
9d003440:	00001810 	mfhi	v1
	Serial1.doSerialInt();
9d003444:	0f400cce 	jal	9d003338 <_ZN14HardwareSerial11doSerialIntEv>
9d003448:	afa30058 	sw	v1,88(sp)
}
9d00344c:	8fa2005c 	lw	v0,92(sp)
9d003450:	8fa30058 	lw	v1,88(sp)
9d003454:	00400013 	mtlo	v0
9d003458:	8fa20068 	lw	v0,104(sp)
9d00345c:	3042000f 	andi	v0,v0,0xf
9d003460:	14400013 	bnez	v0,9d0034b0 <IntSer1Handler+0x108>
9d003464:	00600011 	mthi	v1
9d003468:	8fbf0054 	lw	ra,84(sp)
9d00346c:	8fb90050 	lw	t9,80(sp)
9d003470:	8fb8004c 	lw	t8,76(sp)
9d003474:	8faf0048 	lw	t7,72(sp)
9d003478:	8fae0044 	lw	t6,68(sp)
9d00347c:	8fad0040 	lw	t5,64(sp)
9d003480:	8fac003c 	lw	t4,60(sp)
9d003484:	8fab0038 	lw	t3,56(sp)
9d003488:	8faa0034 	lw	t2,52(sp)
9d00348c:	8fa90030 	lw	t1,48(sp)
9d003490:	8fa8002c 	lw	t0,44(sp)
9d003494:	8fa70028 	lw	a3,40(sp)
9d003498:	8fa60024 	lw	a2,36(sp)
9d00349c:	8fa50020 	lw	a1,32(sp)
9d0034a0:	8fa4001c 	lw	a0,28(sp)
9d0034a4:	8fa30018 	lw	v1,24(sp)
9d0034a8:	8fa20014 	lw	v0,20(sp)
9d0034ac:	8fa10010 	lw	at,16(sp)
9d0034b0:	41606000 	di
9d0034b4:	000000c0 	ehb
9d0034b8:	8fba006c 	lw	k0,108(sp)
9d0034bc:	8fbb0064 	lw	k1,100(sp)
9d0034c0:	409a7000 	mtc0	k0,c0_epc
9d0034c4:	8fba0068 	lw	k0,104(sp)
9d0034c8:	27bd0070 	addiu	sp,sp,112
9d0034cc:	409a6002 	mtc0	k0,c0_srsctl
9d0034d0:	41dde800 	wrpgpr	sp,sp
9d0034d4:	409b6000 	mtc0	k1,c0_status
9d0034d8:	42000018 	eret

9d0034dc <IntSer0Handler>:
**		serial port 0.
*/
#if defined(_SER0_VECTOR)

void __attribute__((interrupt(), nomips16)) IntSer0Handler(void)
{
9d0034dc:	415de800 	rdpgpr	sp,sp
9d0034e0:	401b7000 	mfc0	k1,c0_epc
9d0034e4:	401a6002 	mfc0	k0,c0_srsctl
9d0034e8:	27bdff90 	addiu	sp,sp,-112
9d0034ec:	afbb006c 	sw	k1,108(sp)
9d0034f0:	401b6000 	mfc0	k1,c0_status
9d0034f4:	afba0068 	sw	k0,104(sp)
9d0034f8:	401a6800 	mfc0	k0,c0_cause
9d0034fc:	001ad282 	srl	k0,k0,0xa
9d003500:	afbb0064 	sw	k1,100(sp)
9d003504:	7f5b7a84 	ins	k1,k0,0xa,0x6
9d003508:	7c1b2044 	ins	k1,zero,0x1,0x4
9d00350c:	409b6000 	mtc0	k1,c0_status
9d003510:	afa30018 	sw	v1,24(sp)
9d003514:	8fa30068 	lw	v1,104(sp)
9d003518:	3063000f 	andi	v1,v1,0xf
9d00351c:	14600011 	bnez	v1,9d003564 <IntSer0Handler+0x88>
9d003520:	afa20014 	sw	v0,20(sp)
9d003524:	afbf0054 	sw	ra,84(sp)
9d003528:	afb90050 	sw	t9,80(sp)
9d00352c:	afb8004c 	sw	t8,76(sp)
9d003530:	afaf0048 	sw	t7,72(sp)
9d003534:	afae0044 	sw	t6,68(sp)
9d003538:	afad0040 	sw	t5,64(sp)
9d00353c:	afac003c 	sw	t4,60(sp)
9d003540:	afab0038 	sw	t3,56(sp)
9d003544:	afaa0034 	sw	t2,52(sp)
9d003548:	afa90030 	sw	t1,48(sp)
9d00354c:	afa8002c 	sw	t0,44(sp)
9d003550:	afa70028 	sw	a3,40(sp)
9d003554:	afa60024 	sw	a2,36(sp)
9d003558:	afa50020 	sw	a1,32(sp)
9d00355c:	afa4001c 	sw	a0,28(sp)
9d003560:	afa10010 	sw	at,16(sp)
#if defined(_USB) && defined(_USE_USB_FOR_SERIAL_)
	Serial0.doSerialInt();
#else
	Serial.doSerialInt();
9d003564:	3c04a000 	lui	a0,0xa000
**		serial port 0.
*/
#if defined(_SER0_VECTOR)

void __attribute__((interrupt(), nomips16)) IntSer0Handler(void)
{
9d003568:	00001012 	mflo	v0
#if defined(_USB) && defined(_USE_USB_FOR_SERIAL_)
	Serial0.doSerialInt();
#else
	Serial.doSerialInt();
9d00356c:	24840628 	addiu	a0,a0,1576
**		serial port 0.
*/
#if defined(_SER0_VECTOR)

void __attribute__((interrupt(), nomips16)) IntSer0Handler(void)
{
9d003570:	afa2005c 	sw	v0,92(sp)
9d003574:	00001810 	mfhi	v1
#if defined(_USB) && defined(_USE_USB_FOR_SERIAL_)
	Serial0.doSerialInt();
#else
	Serial.doSerialInt();
9d003578:	0f400cce 	jal	9d003338 <_ZN14HardwareSerial11doSerialIntEv>
9d00357c:	afa30058 	sw	v1,88(sp)
#endif
}
9d003580:	8fa2005c 	lw	v0,92(sp)
9d003584:	8fa30058 	lw	v1,88(sp)
9d003588:	00400013 	mtlo	v0
9d00358c:	8fa20068 	lw	v0,104(sp)
9d003590:	3042000f 	andi	v0,v0,0xf
9d003594:	14400013 	bnez	v0,9d0035e4 <IntSer0Handler+0x108>
9d003598:	00600011 	mthi	v1
9d00359c:	8fbf0054 	lw	ra,84(sp)
9d0035a0:	8fb90050 	lw	t9,80(sp)
9d0035a4:	8fb8004c 	lw	t8,76(sp)
9d0035a8:	8faf0048 	lw	t7,72(sp)
9d0035ac:	8fae0044 	lw	t6,68(sp)
9d0035b0:	8fad0040 	lw	t5,64(sp)
9d0035b4:	8fac003c 	lw	t4,60(sp)
9d0035b8:	8fab0038 	lw	t3,56(sp)
9d0035bc:	8faa0034 	lw	t2,52(sp)
9d0035c0:	8fa90030 	lw	t1,48(sp)
9d0035c4:	8fa8002c 	lw	t0,44(sp)
9d0035c8:	8fa70028 	lw	a3,40(sp)
9d0035cc:	8fa60024 	lw	a2,36(sp)
9d0035d0:	8fa50020 	lw	a1,32(sp)
9d0035d4:	8fa4001c 	lw	a0,28(sp)
9d0035d8:	8fa30018 	lw	v1,24(sp)
9d0035dc:	8fa20014 	lw	v0,20(sp)
9d0035e0:	8fa10010 	lw	at,16(sp)
9d0035e4:	41606000 	di
9d0035e8:	000000c0 	ehb
9d0035ec:	8fba006c 	lw	k0,108(sp)
9d0035f0:	8fbb0064 	lw	k1,100(sp)
9d0035f4:	409a7000 	mtc0	k0,c0_epc
9d0035f8:	8fba0068 	lw	k0,104(sp)
9d0035fc:	27bd0070 	addiu	sp,sp,112
9d003600:	409a6002 	mtc0	k0,c0_srsctl
9d003604:	41dde800 	wrpgpr	sp,sp
9d003608:	409b6000 	mtc0	k1,c0_status
9d00360c:	42000018 	eret

9d003610 <_GLOBAL__I__ZN14HardwareSerialC2EP8p32_uartiiiiPFvvE>:
*/

#if defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler, int pinT, int pinR, ppsFunctionType ppsT, ppsFunctionType ppsR)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
9d003610:	3c069d00 	lui	a2,0x9d00
9d003614:	3c09a000 	lui	t1,0xa000
9d003618:	24c66818 	addiu	a2,a2,26648
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d00361c:	3c07bf88 	lui	a3,0xbf88
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler, int pinT, int pinR, ppsFunctionType ppsT, ppsFunctionType ppsR)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
#endif
{
	uart = uartT;
9d003620:	25230628 	addiu	v1,t1,1576
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d003624:	24e71060 	addiu	a3,a3,4192
*/

#if defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler, int pinT, int pinR, ppsFunctionType ppsT, ppsFunctionType ppsR)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
9d003628:	ad260628 	sw	a2,1576(t1)
#endif
{
	uart = uartT;
	irq  = irqT;
9d00362c:	2409001a 	li	t1,26
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d003630:	24eb0010 	addiu	t3,a3,16
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
#endif
{
	uart = uartT;
	irq  = irqT;
9d003634:	a069000c 	sb	t1,12(v1)
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d003638:	ac670014 	sw	a3,20(v1)
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
#endif
{
	uart = uartT;
	irq  = irqT;
	vec  = vecT;
9d00363c:	24090018 	li	t1,24
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
9d003640:	3c070400 	lui	a3,0x400
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler, int pinT, int pinR, ppsFunctionType ppsT, ppsFunctionType ppsR)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
#endif
{
	uart = uartT;
9d003644:	3c0abf80 	lui	t2,0xbf80
	irq  = irqT;
	vec  = vecT;
9d003648:	a069000d 	sb	t1,13(v1)
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
9d00364c:	ac670018 	sw	a3,24(v1)
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d003650:	3c08bf88 	lui	t0,0xbf88
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
9d003654:	3c070800 	lui	a3,0x800
	vec  = vecT;
	irq  = (uint8_t)irqT;
	vec  = (uint8_t)vecT;
	ipl  = (uint8_t)iplT;
	spl  = (uint8_t)splT;
    isr  = isrHandler;
9d003658:	3c099d00 	lui	t1,0x9d00
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d00365c:	25081030 	addiu	t0,t0,4144
*/

#if defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler, int pinT, int pinR, ppsFunctionType ppsT, ppsFunctionType ppsR)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
9d003660:	3c05a000 	lui	a1,0xa000
	uart = uartT;
	irq  = irqT;
	vec  = vecT;
	irq  = (uint8_t)irqT;
	vec  = (uint8_t)vecT;
	ipl  = (uint8_t)iplT;
9d003664:	24040002 	li	a0,2
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler, int pinT, int pinR, ppsFunctionType ppsT, ppsFunctionType ppsR)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
#endif
{
	uart = uartT;
9d003668:	254d6000 	addiu	t5,t2,24576
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
9d00366c:	ac67001c 	sw	a3,28(v1)
	vec  = vecT;
	irq  = (uint8_t)irqT;
	vec  = (uint8_t)vecT;
	ipl  = (uint8_t)iplT;
	spl  = (uint8_t)splT;
    isr  = isrHandler;
9d003670:	252934dc 	addiu	t1,t1,13532
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
	bit_tx  = 1 << ((irq+2) % 32);	//tx interrupt flag/enable bit
9d003674:	3c071000 	lui	a3,0x1000
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler, int pinT, int pinR, ppsFunctionType ppsT, ppsFunctionType ppsR)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
#endif
{
	uart = uartT;
9d003678:	24a20854 	addiu	v0,a1,2132
9d00367c:	ac6d0004 	sw	t5,4(v1)
	irq  = irqT;
	vec  = vecT;
	irq  = (uint8_t)irqT;
	vec  = (uint8_t)vecT;
	ipl  = (uint8_t)iplT;
9d003680:	a064000e 	sb	a0,14(v1)
	spl  = (uint8_t)splT;
9d003684:	a060000f 	sb	zero,15(v1)
    isr  = isrHandler;
9d003688:	ac690008 	sw	t1,8(v1)
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d00368c:	ac680010 	sw	t0,16(v1)
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
	bit_tx  = 1 << ((irq+2) % 32);	//tx interrupt flag/enable bit
9d003690:	ac670020 	sw	a3,32(v1)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
#endif
{
	uart = uartT;
	irq  = irqT;
9d003694:	24030028 	li	v1,40
9d003698:	a043000c 	sb	v1,12(v0)
	vec  = vecT;
9d00369c:	24030020 	li	v1,32
9d0036a0:	a043000d 	sb	v1,13(v0)
	irq  = (uint8_t)irqT;
	vec  = (uint8_t)vecT;
	ipl  = (uint8_t)iplT;
	spl  = (uint8_t)splT;
    isr  = isrHandler;
9d0036a4:	3c039d00 	lui	v1,0x9d00
9d0036a8:	246333a8 	addiu	v1,v1,13224
9d0036ac:	ac430008 	sw	v1,8(v0)
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
9d0036b0:	24030100 	li	v1,256
9d0036b4:	ac430018 	sw	v1,24(v0)
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
9d0036b8:	24030200 	li	v1,512
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler, int pinT, int pinR, ppsFunctionType ppsT, ppsFunctionType ppsR)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
#endif
{
	uart = uartT;
9d0036bc:	254a6200 	addiu	t2,t2,25088
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d0036c0:	250c0010 	addiu	t4,t0,16
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
9d0036c4:	ac43001c 	sw	v1,28(v0)
	bit_tx  = 1 << ((irq+2) % 32);	//tx interrupt flag/enable bit
9d0036c8:	24030400 	li	v1,1024
*/

#if defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler, int pinT, int pinR, ppsFunctionType ppsT, ppsFunctionType ppsR)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
9d0036cc:	aca60854 	sw	a2,2132(a1)
#endif
{
	uart = uartT;
9d0036d0:	ac4a0004 	sw	t2,4(v0)
	irq  = irqT;
	vec  = vecT;
	irq  = (uint8_t)irqT;
	vec  = (uint8_t)vecT;
	ipl  = (uint8_t)iplT;
9d0036d4:	a044000e 	sb	a0,14(v0)
	spl  = (uint8_t)splT;
9d0036d8:	a040000f 	sb	zero,15(v0)
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d0036dc:	ac4c0010 	sw	t4,16(v0)
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d0036e0:	ac4b0014 	sw	t3,20(v0)

#if defined(_SER1_BASE)
#if defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)
HardwareSerial Serial1((p32_uart *)_SER1_BASE, _SER1_IRQ, _SER1_VECTOR, _SER1_IPL, _SER1_SPL, IntSer1Handler, _SER1_TX_PIN, _SER1_RX_PIN, _SER1_TX_OUT, _SER1_RX_IN);
#else
HardwareSerial Serial1((p32_uart *)_SER1_BASE, _SER1_IRQ, _SER1_VECTOR, _SER1_IPL, _SER1_SPL, IntSer1Handler);
9d0036e4:	03e00008 	jr	ra
9d0036e8:	ac430020 	sw	v1,32(v0)

9d0036ec <_ZN5Print5writeEPKc>:

//************************************************************************
/* default implementation: may be overridden */
//************************************************************************
void Print::write(const char *str)
{
9d0036ec:	27bdffe0 	addiu	sp,sp,-32
9d0036f0:	afb10018 	sw	s1,24(sp)
9d0036f4:	afb00014 	sw	s0,20(sp)
9d0036f8:	afbf001c 	sw	ra,28(sp)
9d0036fc:	00a08021 	move	s0,a1
	while (*str)
9d003700:	80a50000 	lb	a1,0(a1)
9d003704:	10a0000a 	beqz	a1,9d003730 <_ZN5Print5writeEPKc+0x44>
9d003708:	00808821 	move	s1,a0
	{
		write(*str++);
9d00370c:	8e220000 	lw	v0,0(s1)
9d003710:	30a500ff 	andi	a1,a1,0xff
9d003714:	26100001 	addiu	s0,s0,1
9d003718:	8c420000 	lw	v0,0(v0)
9d00371c:	0040f809 	jalr	v0
9d003720:	02202021 	move	a0,s1
//************************************************************************
/* default implementation: may be overridden */
//************************************************************************
void Print::write(const char *str)
{
	while (*str)
9d003724:	82050000 	lb	a1,0(s0)
9d003728:	54a0fff9 	bnezl	a1,9d003710 <_ZN5Print5writeEPKc+0x24>
9d00372c:	8e220000 	lw	v0,0(s1)
	{
		write(*str++);
	}
}
9d003730:	8fbf001c 	lw	ra,28(sp)
9d003734:	8fb10018 	lw	s1,24(sp)
9d003738:	8fb00014 	lw	s0,20(sp)
9d00373c:	03e00008 	jr	ra
9d003740:	27bd0020 	addiu	sp,sp,32

9d003744 <_ZN5Print5writeEPKhm>:

//************************************************************************
/* default implementation: may be overridden */
//************************************************************************
void Print::write(const uint8_t *buffer, size_t size)
{
9d003744:	27bdffe0 	addiu	sp,sp,-32
9d003748:	afb20018 	sw	s2,24(sp)
9d00374c:	afb10014 	sw	s1,20(sp)
9d003750:	afb00010 	sw	s0,16(sp)
9d003754:	afbf001c 	sw	ra,28(sp)
9d003758:	00c08021 	move	s0,a2
9d00375c:	00809021 	move	s2,a0
	while (size--)
9d003760:	10c0000a 	beqz	a2,9d00378c <_ZN5Print5writeEPKhm+0x48>
9d003764:	00a08821 	move	s1,a1
	{
		write(*buffer++);
9d003768:	8e420000 	lw	v0,0(s2)
9d00376c:	92250000 	lbu	a1,0(s1)
9d003770:	2610ffff 	addiu	s0,s0,-1
9d003774:	8c420000 	lw	v0,0(v0)
9d003778:	02402021 	move	a0,s2
9d00377c:	0040f809 	jalr	v0
9d003780:	26310001 	addiu	s1,s1,1
//************************************************************************
/* default implementation: may be overridden */
//************************************************************************
void Print::write(const uint8_t *buffer, size_t size)
{
	while (size--)
9d003784:	5600fff9 	bnezl	s0,9d00376c <_ZN5Print5writeEPKhm+0x28>
9d003788:	8e420000 	lw	v0,0(s2)
	{
		write(*buffer++);
	}
}
9d00378c:	8fbf001c 	lw	ra,28(sp)
9d003790:	8fb20018 	lw	s2,24(sp)
9d003794:	8fb10014 	lw	s1,20(sp)
9d003798:	8fb00010 	lw	s0,16(sp)
9d00379c:	03e00008 	jr	ra
9d0037a0:	27bd0020 	addiu	sp,sp,32

9d0037a4 <_ZN5Print5printEPKc>:
	}
}
//************************************************************************
void Print::print(const char str[])
{
	write(str);
9d0037a4:	8c820000 	lw	v0,0(a0)
9d0037a8:	8c590004 	lw	t9,4(v0)
9d0037ac:	03200008 	jr	t9
9d0037b0:	00000000 	nop

9d0037b4 <_ZN5Print11printNumberEmh>:

// Private Methods /////////////////////////////////////////////////////////////

//************************************************************************
void Print::printNumber(unsigned long n, uint8_t base)
{
9d0037b4:	27bdffc0 	addiu	sp,sp,-64
9d0037b8:	afb10038 	sw	s1,56(sp)
9d0037bc:	afb00034 	sw	s0,52(sp)
9d0037c0:	afbf003c 	sw	ra,60(sp)
9d0037c4:	00808021 	move	s0,a0
9d0037c8:	30c600ff 	andi	a2,a2,0xff
unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars.
unsigned long i = 0;

	if (n == 0)
9d0037cc:	10a00020 	beqz	a1,9d003850 <_ZN5Print11printNumberEmh+0x9c>
9d0037d0:	00008821 	move	s1,zero
		return;
	}

	while (n > 0)
	{
		buf[i++] = n % base;
9d0037d4:	00a6001b 	divu	zero,a1,a2
9d0037d8:	00c001f4 	teq	a2,zero,0x7
}

// Private Methods /////////////////////////////////////////////////////////////

//************************************************************************
void Print::printNumber(unsigned long n, uint8_t base)
9d0037dc:	27a40010 	addiu	a0,sp,16
9d0037e0:	00911021 	addu	v0,a0,s1
		return;
	}

	while (n > 0)
	{
		buf[i++] = n % base;
9d0037e4:	26310001 	addiu	s1,s1,1
9d0037e8:	00001810 	mfhi	v1
9d0037ec:	00002812 	mflo	a1
	{
		print('0');
		return;
	}

	while (n > 0)
9d0037f0:	14a0fff8 	bnez	a1,9d0037d4 <_ZN5Print11printNumberEmh+0x20>
9d0037f4:	a0430000 	sb	v1,0(v0)
	{
		buf[i++] = n % base;
		n /= base;
	}

	for (; i > 0; i--)
9d0037f8:	12200011 	beqz	s1,9d003840 <_ZN5Print11printNumberEmh+0x8c>
9d0037fc:	8fbf003c 	lw	ra,60(sp)
}

// Private Methods /////////////////////////////////////////////////////////////

//************************************************************************
void Print::printNumber(unsigned long n, uint8_t base)
9d003800:	27a30010 	addiu	v1,sp,16
9d003804:	00711021 	addu	v0,v1,s1
		n /= base;
	}

	for (; i > 0; i--)
	{
		print((char) (buf[i - 1] < 10 ?
9d003808:	9042ffff 	lbu	v0,-1(v0)
					'0' + buf[i - 1] :
					'A' + buf[i - 1] - 10));
9d00380c:	24450030 	addiu	a1,v0,48
9d003810:	2c43000a 	sltiu	v1,v0,10
9d003814:	7c052c20 	seb	a1,a1
9d003818:	14600002 	bnez	v1,9d003824 <_ZN5Print11printNumberEmh+0x70>
9d00381c:	24420037 	addiu	v0,v0,55
9d003820:	7c022c20 	seb	a1,v0
	{
		buf[i++] = n % base;
		n /= base;
	}

	for (; i > 0; i--)
9d003824:	2631ffff 	addiu	s1,s1,-1
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d003828:	02002021 	move	a0,s0
9d00382c:	0f400e24 	jal	9d003890 <_ZN5Print5printEli>
9d003830:	00003021 	move	a2,zero
	{
		buf[i++] = n % base;
		n /= base;
	}

	for (; i > 0; i--)
9d003834:	1620fff3 	bnez	s1,9d003804 <_ZN5Print11printNumberEmh+0x50>
9d003838:	27a30010 	addiu	v1,sp,16
	{
		print((char) (buf[i - 1] < 10 ?
					'0' + buf[i - 1] :
					'A' + buf[i - 1] - 10));
	}
}
9d00383c:	8fbf003c 	lw	ra,60(sp)
9d003840:	8fb10038 	lw	s1,56(sp)
9d003844:	8fb00034 	lw	s0,52(sp)
9d003848:	03e00008 	jr	ra
9d00384c:	27bd0040 	addiu	sp,sp,64
9d003850:	8fbf003c 	lw	ra,60(sp)
9d003854:	8fb10038 	lw	s1,56(sp)
9d003858:	8fb00034 	lw	s0,52(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d00385c:	24050030 	li	a1,48
9d003860:	00003021 	move	a2,zero
9d003864:	0b400e24 	j	9d003890 <_ZN5Print5printEli>
9d003868:	27bd0040 	addiu	sp,sp,64

9d00386c <_ZN5Print5printEmi>:
}

//************************************************************************
void Print::print(unsigned long n, int base)
{
	if (base == 0)
9d00386c:	50c00003 	beqzl	a2,9d00387c <_ZN5Print5printEmi+0x10>
9d003870:	8c830000 	lw	v1,0(a0)
	{
		write(n);
	}
	else
	{
		printNumber(n, base);
9d003874:	0b400ded 	j	9d0037b4 <_ZN5Print11printNumberEmh>
9d003878:	30c600ff 	andi	a2,a2,0xff
//************************************************************************
void Print::print(unsigned long n, int base)
{
	if (base == 0)
	{
		write(n);
9d00387c:	8c790000 	lw	t9,0(v1)
9d003880:	03200008 	jr	t9
9d003884:	30a500ff 	andi	a1,a1,0xff

9d003888 <_ZN5Print5printEhi>:
}

//************************************************************************
void Print::print(unsigned char b, int base)
{
	print((unsigned long) b, base);
9d003888:	0b400e1b 	j	9d00386c <_ZN5Print5printEmi>
9d00388c:	30a500ff 	andi	a1,a1,0xff

9d003890 <_ZN5Print5printEli>:
	print((unsigned long) n, base);
}

//************************************************************************
void Print::print(long n, int base)
{
9d003890:	27bdffe0 	addiu	sp,sp,-32
9d003894:	afb10018 	sw	s1,24(sp)
9d003898:	afb00014 	sw	s0,20(sp)
9d00389c:	afbf001c 	sw	ra,28(sp)
9d0038a0:	00808821 	move	s1,a0
	if (base == 0)
9d0038a4:	10c00013 	beqz	a2,9d0038f4 <_ZN5Print5printEli+0x64>
9d0038a8:	00a08021 	move	s0,a1
	{
		write(n);
	}
	else if (base == 10)
9d0038ac:	2402000a 	li	v0,10
9d0038b0:	10c20006 	beq	a2,v0,9d0038cc <_ZN5Print5printEli+0x3c>
9d0038b4:	8fbf001c 	lw	ra,28(sp)
	}
	else
	{
		printNumber(n, base);
	}
}
9d0038b8:	8fb10018 	lw	s1,24(sp)
9d0038bc:	8fb00014 	lw	s0,20(sp)
		}
		printNumber(n, 10);
	}
	else
	{
		printNumber(n, base);
9d0038c0:	30c600ff 	andi	a2,a2,0xff
9d0038c4:	0b400ded 	j	9d0037b4 <_ZN5Print11printNumberEmh>
9d0038c8:	27bd0020 	addiu	sp,sp,32
	{
		write(n);
	}
	else if (base == 10)
	{
		if (n < 0)
9d0038cc:	04a00011 	bltz	a1,9d003914 <_ZN5Print5printEli+0x84>
9d0038d0:	2405002d 	li	a1,45
		{
			print('-');
			n = -n;
		}
		printNumber(n, 10);
9d0038d4:	02202021 	move	a0,s1
9d0038d8:	02002821 	move	a1,s0
	}
	else
	{
		printNumber(n, base);
	}
}
9d0038dc:	8fbf001c 	lw	ra,28(sp)
9d0038e0:	8fb10018 	lw	s1,24(sp)
9d0038e4:	8fb00014 	lw	s0,20(sp)
		if (n < 0)
		{
			print('-');
			n = -n;
		}
		printNumber(n, 10);
9d0038e8:	2406000a 	li	a2,10
	}
	else
	{
		printNumber(n, base);
9d0038ec:	0b400ded 	j	9d0037b4 <_ZN5Print11printNumberEmh>
9d0038f0:	27bd0020 	addiu	sp,sp,32
//************************************************************************
void Print::print(long n, int base)
{
	if (base == 0)
	{
		write(n);
9d0038f4:	8c820000 	lw	v0,0(a0)
	}
	else
	{
		printNumber(n, base);
	}
}
9d0038f8:	8fbf001c 	lw	ra,28(sp)
9d0038fc:	8fb10018 	lw	s1,24(sp)
//************************************************************************
void Print::print(long n, int base)
{
	if (base == 0)
	{
		write(n);
9d003900:	8c590000 	lw	t9,0(v0)
	}
	else
	{
		printNumber(n, base);
	}
}
9d003904:	8fb00014 	lw	s0,20(sp)
//************************************************************************
void Print::print(long n, int base)
{
	if (base == 0)
	{
		write(n);
9d003908:	30a500ff 	andi	a1,a1,0xff
9d00390c:	03200008 	jr	t9
9d003910:	27bd0020 	addiu	sp,sp,32
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d003914:	0f400e24 	jal	9d003890 <_ZN5Print5printEli>
9d003918:	00003021 	move	a2,zero
	else if (base == 10)
	{
		if (n < 0)
		{
			print('-');
			n = -n;
9d00391c:	0b400e35 	j	9d0038d4 <_ZN5Print5printEli+0x44>
9d003920:	00108023 	negu	s0,s0

9d003924 <_ZN5Print7printlnEv>:
	printFloat(n, digits);
}

//************************************************************************
void Print::println(void)
{
9d003924:	27bdffe8 	addiu	sp,sp,-24
9d003928:	afb00010 	sw	s0,16(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d00392c:	2405000d 	li	a1,13
	printFloat(n, digits);
}

//************************************************************************
void Print::println(void)
{
9d003930:	00808021 	move	s0,a0
9d003934:	afbf0014 	sw	ra,20(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d003938:	0f400e24 	jal	9d003890 <_ZN5Print5printEli>
9d00393c:	00003021 	move	a2,zero
9d003940:	02002021 	move	a0,s0
//************************************************************************
void Print::println(void)
{
	print('\r');
	print('\n');
}
9d003944:	8fbf0014 	lw	ra,20(sp)
9d003948:	8fb00010 	lw	s0,16(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d00394c:	2405000a 	li	a1,10
9d003950:	00003021 	move	a2,zero
9d003954:	0b400e24 	j	9d003890 <_ZN5Print5printEli>
9d003958:	27bd0018 	addiu	sp,sp,24

9d00395c <_ZN5Print7printlnEPKc>:
	}
}
//************************************************************************
void Print::print(const char str[])
{
	write(str);
9d00395c:	8c820000 	lw	v0,0(a0)
	print(argString);
	println();
}
//************************************************************************
void Print::println(const char c[])
{
9d003960:	27bdffe8 	addiu	sp,sp,-24
9d003964:	afbf0014 	sw	ra,20(sp)
	}
}
//************************************************************************
void Print::print(const char str[])
{
	write(str);
9d003968:	8c420004 	lw	v0,4(v0)
	print(argString);
	println();
}
//************************************************************************
void Print::println(const char c[])
{
9d00396c:	afb00010 	sw	s0,16(sp)
	}
}
//************************************************************************
void Print::print(const char str[])
{
	write(str);
9d003970:	0040f809 	jalr	v0
9d003974:	00808021 	move	s0,a0
}
//************************************************************************
void Print::println(const char c[])
{
	print(c);
	println();
9d003978:	02002021 	move	a0,s0
}
9d00397c:	8fbf0014 	lw	ra,20(sp)
9d003980:	8fb00010 	lw	s0,16(sp)
}
//************************************************************************
void Print::println(const char c[])
{
	print(c);
	println();
9d003984:	0b400e49 	j	9d003924 <_ZN5Print7printlnEv>
9d003988:	27bd0018 	addiu	sp,sp,24

9d00398c <_ZN5Print10printFloatEdh>:
	}
}

//************************************************************************
void Print::printFloat(double number, uint8_t digits)
{
9d00398c:	27bdffc8 	addiu	sp,sp,-56
	// Handle negative numbers
	if (number < 0.0)
9d003990:	00c01021 	move	v0,a2
	}
}

//************************************************************************
void Print::printFloat(double number, uint8_t digits)
{
9d003994:	afb40028 	sw	s4,40(sp)
9d003998:	00e0a021 	move	s4,a3
9d00399c:	afb5002c 	sw	s5,44(sp)
9d0039a0:	afb1001c 	sw	s1,28(sp)
9d0039a4:	00c0a821 	move	s5,a2
9d0039a8:	00808821 	move	s1,a0
	// Handle negative numbers
	if (number < 0.0)
9d0039ac:	00003021 	move	a2,zero
9d0039b0:	00003821 	move	a3,zero
9d0039b4:	00402021 	move	a0,v0
9d0039b8:	02802821 	move	a1,s4
	}
}

//************************************************************************
void Print::printFloat(double number, uint8_t digits)
{
9d0039bc:	afb00018 	sw	s0,24(sp)
9d0039c0:	afbf0034 	sw	ra,52(sp)
9d0039c4:	afb60030 	sw	s6,48(sp)
9d0039c8:	afb30024 	sw	s3,36(sp)
9d0039cc:	afb20020 	sw	s2,32(sp)
	// Handle negative numbers
	if (number < 0.0)
9d0039d0:	0f40139d 	jal	9d004e74 <__ledf2>
9d0039d4:	93b00048 	lbu	s0,72(sp)
9d0039d8:	0440005a 	bltz	v0,9d003b44 <_ZN5Print10printFloatEdh+0x1b8>
9d0039dc:	02202021 	move	a0,s1
		 number = -number;
	}

	// Round correctly so that print(1.999, 2) prints as "2.00"
	double rounding = 0.5;
	for (uint8_t i=0; i<digits; ++i)
9d0039e0:	1200005e 	beqz	s0,9d003b5c <_ZN5Print10printFloatEdh+0x1d0>
9d0039e4:	3c039d00 	lui	v1,0x9d00
9d0039e8:	8c63683c 	lw	v1,26684(v1)
9d0039ec:	3c029d00 	lui	v0,0x9d00
		rounding /= 10.0;
9d0039f0:	8c526840 	lw	s2,26688(v0)
9d0039f4:	8c536844 	lw	s3,26692(v0)
		 number = -number;
	}

	// Round correctly so that print(1.999, 2) prints as "2.00"
	double rounding = 0.5;
	for (uint8_t i=0; i<digits; ++i)
9d0039f8:	0000b021 	move	s6,zero
9d0039fc:	00001021 	move	v0,zero
9d003a00:	26d60001 	addiu	s6,s6,1
		rounding /= 10.0;
9d003a04:	00402021 	move	a0,v0
9d003a08:	02403021 	move	a2,s2
9d003a0c:	00602821 	move	a1,v1
9d003a10:	02603821 	move	a3,s3
9d003a14:	0f40119c 	jal	9d004670 <__divdf3>
9d003a18:	32d600ff 	andi	s6,s6,0xff
		 number = -number;
	}

	// Round correctly so that print(1.999, 2) prints as "2.00"
	double rounding = 0.5;
	for (uint8_t i=0; i<digits; ++i)
9d003a1c:	02d0202b 	sltu	a0,s6,s0
9d003a20:	1480fff8 	bnez	a0,9d003a04 <_ZN5Print10printFloatEdh+0x78>
9d003a24:	26d60001 	addiu	s6,s6,1
		rounding /= 10.0;

	number += rounding;
9d003a28:	00403021 	move	a2,v0
9d003a2c:	00603821 	move	a3,v1
9d003a30:	02a02021 	move	a0,s5
9d003a34:	0f400f6b 	jal	9d003dac <__adddf3>
9d003a38:	02802821 	move	a1,s4

	// Extract the integer part of the number and print it
	unsigned long int_part = (unsigned long)number;
9d003a3c:	00602821 	move	a1,v1
9d003a40:	00402021 	move	a0,v0
	// Round correctly so that print(1.999, 2) prints as "2.00"
	double rounding = 0.5;
	for (uint8_t i=0; i<digits; ++i)
		rounding /= 10.0;

	number += rounding;
9d003a44:	0060a821 	move	s5,v1

	// Extract the integer part of the number and print it
	unsigned long int_part = (unsigned long)number;
9d003a48:	0f400efc 	jal	9d003bf0 <__fixunsdfsi>
9d003a4c:	0040b021 	move	s6,v0
	double remainder = number - (double)int_part;
9d003a50:	00402021 	move	a0,v0
9d003a54:	0f4017cf 	jal	9d005f3c <__floatunsidf>
9d003a58:	0040a021 	move	s4,v0
9d003a5c:	00603821 	move	a3,v1
9d003a60:	02c02021 	move	a0,s6
9d003a64:	02a02821 	move	a1,s5
9d003a68:	0f401541 	jal	9d005504 <__subdf3>
9d003a6c:	00403021 	move	a2,v0
	print(int_part);
9d003a70:	02802821 	move	a1,s4
9d003a74:	02202021 	move	a0,s1
9d003a78:	2406000a 	li	a2,10
9d003a7c:	afa20014 	sw	v0,20(sp)
9d003a80:	0f400e1b 	jal	9d00386c <_ZN5Print5printEmi>
9d003a84:	afa30010 	sw	v1,16(sp)
	}
}
//************************************************************************
void Print::print(const char str[])
{
	write(str);
9d003a88:	8e250000 	lw	a1,0(s1)
9d003a8c:	02202021 	move	a0,s1
		print(".");

	// Extract digits from the remainder one at a time
	while (digits-- > 0)
	{
		remainder *= 10.0;
9d003a90:	0240a021 	move	s4,s2
	}
}
//************************************************************************
void Print::print(const char str[])
{
	write(str);
9d003a94:	8ca60004 	lw	a2,4(a1)
9d003a98:	3c059d00 	lui	a1,0x9d00
9d003a9c:	00c0f809 	jalr	a2
9d003aa0:	24a56600 	addiu	a1,a1,26112
		print(".");

	// Extract digits from the remainder one at a time
	while (digits-- > 0)
	{
		remainder *= 10.0;
9d003aa4:	8fa30010 	lw	v1,16(sp)
9d003aa8:	8fa20014 	lw	v0,20(sp)
9d003aac:	02609021 	move	s2,s3
9d003ab0:	02403821 	move	a3,s2
9d003ab4:	02803021 	move	a2,s4
9d003ab8:	00402021 	move	a0,v0
9d003abc:	0f4013e6 	jal	9d004f98 <__muldf3>
9d003ac0:	00602821 	move	a1,v1
		int toPrint = int(remainder);
9d003ac4:	00602821 	move	a1,v1
9d003ac8:	00402021 	move	a0,v0
		print(".");

	// Extract digits from the remainder one at a time
	while (digits-- > 0)
	{
		remainder *= 10.0;
9d003acc:	00609821 	move	s3,v1
		int toPrint = int(remainder);
9d003ad0:	0f401783 	jal	9d005e0c <__fixdfsi>
9d003ad4:	0040a821 	move	s5,v0
}

//************************************************************************
void Print::print(int n, int base)
{
	print((long) n, base);
9d003ad8:	00402821 	move	a1,v0
9d003adc:	2406000a 	li	a2,10
9d003ae0:	02202021 	move	a0,s1
9d003ae4:	0f400e24 	jal	9d003890 <_ZN5Print5printEli>
9d003ae8:	afa20014 	sw	v0,20(sp)
	while (digits-- > 0)
	{
		remainder *= 10.0;
		int toPrint = int(remainder);
		print(toPrint);
		remainder -= toPrint;
9d003aec:	8fa20014 	lw	v0,20(sp)
9d003af0:	2610ffff 	addiu	s0,s0,-1
9d003af4:	321000ff 	andi	s0,s0,0xff
9d003af8:	0f4017a3 	jal	9d005e8c <__floatsidf>
9d003afc:	00402021 	move	a0,v0
9d003b00:	00403021 	move	a2,v0
9d003b04:	02a02021 	move	a0,s5
9d003b08:	02602821 	move	a1,s3
9d003b0c:	0f401541 	jal	9d005504 <__subdf3>
9d003b10:	00603821 	move	a3,v1
	// Print the decimal point, but only if there are digits beyond
	if (digits > 0)
		print(".");

	// Extract digits from the remainder one at a time
	while (digits-- > 0)
9d003b14:	5600ffe7 	bnezl	s0,9d003ab4 <_ZN5Print10printFloatEdh+0x128>
9d003b18:	02403821 	move	a3,s2
		remainder *= 10.0;
		int toPrint = int(remainder);
		print(toPrint);
		remainder -= toPrint;
	}
}
9d003b1c:	8fbf0034 	lw	ra,52(sp)
9d003b20:	8fb60030 	lw	s6,48(sp)
9d003b24:	8fb5002c 	lw	s5,44(sp)
9d003b28:	8fb40028 	lw	s4,40(sp)
9d003b2c:	8fb30024 	lw	s3,36(sp)
9d003b30:	8fb20020 	lw	s2,32(sp)
9d003b34:	8fb1001c 	lw	s1,28(sp)
9d003b38:	8fb00018 	lw	s0,24(sp)
9d003b3c:	03e00008 	jr	ra
9d003b40:	27bd0038 	addiu	sp,sp,56
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d003b44:	2405002d 	li	a1,45
9d003b48:	0f400e24 	jal	9d003890 <_ZN5Print5printEli>
9d003b4c:	00003021 	move	a2,zero
{
	// Handle negative numbers
	if (number < 0.0)
	{
		 print('-');
		 number = -number;
9d003b50:	3c028000 	lui	v0,0x8000
9d003b54:	0b400e78 	j	9d0039e0 <_ZN5Print10printFloatEdh+0x54>
9d003b58:	0282a026 	xor	s4,s4,v0
	// Round correctly so that print(1.999, 2) prints as "2.00"
	double rounding = 0.5;
	for (uint8_t i=0; i<digits; ++i)
		rounding /= 10.0;

	number += rounding;
9d003b5c:	3c029d00 	lui	v0,0x9d00
9d003b60:	8c466838 	lw	a2,26680(v0)
9d003b64:	8c47683c 	lw	a3,26684(v0)
9d003b68:	02a02021 	move	a0,s5
9d003b6c:	0f400f6b 	jal	9d003dac <__adddf3>
9d003b70:	02802821 	move	a1,s4

	// Extract the integer part of the number and print it
	unsigned long int_part = (unsigned long)number;
9d003b74:	00402021 	move	a0,v0
9d003b78:	0f400efc 	jal	9d003bf0 <__fixunsdfsi>
9d003b7c:	00602821 	move	a1,v1
	double remainder = number - (double)int_part;
	print(int_part);
9d003b80:	00402821 	move	a1,v0
9d003b84:	02202021 	move	a0,s1
		remainder *= 10.0;
		int toPrint = int(remainder);
		print(toPrint);
		remainder -= toPrint;
	}
}
9d003b88:	8fbf0034 	lw	ra,52(sp)
9d003b8c:	8fb60030 	lw	s6,48(sp)
9d003b90:	8fb5002c 	lw	s5,44(sp)
9d003b94:	8fb40028 	lw	s4,40(sp)
9d003b98:	8fb30024 	lw	s3,36(sp)
9d003b9c:	8fb20020 	lw	s2,32(sp)
9d003ba0:	8fb1001c 	lw	s1,28(sp)
9d003ba4:	8fb00018 	lw	s0,24(sp)
	number += rounding;

	// Extract the integer part of the number and print it
	unsigned long int_part = (unsigned long)number;
	double remainder = number - (double)int_part;
	print(int_part);
9d003ba8:	2406000a 	li	a2,10
9d003bac:	0b400e1b 	j	9d00386c <_ZN5Print5printEmi>
9d003bb0:	27bd0038 	addiu	sp,sp,56

9d003bb4 <_ZN5Print5printEdi>:
}

//************************************************************************
void Print::print(double n, int digits)
{
	printFloat(n, digits);
9d003bb4:	93a20010 	lbu	v0,16(sp)
9d003bb8:	0b400e63 	j	9d00398c <_ZN5Print10printFloatEdh>
9d003bbc:	afa20010 	sw	v0,16(sp)

9d003bc0 <main>:
__attribute__((section(".comment"))) void (*__use_force_isr_install)(void) = &__use_isr_install;
}

//************************************************************************
int main(void)
{
9d003bc0:	27bdffe8 	addiu	sp,sp,-24
9d003bc4:	afbf0014 	sw	ra,20(sp)
	init();
9d003bc8:	0f400a7c 	jal	9d0029f0 <init>
9d003bcc:	00000000 	nop

	setup();
9d003bd0:	0f4004ca 	jal	9d001328 <setup>
9d003bd4:	00000000 	nop

	while (1)
	{
		_scheduleTask();
9d003bd8:	0f400b72 	jal	9d002dc8 <_scheduleTask>
9d003bdc:	00000000 	nop
		loop();
9d003be0:	0f40072b 	jal	9d001cac <loop>
9d003be4:	00000000 	nop
9d003be8:	0b400ef6 	j	9d003bd8 <main+0x18>
9d003bec:	00000000 	nop

9d003bf0 <__fixunsdfsi>:
9d003bf0:	27bdffe0 	addiu	sp,sp,-32
9d003bf4:	afb00010 	sw	s0,16(sp)
9d003bf8:	3c109d00 	lui	s0,0x9d00
9d003bfc:	8e066848 	lw	a2,26696(s0)
9d003c00:	8e07684c 	lw	a3,26700(s0)
9d003c04:	afb30018 	sw	s3,24(sp)
9d003c08:	afb20014 	sw	s2,20(sp)
9d003c0c:	afbf001c 	sw	ra,28(sp)
9d003c10:	00809021 	move	s2,a0
9d003c14:	0f401354 	jal	9d004d50 <__gedf2>
9d003c18:	00a09821 	move	s3,a1
9d003c1c:	0441000a 	bgez	v0,9d003c48 <__fixunsdfsi+0x58>
9d003c20:	8e066848 	lw	a2,26696(s0)
9d003c24:	02402021 	move	a0,s2
9d003c28:	0f401783 	jal	9d005e0c <__fixdfsi>
9d003c2c:	02602821 	move	a1,s3
9d003c30:	8fbf001c 	lw	ra,28(sp)
9d003c34:	8fb30018 	lw	s3,24(sp)
9d003c38:	8fb20014 	lw	s2,20(sp)
9d003c3c:	8fb00010 	lw	s0,16(sp)
9d003c40:	03e00008 	jr	ra
9d003c44:	27bd0020 	addiu	sp,sp,32
9d003c48:	8e07684c 	lw	a3,26700(s0)
9d003c4c:	02402021 	move	a0,s2
9d003c50:	0f401541 	jal	9d005504 <__subdf3>
9d003c54:	02602821 	move	a1,s3
9d003c58:	00602821 	move	a1,v1
9d003c5c:	0f401783 	jal	9d005e0c <__fixdfsi>
9d003c60:	00402021 	move	a0,v0
9d003c64:	8fbf001c 	lw	ra,28(sp)
9d003c68:	3c038000 	lui	v1,0x8000
9d003c6c:	00431021 	addu	v0,v0,v1
9d003c70:	8fb30018 	lw	s3,24(sp)
9d003c74:	8fb20014 	lw	s2,20(sp)
9d003c78:	8fb00010 	lw	s0,16(sp)
9d003c7c:	03e00008 	jr	ra
9d003c80:	27bd0020 	addiu	sp,sp,32

9d003c84 <__floatunsisf>:
9d003c84:	10800039 	beqz	a0,9d003d6c <__floatunsisf+0xe8>
9d003c88:	2403009e 	li	v1,158
9d003c8c:	70821020 	clz	v0,a0
9d003c90:	00621023 	subu	v0,v1,v0
9d003c94:	28430097 	slti	v1,v0,151
9d003c98:	1060000b 	beqz	v1,9d003cc8 <__floatunsisf+0x44>
9d003c9c:	2843009a 	slti	v1,v0,154
9d003ca0:	24030096 	li	v1,150
9d003ca4:	00621823 	subu	v1,v1,v0
9d003ca8:	00642004 	sllv	a0,a0,v1
9d003cac:	7c84b000 	ext	a0,a0,0x0,0x17
9d003cb0:	304300ff 	andi	v1,v0,0xff
9d003cb4:	00001021 	move	v0,zero
9d003cb8:	7c82b004 	ins	v0,a0,0x0,0x17
9d003cbc:	7c62f5c4 	ins	v0,v1,0x17,0x8
9d003cc0:	03e00008 	jr	ra
9d003cc4:	7c42f000 	ext	v0,v0,0x0,0x1f
9d003cc8:	14600009 	bnez	v1,9d003cf0 <__floatunsisf+0x6c>
9d003ccc:	24030099 	li	v1,153
9d003cd0:	240300b9 	li	v1,185
9d003cd4:	00621823 	subu	v1,v1,v0
9d003cd8:	00641804 	sllv	v1,a0,v1
9d003cdc:	2445ff67 	addiu	a1,v0,-153
9d003ce0:	0003182b 	sltu	v1,zero,v1
9d003ce4:	00a42006 	srlv	a0,a0,a1
9d003ce8:	00642025 	or	a0,v1,a0
9d003cec:	24030099 	li	v1,153
9d003cf0:	00621823 	subu	v1,v1,v0
9d003cf4:	00642804 	sllv	a1,a0,v1
9d003cf8:	0003182a 	slt	v1,zero,v1
9d003cfc:	00a3200b 	movn	a0,a1,v1
9d003d00:	3c05fbff 	lui	a1,0xfbff
9d003d04:	34a5ffff 	ori	a1,a1,0xffff
9d003d08:	00851824 	and	v1,a0,a1
9d003d0c:	3084000f 	andi	a0,a0,0xf
9d003d10:	38840004 	xori	a0,a0,0x4
9d003d14:	24660004 	addiu	a2,v1,4
9d003d18:	00c4180b 	movn	v1,a2,a0
9d003d1c:	7c640680 	ext	a0,v1,0x1a,0x1
9d003d20:	50800007 	beqzl	a0,9d003d40 <__floatunsisf+0xbc>
9d003d24:	24450001 	addiu	a1,v0,1
9d003d28:	24420001 	addiu	v0,v0,1
9d003d2c:	240400ff 	li	a0,255
9d003d30:	5044001c 	beql	v0,a0,9d003da4 <__floatunsisf+0x120>
9d003d34:	240300ff 	li	v1,255
9d003d38:	00651824 	and	v1,v1,a1
9d003d3c:	24450001 	addiu	a1,v0,1
9d003d40:	30a500ff 	andi	a1,a1,0xff
9d003d44:	28a50002 	slti	a1,a1,2
9d003d48:	14a0000f 	bnez	a1,9d003d88 <__floatunsisf+0x104>
9d003d4c:	000320c2 	srl	a0,v1,0x3
9d003d50:	304300ff 	andi	v1,v0,0xff
9d003d54:	7c84b000 	ext	a0,a0,0x0,0x17
9d003d58:	00001021 	move	v0,zero
9d003d5c:	7c82b004 	ins	v0,a0,0x0,0x17
9d003d60:	7c62f5c4 	ins	v0,v1,0x17,0x8
9d003d64:	03e00008 	jr	ra
9d003d68:	7c42f000 	ext	v0,v0,0x0,0x1f
9d003d6c:	00002021 	move	a0,zero
9d003d70:	00001021 	move	v0,zero
9d003d74:	00001821 	move	v1,zero
9d003d78:	7c82b004 	ins	v0,a0,0x0,0x17
9d003d7c:	7c62f5c4 	ins	v0,v1,0x17,0x8
9d003d80:	03e00008 	jr	ra
9d003d84:	7c42f000 	ext	v0,v0,0x0,0x1f
9d003d88:	5080ffca 	beqzl	a0,9d003cb4 <__floatunsisf+0x30>
9d003d8c:	304300ff 	andi	v1,v0,0xff
9d003d90:	3c030040 	lui	v1,0x40
9d003d94:	00832025 	or	a0,a0,v1
9d003d98:	7c84b000 	ext	a0,a0,0x0,0x17
9d003d9c:	0b400f2d 	j	9d003cb4 <__floatunsisf+0x30>
9d003da0:	304300ff 	andi	v1,v0,0xff
9d003da4:	0b400f2d 	j	9d003cb4 <__floatunsisf+0x30>
9d003da8:	00002021 	move	a0,zero

9d003dac <__adddf3>:
9d003dac:	7cad07c0 	ext	t5,a1,0x1f,0x1
9d003db0:	7cab9800 	ext	t3,a1,0x0,0x14
9d003db4:	7cea9800 	ext	t2,a3,0x0,0x14
9d003db8:	00067742 	srl	t6,a2,0x1d
9d003dbc:	000b58c0 	sll	t3,t3,0x3
9d003dc0:	00047f42 	srl	t7,a0,0x1d
9d003dc4:	000a50c0 	sll	t2,t2,0x3
9d003dc8:	000767c2 	srl	t4,a3,0x1f
9d003dcc:	31a900ff 	andi	t1,t5,0xff
9d003dd0:	7ca55500 	ext	a1,a1,0x14,0xb
9d003dd4:	016f5825 	or	t3,t3,t7
9d003dd8:	000440c0 	sll	t0,a0,0x3
9d003ddc:	7ce75500 	ext	a3,a3,0x14,0xb
9d003de0:	014e5025 	or	t2,t2,t6
9d003de4:	112c006e 	beq	t1,t4,9d003fa0 <__adddf3+0x1f4>
9d003de8:	000630c0 	sll	a2,a2,0x3
9d003dec:	00a71823 	subu	v1,a1,a3
9d003df0:	186000bc 	blez	v1,9d0040e4 <__adddf3+0x338>
9d003df4:	00000000 	nop
9d003df8:	14e0000d 	bnez	a3,9d003e30 <__adddf3+0x84>
9d003dfc:	240207ff 	li	v0,2047
9d003e00:	01461025 	or	v0,t2,a2
9d003e04:	50400096 	beqzl	v0,9d004060 <__adddf3+0x2b4>
9d003e08:	24a30001 	addiu	v1,a1,1
9d003e0c:	2463ffff 	addiu	v1,v1,-1
9d003e10:	546000a6 	bnezl	v1,9d0040ac <__adddf3+0x300>
9d003e14:	240207ff 	li	v0,2047
9d003e18:	01062023 	subu	a0,t0,a2
9d003e1c:	016a1023 	subu	v0,t3,t2
9d003e20:	0104402b 	sltu	t0,t0,a0
9d003e24:	00481023 	subu	v0,v0,t0
9d003e28:	0b400fa4 	j	9d003e90 <__adddf3+0xe4>
9d003e2c:	00a03821 	move	a3,a1
9d003e30:	10a200a1 	beq	a1,v0,9d0040b8 <__adddf3+0x30c>
9d003e34:	310e000f 	andi	t6,t0,0xf
9d003e38:	3c020080 	lui	v0,0x80
9d003e3c:	01425025 	or	t2,t2,v0
9d003e40:	28620039 	slti	v0,v1,57
9d003e44:	104000c6 	beqz	v0,9d004160 <__adddf3+0x3b4>
9d003e48:	01462025 	or	a0,t2,a2
9d003e4c:	28620020 	slti	v0,v1,32
9d003e50:	104000e6 	beqz	v0,9d0041ec <__adddf3+0x440>
9d003e54:	24040020 	li	a0,32
9d003e58:	24020020 	li	v0,32
9d003e5c:	00431023 	subu	v0,v0,v1
9d003e60:	004a3804 	sllv	a3,t2,v0
9d003e64:	00662006 	srlv	a0,a2,v1
9d003e68:	00463004 	sllv	a2,a2,v0
9d003e6c:	00e42025 	or	a0,a3,a0
9d003e70:	0006302b 	sltu	a2,zero,a2
9d003e74:	00862025 	or	a0,a0,a2
9d003e78:	006a1006 	srlv	v0,t2,v1
9d003e7c:	01042023 	subu	a0,t0,a0
9d003e80:	01621023 	subu	v0,t3,v0
9d003e84:	0104402b 	sltu	t0,t0,a0
9d003e88:	00481023 	subu	v0,v0,t0
9d003e8c:	00a03821 	move	a3,a1
9d003e90:	7c4305c0 	ext	v1,v0,0x17,0x1
9d003e94:	10600090 	beqz	v1,9d0040d8 <__adddf3+0x32c>
9d003e98:	7c4db000 	ext	t5,v0,0x0,0x17
9d003e9c:	15a00003 	bnez	t5,9d003eac <__adddf3+0x100>
9d003ea0:	71a21020 	clz	v0,t5
9d003ea4:	70821020 	clz	v0,a0
9d003ea8:	24420020 	addiu	v0,v0,32
9d003eac:	2443fff8 	addiu	v1,v0,-8
9d003eb0:	28650020 	slti	a1,v1,32
9d003eb4:	10a000a7 	beqz	a1,9d004154 <__adddf3+0x3a8>
9d003eb8:	2442ffd8 	addiu	v0,v0,-40
9d003ebc:	00031023 	negu	v0,v1
9d003ec0:	00441006 	srlv	v0,a0,v0
9d003ec4:	006d6804 	sllv	t5,t5,v1
9d003ec8:	004d6825 	or	t5,v0,t5
9d003ecc:	00642004 	sllv	a0,a0,v1
9d003ed0:	0067102a 	slt	v0,v1,a3
9d003ed4:	1440007d 	bnez	v0,9d0040cc <__adddf3+0x320>
9d003ed8:	3c02ff7f 	lui	v0,0xff7f
9d003edc:	00673823 	subu	a3,v1,a3
9d003ee0:	24e70001 	addiu	a3,a3,1
9d003ee4:	28e20020 	slti	v0,a3,32
9d003ee8:	104000b3 	beqz	v0,9d0041b8 <__adddf3+0x40c>
9d003eec:	24030020 	li	v1,32
9d003ef0:	24020020 	li	v0,32
9d003ef4:	00471023 	subu	v0,v0,a3
9d003ef8:	00e41806 	srlv	v1,a0,a3
9d003efc:	00442004 	sllv	a0,a0,v0
9d003f00:	004d1004 	sllv	v0,t5,v0
9d003f04:	00621025 	or	v0,v1,v0
9d003f08:	0004202b 	sltu	a0,zero,a0
9d003f0c:	00442025 	or	a0,v0,a0
9d003f10:	00ed1006 	srlv	v0,t5,a3
9d003f14:	308e000f 	andi	t6,a0,0xf
9d003f18:	24030001 	li	v1,1
9d003f1c:	00003821 	move	a3,zero
9d003f20:	24050004 	li	a1,4
9d003f24:	11c50005 	beq	t6,a1,9d003f3c <__adddf3+0x190>
9d003f28:	00802821 	move	a1,a0
9d003f2c:	24850004 	addiu	a1,a0,4
9d003f30:	00a4202b 	sltu	a0,a1,a0
9d003f34:	00441021 	addu	v0,v0,a0
9d003f38:	24e30001 	addiu	v1,a3,1
9d003f3c:	7c4405c0 	ext	a0,v0,0x17,0x1
9d003f40:	50800009 	beqzl	a0,9d003f68 <__adddf3+0x1bc>
9d003f44:	306307ff 	andi	v1,v1,0x7ff
9d003f48:	240407ff 	li	a0,2047
9d003f4c:	10640078 	beq	v1,a0,9d004130 <__adddf3+0x384>
9d003f50:	3c04ff7f 	lui	a0,0xff7f
9d003f54:	3484ffff 	ori	a0,a0,0xffff
9d003f58:	00603821 	move	a3,v1
9d003f5c:	00441024 	and	v0,v0,a0
9d003f60:	24630001 	addiu	v1,v1,1
9d003f64:	306307ff 	andi	v1,v1,0x7ff
9d003f68:	00023740 	sll	a2,v0,0x1d
9d003f6c:	000528c2 	srl	a1,a1,0x3
9d003f70:	28630002 	slti	v1,v1,2
9d003f74:	00c53025 	or	a2,a2,a1
9d003f78:	14600031 	bnez	v1,9d004040 <__adddf3+0x294>
9d003f7c:	000210c2 	srl	v0,v0,0x3
9d003f80:	7c429800 	ext	v0,v0,0x0,0x14
9d003f84:	30e707ff 	andi	a3,a3,0x7ff
9d003f88:	00001821 	move	v1,zero
9d003f8c:	7c439804 	ins	v1,v0,0x0,0x14
9d003f90:	7ce3f504 	ins	v1,a3,0x14,0xb
9d003f94:	7d23ffc4 	ins	v1,t1,0x1f,0x1
9d003f98:	03e00008 	jr	ra
9d003f9c:	00c01021 	move	v0,a2
9d003fa0:	00a71023 	subu	v0,a1,a3
9d003fa4:	18400071 	blez	v0,9d00416c <__adddf3+0x3c0>
9d003fa8:	00000000 	nop
9d003fac:	10e00034 	beqz	a3,9d004080 <__adddf3+0x2d4>
9d003fb0:	01461825 	or	v1,t2,a2
9d003fb4:	240307ff 	li	v1,2047
9d003fb8:	10a3003f 	beq	a1,v1,9d0040b8 <__adddf3+0x30c>
9d003fbc:	310e000f 	andi	t6,t0,0xf
9d003fc0:	3c030080 	lui	v1,0x80
9d003fc4:	01435025 	or	t2,t2,v1
9d003fc8:	28430039 	slti	v1,v0,57
9d003fcc:	146000b5 	bnez	v1,9d0042a4 <__adddf3+0x4f8>
9d003fd0:	28430020 	slti	v1,v0,32
9d003fd4:	01462025 	or	a0,t2,a2
9d003fd8:	00001021 	move	v0,zero
9d003fdc:	0004202b 	sltu	a0,zero,a0
9d003fe0:	00882021 	addu	a0,a0,t0
9d003fe4:	004b1021 	addu	v0,v0,t3
9d003fe8:	0088402b 	sltu	t0,a0,t0
9d003fec:	00481021 	addu	v0,v0,t0
9d003ff0:	00a03821 	move	a3,a1
9d003ff4:	7c4305c0 	ext	v1,v0,0x17,0x1
9d003ff8:	10600038 	beqz	v1,9d0040dc <__adddf3+0x330>
9d003ffc:	24e30001 	addiu	v1,a3,1
9d004000:	24e70001 	addiu	a3,a3,1
9d004004:	240307ff 	li	v1,2047
9d004008:	50e300d7 	beql	a3,v1,9d004368 <__adddf3+0x5bc>
9d00400c:	31a90001 	andi	t1,t5,0x1
9d004010:	3c03ff7f 	lui	v1,0xff7f
9d004014:	3463ffff 	ori	v1,v1,0xffff
9d004018:	00431024 	and	v0,v0,v1
9d00401c:	30830001 	andi	v1,a0,0x1
9d004020:	00042042 	srl	a0,a0,0x1
9d004024:	00642025 	or	a0,v1,a0
9d004028:	00021fc0 	sll	v1,v0,0x1f
9d00402c:	00832025 	or	a0,a0,v1
9d004030:	00021042 	srl	v0,v0,0x1
9d004034:	24e30001 	addiu	v1,a3,1
9d004038:	0b400fc8 	j	9d003f20 <__adddf3+0x174>
9d00403c:	308e000f 	andi	t6,a0,0xf
9d004040:	00c21825 	or	v1,a2,v0
9d004044:	50600175 	beqzl	v1,9d00461c <__adddf3+0x870>
9d004048:	30e707ff 	andi	a3,a3,0x7ff
9d00404c:	50e0ffce 	beqzl	a3,9d003f88 <__adddf3+0x1dc>
9d004050:	7c429800 	ext	v0,v0,0x0,0x14
9d004054:	3c030008 	lui	v1,0x8
9d004058:	0b400fe0 	j	9d003f80 <__adddf3+0x1d4>
9d00405c:	00431025 	or	v0,v0,v1
9d004060:	00a03821 	move	a3,a1
9d004064:	310e000f 	andi	t6,t0,0xf
9d004068:	24050004 	li	a1,4
9d00406c:	01601021 	move	v0,t3
9d004070:	15c5ffae 	bne	t6,a1,9d003f2c <__adddf3+0x180>
9d004074:	01002021 	move	a0,t0
9d004078:	0b400fcf 	j	9d003f3c <__adddf3+0x190>
9d00407c:	00802821 	move	a1,a0
9d004080:	1060fff7 	beqz	v1,9d004060 <__adddf3+0x2b4>
9d004084:	24a30001 	addiu	v1,a1,1
9d004088:	2442ffff 	addiu	v0,v0,-1
9d00408c:	1440009a 	bnez	v0,9d0042f8 <__adddf3+0x54c>
9d004090:	240307ff 	li	v1,2047
9d004094:	00c82021 	addu	a0,a2,t0
9d004098:	014b1021 	addu	v0,t2,t3
9d00409c:	0088402b 	sltu	t0,a0,t0
9d0040a0:	00481021 	addu	v0,v0,t0
9d0040a4:	0b400ffd 	j	9d003ff4 <__adddf3+0x248>
9d0040a8:	00a03821 	move	a3,a1
9d0040ac:	54a2ff65 	bnel	a1,v0,9d003e44 <__adddf3+0x98>
9d0040b0:	28620039 	slti	v0,v1,57
9d0040b4:	310e000f 	andi	t6,t0,0xf
9d0040b8:	01601021 	move	v0,t3
9d0040bc:	01002021 	move	a0,t0
9d0040c0:	24030800 	li	v1,2048
9d0040c4:	0b400fc8 	j	9d003f20 <__adddf3+0x174>
9d0040c8:	240707ff 	li	a3,2047
9d0040cc:	3442ffff 	ori	v0,v0,0xffff
9d0040d0:	00e33823 	subu	a3,a3,v1
9d0040d4:	01a21024 	and	v0,t5,v0
9d0040d8:	24e30001 	addiu	v1,a3,1
9d0040dc:	0b400fc8 	j	9d003f20 <__adddf3+0x174>
9d0040e0:	308e000f 	andi	t6,a0,0xf
9d0040e4:	1460004b 	bnez	v1,9d004214 <__adddf3+0x468>
9d0040e8:	24a20001 	addiu	v0,a1,1
9d0040ec:	304207ff 	andi	v0,v0,0x7ff
9d0040f0:	28420002 	slti	v0,v0,2
9d0040f4:	1440008e 	bnez	v0,9d004330 <__adddf3+0x584>
9d0040f8:	01062023 	subu	a0,t0,a2
9d0040fc:	0104102b 	sltu	v0,t0,a0
9d004100:	016a6823 	subu	t5,t3,t2
9d004104:	01a26823 	subu	t5,t5,v0
9d004108:	7da205c0 	ext	v0,t5,0x17,0x1
9d00410c:	1040005d 	beqz	v0,9d004284 <__adddf3+0x4d8>
9d004110:	01a41025 	or	v0,t5,a0
9d004114:	00c82023 	subu	a0,a2,t0
9d004118:	014b5023 	subu	t2,t2,t3
9d00411c:	00c4302b 	sltu	a2,a2,a0
9d004120:	01466823 	subu	t5,t2,a2
9d004124:	00a03821 	move	a3,a1
9d004128:	0b400fa7 	j	9d003e9c <__adddf3+0xf0>
9d00412c:	01804821 	move	t1,t4
9d004130:	00001021 	move	v0,zero
9d004134:	00001821 	move	v1,zero
9d004138:	240707ff 	li	a3,2047
9d00413c:	7c439804 	ins	v1,v0,0x0,0x14
9d004140:	00003021 	move	a2,zero
9d004144:	7ce3f504 	ins	v1,a3,0x14,0xb
9d004148:	7d23ffc4 	ins	v1,t1,0x1f,0x1
9d00414c:	03e00008 	jr	ra
9d004150:	00c01021 	move	v0,a2
9d004154:	00446804 	sllv	t5,a0,v0
9d004158:	0b400fb4 	j	9d003ed0 <__adddf3+0x124>
9d00415c:	00002021 	move	a0,zero
9d004160:	00001021 	move	v0,zero
9d004164:	0b400f9f 	j	9d003e7c <__adddf3+0xd0>
9d004168:	0004202b 	sltu	a0,zero,a0
9d00416c:	1440008c 	bnez	v0,9d0043a0 <__adddf3+0x5f4>
9d004170:	00000000 	nop
9d004174:	24a70001 	addiu	a3,a1,1
9d004178:	30e207ff 	andi	v0,a3,0x7ff
9d00417c:	28420002 	slti	v0,v0,2
9d004180:	14400061 	bnez	v0,9d004308 <__adddf3+0x55c>
9d004184:	240207ff 	li	v0,2047
9d004188:	10e20076 	beq	a3,v0,9d004364 <__adddf3+0x5b8>
9d00418c:	00c83021 	addu	a2,a2,t0
9d004190:	00c8402b 	sltu	t0,a2,t0
9d004194:	014b1021 	addu	v0,t2,t3
9d004198:	00481021 	addu	v0,v0,t0
9d00419c:	00021fc0 	sll	v1,v0,0x1f
9d0041a0:	00063042 	srl	a2,a2,0x1
9d0041a4:	00c32025 	or	a0,a2,v1
9d0041a8:	00021042 	srl	v0,v0,0x1
9d0041ac:	24a30002 	addiu	v1,a1,2
9d0041b0:	0b400fc8 	j	9d003f20 <__adddf3+0x174>
9d0041b4:	308e000f 	andi	t6,a0,0xf
9d0041b8:	00ed2806 	srlv	a1,t5,a3
9d0041bc:	10e30003 	beq	a3,v1,9d0041cc <__adddf3+0x420>
9d0041c0:	00001021 	move	v0,zero
9d0041c4:	00071023 	negu	v0,a3
9d0041c8:	004d1004 	sllv	v0,t5,v0
9d0041cc:	00442025 	or	a0,v0,a0
9d0041d0:	0004202b 	sltu	a0,zero,a0
9d0041d4:	00852025 	or	a0,a0,a1
9d0041d8:	308e000f 	andi	t6,a0,0xf
9d0041dc:	24030001 	li	v1,1
9d0041e0:	00001021 	move	v0,zero
9d0041e4:	0b400fc8 	j	9d003f20 <__adddf3+0x174>
9d0041e8:	00003821 	move	a3,zero
9d0041ec:	006a3806 	srlv	a3,t2,v1
9d0041f0:	10640003 	beq	v1,a0,9d004200 <__adddf3+0x454>
9d0041f4:	00001021 	move	v0,zero
9d0041f8:	00031823 	negu	v1,v1
9d0041fc:	006a1004 	sllv	v0,t2,v1
9d004200:	00462025 	or	a0,v0,a2
9d004204:	0004202b 	sltu	a0,zero,a0
9d004208:	00872025 	or	a0,a0,a3
9d00420c:	0b400f9f 	j	9d003e7c <__adddf3+0xd0>
9d004210:	00001021 	move	v0,zero
9d004214:	10a0002f 	beqz	a1,9d0042d4 <__adddf3+0x528>
9d004218:	00031823 	negu	v1,v1
9d00421c:	240207ff 	li	v0,2047
9d004220:	10e20078 	beq	a3,v0,9d004404 <__adddf3+0x658>
9d004224:	30ce000f 	andi	t6,a2,0xf
9d004228:	3c020080 	lui	v0,0x80
9d00422c:	01625825 	or	t3,t3,v0
9d004230:	28620039 	slti	v0,v1,57
9d004234:	10400094 	beqz	v0,9d004488 <__adddf3+0x6dc>
9d004238:	01682025 	or	a0,t3,t0
9d00423c:	28620020 	slti	v0,v1,32
9d004240:	504000cc 	beqzl	v0,9d004574 <__adddf3+0x7c8>
9d004244:	24040020 	li	a0,32
9d004248:	24020020 	li	v0,32
9d00424c:	00431023 	subu	v0,v0,v1
9d004250:	004b2804 	sllv	a1,t3,v0
9d004254:	00682006 	srlv	a0,t0,v1
9d004258:	00481004 	sllv	v0,t0,v0
9d00425c:	0002102b 	sltu	v0,zero,v0
9d004260:	00a42025 	or	a0,a1,a0
9d004264:	00822025 	or	a0,a0,v0
9d004268:	006b1006 	srlv	v0,t3,v1
9d00426c:	00c42023 	subu	a0,a2,a0
9d004270:	01421023 	subu	v0,t2,v0
9d004274:	00c4302b 	sltu	a2,a2,a0
9d004278:	00461023 	subu	v0,v0,a2
9d00427c:	0b400fa4 	j	9d003e90 <__adddf3+0xe4>
9d004280:	01804821 	move	t1,t4
9d004284:	1440ff05 	bnez	v0,9d003e9c <__adddf3+0xf0>
9d004288:	00a03821 	move	a3,a1
9d00428c:	00004821 	move	t1,zero
9d004290:	24030001 	li	v1,1
9d004294:	00001021 	move	v0,zero
9d004298:	24050004 	li	a1,4
9d00429c:	0b400fcf 	j	9d003f3c <__adddf3+0x190>
9d0042a0:	00003821 	move	a3,zero
9d0042a4:	50600034 	beqzl	v1,9d004378 <__adddf3+0x5cc>
9d0042a8:	24040020 	li	a0,32
9d0042ac:	24030020 	li	v1,32
9d0042b0:	00621823 	subu	v1,v1,v0
9d0042b4:	006a3804 	sllv	a3,t2,v1
9d0042b8:	00462006 	srlv	a0,a2,v0
9d0042bc:	00661804 	sllv	v1,a2,v1
9d0042c0:	00e42025 	or	a0,a3,a0
9d0042c4:	0003182b 	sltu	v1,zero,v1
9d0042c8:	00832025 	or	a0,a0,v1
9d0042cc:	0b400ff8 	j	9d003fe0 <__adddf3+0x234>
9d0042d0:	004a1006 	srlv	v0,t2,v0
9d0042d4:	01681025 	or	v0,t3,t0
9d0042d8:	54400063 	bnezl	v0,9d004468 <__adddf3+0x6bc>
9d0042dc:	2463ffff 	addiu	v1,v1,-1
9d0042e0:	24e30001 	addiu	v1,a3,1
9d0042e4:	30ce000f 	andi	t6,a2,0xf
9d0042e8:	01401021 	move	v0,t2
9d0042ec:	00c02021 	move	a0,a2
9d0042f0:	0b400fc8 	j	9d003f20 <__adddf3+0x174>
9d0042f4:	01804821 	move	t1,t4
9d0042f8:	54a3ff34 	bnel	a1,v1,9d003fcc <__adddf3+0x220>
9d0042fc:	28430039 	slti	v1,v0,57
9d004300:	0b40102e 	j	9d0040b8 <__adddf3+0x30c>
9d004304:	310e000f 	andi	t6,t0,0xf
9d004308:	14a0008d 	bnez	a1,9d004540 <__adddf3+0x794>
9d00430c:	01681025 	or	v0,t3,t0
9d004310:	544000ac 	bnezl	v0,9d0045c4 <__adddf3+0x818>
9d004314:	01461025 	or	v0,t2,a2
9d004318:	30ce000f 	andi	t6,a2,0xf
9d00431c:	01401021 	move	v0,t2
9d004320:	00c02021 	move	a0,a2
9d004324:	24030001 	li	v1,1
9d004328:	0b400fc8 	j	9d003f20 <__adddf3+0x174>
9d00432c:	00003821 	move	a3,zero
9d004330:	14a00025 	bnez	a1,9d0043c8 <__adddf3+0x61c>
9d004334:	01681025 	or	v0,t3,t0
9d004338:	1440006f 	bnez	v0,9d0044f8 <__adddf3+0x74c>
9d00433c:	01461025 	or	v0,t2,a2
9d004340:	5040ffd3 	beqzl	v0,9d004290 <__adddf3+0x4e4>
9d004344:	00004821 	move	t1,zero
9d004348:	30ce000f 	andi	t6,a2,0xf
9d00434c:	01401021 	move	v0,t2
9d004350:	00c02021 	move	a0,a2
9d004354:	01804821 	move	t1,t4
9d004358:	24030001 	li	v1,1
9d00435c:	0b400fc8 	j	9d003f20 <__adddf3+0x174>
9d004360:	00003821 	move	a3,zero
9d004364:	31a90001 	andi	t1,t5,0x1
9d004368:	24030800 	li	v1,2048
9d00436c:	00001021 	move	v0,zero
9d004370:	0b400fcf 	j	9d003f3c <__adddf3+0x190>
9d004374:	24050004 	li	a1,4
9d004378:	004a3806 	srlv	a3,t2,v0
9d00437c:	10440003 	beq	v0,a0,9d00438c <__adddf3+0x5e0>
9d004380:	00001821 	move	v1,zero
9d004384:	00021023 	negu	v0,v0
9d004388:	004a1804 	sllv	v1,t2,v0
9d00438c:	00662025 	or	a0,v1,a2
9d004390:	0004202b 	sltu	a0,zero,a0
9d004394:	00872025 	or	a0,a0,a3
9d004398:	0b400ff8 	j	9d003fe0 <__adddf3+0x234>
9d00439c:	00001021 	move	v0,zero
9d0043a0:	14a0003c 	bnez	a1,9d004494 <__adddf3+0x6e8>
9d0043a4:	00021023 	negu	v0,v0
9d0043a8:	01681825 	or	v1,t3,t0
9d0043ac:	5460007b 	bnezl	v1,9d00459c <__adddf3+0x7f0>
9d0043b0:	2442ffff 	addiu	v0,v0,-1
9d0043b4:	24e30001 	addiu	v1,a3,1
9d0043b8:	30ce000f 	andi	t6,a2,0xf
9d0043bc:	01401021 	move	v0,t2
9d0043c0:	0b400fc8 	j	9d003f20 <__adddf3+0x174>
9d0043c4:	00c02021 	move	a0,a2
9d0043c8:	54400014 	bnezl	v0,9d00441c <__adddf3+0x670>
9d0043cc:	01463025 	or	a2,t2,a2
9d0043d0:	01461025 	or	v0,t2,a2
9d0043d4:	1440000b 	bnez	v0,9d004404 <__adddf3+0x658>
9d0043d8:	30ce000f 	andi	t6,a2,0xf
9d0043dc:	3c02007f 	lui	v0,0x7f
9d0043e0:	00004821 	move	t1,zero
9d0043e4:	24030800 	li	v1,2048
9d0043e8:	3442ffff 	ori	v0,v0,0xffff
9d0043ec:	2405fffc 	li	a1,-4
9d0043f0:	0b400fcf 	j	9d003f3c <__adddf3+0x190>
9d0043f4:	240707ff 	li	a3,2047
9d0043f8:	54e2ff8e 	bnel	a3,v0,9d004234 <__adddf3+0x488>
9d0043fc:	28620039 	slti	v0,v1,57
9d004400:	30ce000f 	andi	t6,a2,0xf
9d004404:	01401021 	move	v0,t2
9d004408:	00c02021 	move	a0,a2
9d00440c:	01804821 	move	t1,t4
9d004410:	24030800 	li	v1,2048
9d004414:	0b400fc8 	j	9d003f20 <__adddf3+0x174>
9d004418:	240707ff 	li	a3,2047
9d00441c:	10c0ff26 	beqz	a2,9d0040b8 <__adddf3+0x30c>
9d004420:	310e000f 	andi	t6,t0,0xf
9d004424:	000b18c2 	srl	v1,t3,0x3
9d004428:	000a10c2 	srl	v0,t2,0x3
9d00442c:	00431025 	or	v0,v0,v1
9d004430:	7c4204c0 	ext	v0,v0,0x13,0x1
9d004434:	54400072 	bnezl	v0,9d004600 <__adddf3+0x854>
9d004438:	3c02007f 	lui	v0,0x7f
9d00443c:	000840c2 	srl	t0,t0,0x3
9d004440:	000b2740 	sll	a0,t3,0x1d
9d004444:	00882025 	or	a0,a0,t0
9d004448:	00041742 	srl	v0,a0,0x1d
9d00444c:	000318c0 	sll	v1,v1,0x3
9d004450:	000420c0 	sll	a0,a0,0x3
9d004454:	00431025 	or	v0,v0,v1
9d004458:	308e000f 	andi	t6,a0,0xf
9d00445c:	24030800 	li	v1,2048
9d004460:	0b400fc8 	j	9d003f20 <__adddf3+0x174>
9d004464:	240707ff 	li	a3,2047
9d004468:	5460ffe3 	bnezl	v1,9d0043f8 <__adddf3+0x64c>
9d00446c:	240207ff 	li	v0,2047
9d004470:	00c82023 	subu	a0,a2,t0
9d004474:	014b1023 	subu	v0,t2,t3
9d004478:	00c4302b 	sltu	a2,a2,a0
9d00447c:	00461023 	subu	v0,v0,a2
9d004480:	0b400fa4 	j	9d003e90 <__adddf3+0xe4>
9d004484:	01804821 	move	t1,t4
9d004488:	00001021 	move	v0,zero
9d00448c:	0b40109b 	j	9d00426c <__adddf3+0x4c0>
9d004490:	0004202b 	sltu	a0,zero,a0
9d004494:	240307ff 	li	v1,2047
9d004498:	10e3002c 	beq	a3,v1,9d00454c <__adddf3+0x7a0>
9d00449c:	30ce000f 	andi	t6,a2,0xf
9d0044a0:	3c030080 	lui	v1,0x80
9d0044a4:	01635825 	or	t3,t3,v1
9d0044a8:	28430039 	slti	v1,v0,57
9d0044ac:	10600042 	beqz	v1,9d0045b8 <__adddf3+0x80c>
9d0044b0:	01682025 	or	a0,t3,t0
9d0044b4:	28430020 	slti	v1,v0,32
9d0044b8:	50600063 	beqzl	v1,9d004648 <__adddf3+0x89c>
9d0044bc:	24040020 	li	a0,32
9d0044c0:	24030020 	li	v1,32
9d0044c4:	00621823 	subu	v1,v1,v0
9d0044c8:	006b2804 	sllv	a1,t3,v1
9d0044cc:	00482006 	srlv	a0,t0,v0
9d0044d0:	00681804 	sllv	v1,t0,v1
9d0044d4:	00a42025 	or	a0,a1,a0
9d0044d8:	0003182b 	sltu	v1,zero,v1
9d0044dc:	00832025 	or	a0,a0,v1
9d0044e0:	004b1006 	srlv	v0,t3,v0
9d0044e4:	00862021 	addu	a0,a0,a2
9d0044e8:	004a1021 	addu	v0,v0,t2
9d0044ec:	0086302b 	sltu	a2,a0,a2
9d0044f0:	0b400ffd 	j	9d003ff4 <__adddf3+0x248>
9d0044f4:	00461021 	addu	v0,v0,a2
9d0044f8:	10400019 	beqz	v0,9d004560 <__adddf3+0x7b4>
9d0044fc:	310e000f 	andi	t6,t0,0xf
9d004500:	01062023 	subu	a0,t0,a2
9d004504:	016a1823 	subu	v1,t3,t2
9d004508:	0104102b 	sltu	v0,t0,a0
9d00450c:	00621023 	subu	v0,v1,v0
9d004510:	7c4305c0 	ext	v1,v0,0x17,0x1
9d004514:	50600048 	beqzl	v1,9d004638 <__adddf3+0x88c>
9d004518:	00441825 	or	v1,v0,a0
9d00451c:	00c82023 	subu	a0,a2,t0
9d004520:	014b1023 	subu	v0,t2,t3
9d004524:	00c4302b 	sltu	a2,a2,a0
9d004528:	00461023 	subu	v0,v0,a2
9d00452c:	308e000f 	andi	t6,a0,0xf
9d004530:	01804821 	move	t1,t4
9d004534:	24030001 	li	v1,1
9d004538:	0b400fc8 	j	9d003f20 <__adddf3+0x174>
9d00453c:	00003821 	move	a3,zero
9d004540:	5440ffb6 	bnezl	v0,9d00441c <__adddf3+0x670>
9d004544:	01463025 	or	a2,t2,a2
9d004548:	30ce000f 	andi	t6,a2,0xf
9d00454c:	01401021 	move	v0,t2
9d004550:	00c02021 	move	a0,a2
9d004554:	24030800 	li	v1,2048
9d004558:	0b400fc8 	j	9d003f20 <__adddf3+0x174>
9d00455c:	240707ff 	li	a3,2047
9d004560:	01601021 	move	v0,t3
9d004564:	01002021 	move	a0,t0
9d004568:	24030001 	li	v1,1
9d00456c:	0b400fc8 	j	9d003f20 <__adddf3+0x174>
9d004570:	00003821 	move	a3,zero
9d004574:	006b2806 	srlv	a1,t3,v1
9d004578:	10640003 	beq	v1,a0,9d004588 <__adddf3+0x7dc>
9d00457c:	00001021 	move	v0,zero
9d004580:	00031823 	negu	v1,v1
9d004584:	006b1004 	sllv	v0,t3,v1
9d004588:	00482025 	or	a0,v0,t0
9d00458c:	0004202b 	sltu	a0,zero,a0
9d004590:	00852025 	or	a0,a0,a1
9d004594:	0b40109b 	j	9d00426c <__adddf3+0x4c0>
9d004598:	00001021 	move	v0,zero
9d00459c:	14400022 	bnez	v0,9d004628 <__adddf3+0x87c>
9d0045a0:	240307ff 	li	v1,2047
9d0045a4:	00c82021 	addu	a0,a2,t0
9d0045a8:	014b1021 	addu	v0,t2,t3
9d0045ac:	0086302b 	sltu	a2,a0,a2
9d0045b0:	0b400ffd 	j	9d003ff4 <__adddf3+0x248>
9d0045b4:	00461021 	addu	v0,v0,a2
9d0045b8:	00001021 	move	v0,zero
9d0045bc:	0b401139 	j	9d0044e4 <__adddf3+0x738>
9d0045c0:	0004202b 	sltu	a0,zero,a0
9d0045c4:	1040ffe6 	beqz	v0,9d004560 <__adddf3+0x7b4>
9d0045c8:	310e000f 	andi	t6,t0,0xf
9d0045cc:	00c82021 	addu	a0,a2,t0
9d0045d0:	014b1021 	addu	v0,t2,t3
9d0045d4:	0088402b 	sltu	t0,a0,t0
9d0045d8:	00481021 	addu	v0,v0,t0
9d0045dc:	7c4305c0 	ext	v1,v0,0x17,0x1
9d0045e0:	1060fe4d 	beqz	v1,9d003f18 <__adddf3+0x16c>
9d0045e4:	308e000f 	andi	t6,a0,0xf
9d0045e8:	3c03ff7f 	lui	v1,0xff7f
9d0045ec:	3463ffff 	ori	v1,v1,0xffff
9d0045f0:	00431024 	and	v0,v0,v1
9d0045f4:	24030002 	li	v1,2
9d0045f8:	0b400fc8 	j	9d003f20 <__adddf3+0x174>
9d0045fc:	24070001 	li	a3,1
9d004600:	240e0008 	li	t6,8
9d004604:	2404fff8 	li	a0,-8
9d004608:	3442ffff 	ori	v0,v0,0xffff
9d00460c:	00004821 	move	t1,zero
9d004610:	24030800 	li	v1,2048
9d004614:	0b400fc8 	j	9d003f20 <__adddf3+0x174>
9d004618:	240707ff 	li	a3,2047
9d00461c:	00001021 	move	v0,zero
9d004620:	0b400fe2 	j	9d003f88 <__adddf3+0x1dc>
9d004624:	00003021 	move	a2,zero
9d004628:	54e3ffa0 	bnel	a3,v1,9d0044ac <__adddf3+0x700>
9d00462c:	28430039 	slti	v1,v0,57
9d004630:	0b401153 	j	9d00454c <__adddf3+0x7a0>
9d004634:	30ce000f 	andi	t6,a2,0xf
9d004638:	5060ff15 	beqzl	v1,9d004290 <__adddf3+0x4e4>
9d00463c:	00004821 	move	t1,zero
9d004640:	0b400fc6 	j	9d003f18 <__adddf3+0x16c>
9d004644:	308e000f 	andi	t6,a0,0xf
9d004648:	004b2806 	srlv	a1,t3,v0
9d00464c:	10440003 	beq	v0,a0,9d00465c <__adddf3+0x8b0>
9d004650:	00001821 	move	v1,zero
9d004654:	00021023 	negu	v0,v0
9d004658:	004b1804 	sllv	v1,t3,v0
9d00465c:	00682025 	or	a0,v1,t0
9d004660:	0004202b 	sltu	a0,zero,a0
9d004664:	00852025 	or	a0,a0,a1
9d004668:	0b401139 	j	9d0044e4 <__adddf3+0x738>
9d00466c:	00001021 	move	v0,zero

9d004670 <__divdf3>:
9d004670:	7ca807c0 	ext	t0,a1,0x1f,0x1
9d004674:	7ca35500 	ext	v1,a1,0x14,0xb
9d004678:	310d00ff 	andi	t5,t0,0xff
9d00467c:	1460002e 	bnez	v1,9d004738 <__divdf3+0xc8>
9d004680:	7ca59800 	ext	a1,a1,0x0,0x14
9d004684:	00a44825 	or	t1,a1,a0
9d004688:	1120006c 	beqz	t1,9d00483c <__divdf3+0x1cc>
9d00468c:	240c0004 	li	t4,4
9d004690:	14a00003 	bnez	a1,9d0046a0 <__divdf3+0x30>
9d004694:	70a94820 	clz	t1,a1
9d004698:	70894820 	clz	t1,a0
9d00469c:	25290020 	addiu	t1,t1,32
9d0046a0:	2523fff5 	addiu	v1,t1,-11
9d0046a4:	286a001d 	slti	t2,v1,29
9d0046a8:	514000bb 	beqzl	t2,9d004998 <__divdf3+0x328>
9d0046ac:	2525ffd8 	addiu	a1,t1,-40
9d0046b0:	240a001d 	li	t2,29
9d0046b4:	2529fff8 	addiu	t1,t1,-8
9d0046b8:	01435023 	subu	t2,t2,v1
9d0046bc:	01445006 	srlv	t2,a0,t2
9d0046c0:	01252804 	sllv	a1,a1,t1
9d0046c4:	01452825 	or	a1,t2,a1
9d0046c8:	01242004 	sllv	a0,a0,t1
9d0046cc:	2409fc02 	li	t1,-1022
9d0046d0:	7cea5500 	ext	t2,a3,0x14,0xb
9d0046d4:	01231823 	subu	v1,t1,v1
9d0046d8:	00006021 	move	t4,zero
9d0046dc:	7ce99800 	ext	t1,a3,0x0,0x14
9d0046e0:	00007821 	move	t7,zero
9d0046e4:	11400023 	beqz	t2,9d004774 <__divdf3+0x104>
9d0046e8:	00073fc2 	srl	a3,a3,0x1f
9d0046ec:	240b07ff 	li	t3,2047
9d0046f0:	514b0049 	beql	t2,t3,9d004818 <__divdf3+0x1a8>
9d0046f4:	01267025 	or	t6,t1,a2
9d0046f8:	3c0b0010 	lui	t3,0x10
9d0046fc:	012b4825 	or	t1,t1,t3
9d004700:	000948c0 	sll	t1,t1,0x3
9d004704:	00065f42 	srl	t3,a2,0x1d
9d004708:	012b4825 	or	t1,t1,t3
9d00470c:	000630c0 	sll	a2,a2,0x3
9d004710:	254afc01 	addiu	t2,t2,-1023
9d004714:	00005821 	move	t3,zero
9d004718:	016c6025 	or	t4,t3,t4
9d00471c:	3c0e9d00 	lui	t6,0x9d00
9d004720:	25ce6850 	addiu	t6,t6,26704
9d004724:	000c6080 	sll	t4,t4,0x2
9d004728:	01cc6021 	addu	t4,t6,t4
9d00472c:	8d8c0000 	lw	t4,0(t4)
9d004730:	01800008 	jr	t4
9d004734:	00ed7026 	xor	t6,a3,t5
9d004738:	240907ff 	li	t1,2047
9d00473c:	10690023 	beq	v1,t1,9d0047cc <__divdf3+0x15c>
9d004740:	3c090010 	lui	t1,0x10
9d004744:	00a92825 	or	a1,a1,t1
9d004748:	000528c0 	sll	a1,a1,0x3
9d00474c:	00044f42 	srl	t1,a0,0x1d
9d004750:	00a92825 	or	a1,a1,t1
9d004754:	000420c0 	sll	a0,a0,0x3
9d004758:	2463fc01 	addiu	v1,v1,-1023
9d00475c:	00006021 	move	t4,zero
9d004760:	00007821 	move	t7,zero
9d004764:	7cea5500 	ext	t2,a3,0x14,0xb
9d004768:	7ce99800 	ext	t1,a3,0x0,0x14
9d00476c:	1540ffdf 	bnez	t2,9d0046ec <__divdf3+0x7c>
9d004770:	00073fc2 	srl	a3,a3,0x1f
9d004774:	01265825 	or	t3,t1,a2
9d004778:	5160002d 	beqzl	t3,9d004830 <__divdf3+0x1c0>
9d00477c:	00004821 	move	t1,zero
9d004780:	15200003 	bnez	t1,9d004790 <__divdf3+0x120>
9d004784:	712b5820 	clz	t3,t1
9d004788:	70cb5820 	clz	t3,a2
9d00478c:	256b0020 	addiu	t3,t3,32
9d004790:	256afff5 	addiu	t2,t3,-11
9d004794:	294e001d 	slti	t6,t2,29
9d004798:	51c0007c 	beqzl	t6,9d00498c <__divdf3+0x31c>
9d00479c:	2569ffd8 	addiu	t1,t3,-40
9d0047a0:	240e001d 	li	t6,29
9d0047a4:	256bfff8 	addiu	t3,t3,-8
9d0047a8:	01ca7023 	subu	t6,t6,t2
9d0047ac:	01c67006 	srlv	t6,a2,t6
9d0047b0:	01694804 	sllv	t1,t1,t3
9d0047b4:	01c94825 	or	t1,t6,t1
9d0047b8:	01663004 	sllv	a2,a2,t3
9d0047bc:	240bfc02 	li	t3,-1022
9d0047c0:	016a5023 	subu	t2,t3,t2
9d0047c4:	0b4011c6 	j	9d004718 <__divdf3+0xa8>
9d0047c8:	00005821 	move	t3,zero
9d0047cc:	00a44825 	or	t1,a1,a0
9d0047d0:	240a000c 	li	t2,12
9d0047d4:	240c0008 	li	t4,8
9d0047d8:	240f0002 	li	t7,2
9d0047dc:	0149600b 	movn	t4,t2,t1
9d0047e0:	240a0003 	li	t2,3
9d0047e4:	0009280a 	movz	a1,zero,t1
9d0047e8:	0009200a 	movz	a0,zero,t1
9d0047ec:	0b4011d9 	j	9d004764 <__divdf3+0xf4>
9d0047f0:	0149780b 	movn	t7,t2,t1
9d0047f4:	240207ff 	li	v0,2047
9d0047f8:	00002821 	move	a1,zero
9d0047fc:	00002021 	move	a0,zero
9d004800:	00001821 	move	v1,zero
9d004804:	7ca39804 	ins	v1,a1,0x0,0x14
9d004808:	7c43f504 	ins	v1,v0,0x14,0xb
9d00480c:	7dc3ffc4 	ins	v1,t6,0x1f,0x1
9d004810:	03e00008 	jr	ra
9d004814:	00801021 	move	v0,a0
9d004818:	240b0002 	li	t3,2
9d00481c:	24180003 	li	t8,3
9d004820:	000e480a 	movz	t1,zero,t6
9d004824:	000e300a 	movz	a2,zero,t6
9d004828:	0b4011c6 	j	9d004718 <__divdf3+0xa8>
9d00482c:	030e580b 	movn	t3,t8,t6
9d004830:	00003021 	move	a2,zero
9d004834:	0b4011c6 	j	9d004718 <__divdf3+0xa8>
9d004838:	240b0001 	li	t3,1
9d00483c:	00002821 	move	a1,zero
9d004840:	00002021 	move	a0,zero
9d004844:	0b4011d9 	j	9d004764 <__divdf3+0xf4>
9d004848:	240f0001 	li	t7,1
9d00484c:	3c05000f 	lui	a1,0xf
9d004850:	34a5ffff 	ori	a1,a1,0xffff
9d004854:	00007021 	move	t6,zero
9d004858:	2404ffff 	li	a0,-1
9d00485c:	7ca59800 	ext	a1,a1,0x0,0x14
9d004860:	240207ff 	li	v0,2047
9d004864:	00001821 	move	v1,zero
9d004868:	7ca39804 	ins	v1,a1,0x0,0x14
9d00486c:	7c43f504 	ins	v1,v0,0x14,0xb
9d004870:	7dc3ffc4 	ins	v1,t6,0x1f,0x1
9d004874:	03e00008 	jr	ra
9d004878:	00801021 	move	v0,a0
9d00487c:	00002821 	move	a1,zero
9d004880:	00001821 	move	v1,zero
9d004884:	00001021 	move	v0,zero
9d004888:	7ca39804 	ins	v1,a1,0x0,0x14
9d00488c:	00002021 	move	a0,zero
9d004890:	7c43f504 	ins	v1,v0,0x14,0xb
9d004894:	7dc3ffc4 	ins	v1,t6,0x1f,0x1
9d004898:	03e00008 	jr	ra
9d00489c:	00801021 	move	v0,a0
9d0048a0:	01a07021 	move	t6,t5
9d0048a4:	01e05821 	move	t3,t7
9d0048a8:	24030002 	li	v1,2
9d0048ac:	5163ffd2 	beql	t3,v1,9d0047f8 <__divdf3+0x188>
9d0048b0:	240207ff 	li	v0,2047
9d0048b4:	24030003 	li	v1,3
9d0048b8:	51630121 	beql	t3,v1,9d004d40 <__divdf3+0x6d0>
9d0048bc:	3c020008 	lui	v0,0x8
9d0048c0:	24030001 	li	v1,1
9d0048c4:	5163ffee 	beql	t3,v1,9d004880 <__divdf3+0x210>
9d0048c8:	00002821 	move	a1,zero
9d0048cc:	244203ff 	addiu	v0,v0,1023
9d0048d0:	184000ed 	blez	v0,9d004c88 <__divdf3+0x618>
9d0048d4:	3086000f 	andi	a2,a0,0xf
9d0048d8:	24030004 	li	v1,4
9d0048dc:	10c30004 	beq	a2,v1,9d0048f0 <__divdf3+0x280>
9d0048e0:	24830004 	addiu	v1,a0,4
9d0048e4:	0064202b 	sltu	a0,v1,a0
9d0048e8:	00a42821 	addu	a1,a1,a0
9d0048ec:	00602021 	move	a0,v1
9d0048f0:	7ca30600 	ext	v1,a1,0x18,0x1
9d0048f4:	10600006 	beqz	v1,9d004910 <__divdf3+0x2a0>
9d0048f8:	284307ff 	slti	v1,v0,2047
9d0048fc:	3c03feff 	lui	v1,0xfeff
9d004900:	3463ffff 	ori	v1,v1,0xffff
9d004904:	00a32824 	and	a1,a1,v1
9d004908:	24420001 	addiu	v0,v0,1
9d00490c:	284307ff 	slti	v1,v0,2047
9d004910:	5060ffb9 	beqzl	v1,9d0047f8 <__divdf3+0x188>
9d004914:	240207ff 	li	v0,2047
9d004918:	00053740 	sll	a2,a1,0x1d
9d00491c:	000420c2 	srl	a0,a0,0x3
9d004920:	00c42025 	or	a0,a2,a0
9d004924:	7ca598c0 	ext	a1,a1,0x3,0x14
9d004928:	0b401200 	j	9d004800 <__divdf3+0x190>
9d00492c:	304207ff 	andi	v0,v0,0x7ff
9d004930:	01202821 	move	a1,t1
9d004934:	00c02021 	move	a0,a2
9d004938:	0b40122a 	j	9d0048a8 <__divdf3+0x238>
9d00493c:	00e07021 	move	t6,a3
9d004940:	01254825 	or	t1,t1,a1
9d004944:	3c020008 	lui	v0,0x8
9d004948:	01224824 	and	t1,t1,v0
9d00494c:	5520ffc0 	bnezl	t1,9d004850 <__divdf3+0x1e0>
9d004950:	3c05000f 	lui	a1,0xf
9d004954:	00a22825 	or	a1,a1,v0
9d004958:	310e0001 	andi	t6,t0,0x1
9d00495c:	7ca59800 	ext	a1,a1,0x0,0x14
9d004960:	0b401219 	j	9d004864 <__divdf3+0x1f4>
9d004964:	240207ff 	li	v0,2047
9d004968:	0125382b 	sltu	a3,t1,a1
9d00496c:	14e0000f 	bnez	a3,9d0049ac <__divdf3+0x33c>
9d004970:	006a1023 	subu	v0,v1,t2
9d004974:	10a9000b 	beq	a1,t1,9d0049a4 <__divdf3+0x334>
9d004978:	00c4182b 	sltu	v1,a2,a0
9d00497c:	00806821 	move	t5,a0
9d004980:	2442ffff 	addiu	v0,v0,-1
9d004984:	0b401270 	j	9d0049c0 <__divdf3+0x350>
9d004988:	00002021 	move	a0,zero
9d00498c:	01264804 	sllv	t1,a2,t1
9d004990:	0b4011ef 	j	9d0047bc <__divdf3+0x14c>
9d004994:	00003021 	move	a2,zero
9d004998:	00a42804 	sllv	a1,a0,a1
9d00499c:	0b4011b3 	j	9d0046cc <__divdf3+0x5c>
9d0049a0:	00002021 	move	a0,zero
9d0049a4:	1060fff6 	beqz	v1,9d004980 <__divdf3+0x310>
9d0049a8:	00806821 	move	t5,a0
9d0049ac:	00046842 	srl	t5,a0,0x1
9d0049b0:	00051fc0 	sll	v1,a1,0x1f
9d0049b4:	01a36825 	or	t5,t5,v1
9d0049b8:	00052842 	srl	a1,a1,0x1
9d0049bc:	000427c0 	sll	a0,a0,0x1f
9d0049c0:	00094a00 	sll	t1,t1,0x8
9d0049c4:	00061e02 	srl	v1,a2,0x18
9d0049c8:	00691825 	or	v1,v1,t1
9d0049cc:	00033c02 	srl	a3,v1,0x10
9d0049d0:	00a7001b 	divu	zero,a1,a3
9d0049d4:	00e001f4 	teq	a3,zero,0x7
9d0049d8:	306bffff 	andi	t3,v1,0xffff
9d0049dc:	000d4402 	srl	t0,t5,0x10
9d0049e0:	00006012 	mflo	t4
9d0049e4:	00002810 	mfhi	a1
9d0049e8:	00055400 	sll	t2,a1,0x10
9d0049ec:	01485025 	or	t2,t2,t0
9d0049f0:	718b4802 	mul	t1,t4,t3
9d0049f4:	0149282b 	sltu	a1,t2,t1
9d0049f8:	10a0000a 	beqz	a1,9d004a24 <__divdf3+0x3b4>
9d0049fc:	00063200 	sll	a2,a2,0x8
9d004a00:	01435021 	addu	t2,t2,v1
9d004a04:	0143282b 	sltu	a1,t2,v1
9d004a08:	14a00006 	bnez	a1,9d004a24 <__divdf3+0x3b4>
9d004a0c:	258cffff 	addiu	t4,t4,-1
9d004a10:	0149282b 	sltu	a1,t2,t1
9d004a14:	50a00004 	beqzl	a1,9d004a28 <__divdf3+0x3b8>
9d004a18:	01494823 	subu	t1,t2,t1
9d004a1c:	258cffff 	addiu	t4,t4,-1
9d004a20:	01435021 	addu	t2,t2,v1
9d004a24:	01494823 	subu	t1,t2,t1
9d004a28:	0127001b 	divu	zero,t1,a3
9d004a2c:	00e001f4 	teq	a3,zero,0x7
9d004a30:	31afffff 	andi	t7,t5,0xffff
9d004a34:	00002812 	mflo	a1
9d004a38:	00004010 	mfhi	t0
9d004a3c:	00084400 	sll	t0,t0,0x10
9d004a40:	010f4025 	or	t0,t0,t7
9d004a44:	70ab6802 	mul	t5,a1,t3
9d004a48:	010d782b 	sltu	t7,t0,t5
9d004a4c:	51e0000b 	beqzl	t7,9d004a7c <__divdf3+0x40c>
9d004a50:	000c6400 	sll	t4,t4,0x10
9d004a54:	01034021 	addu	t0,t0,v1
9d004a58:	0103782b 	sltu	t7,t0,v1
9d004a5c:	15e00006 	bnez	t7,9d004a78 <__divdf3+0x408>
9d004a60:	24a5ffff 	addiu	a1,a1,-1
9d004a64:	010d782b 	sltu	t7,t0,t5
9d004a68:	51e00004 	beqzl	t7,9d004a7c <__divdf3+0x40c>
9d004a6c:	000c6400 	sll	t4,t4,0x10
9d004a70:	24a5ffff 	addiu	a1,a1,-1
9d004a74:	01034021 	addu	t0,t0,v1
9d004a78:	000c6400 	sll	t4,t4,0x10
9d004a7c:	00ac2825 	or	a1,a1,t4
9d004a80:	00a60019 	multu	a1,a2
9d004a84:	010d4023 	subu	t0,t0,t5
9d004a88:	0000c810 	mfhi	t9
9d004a8c:	0119682b 	sltu	t5,t0,t9
9d004a90:	03206021 	move	t4,t9
9d004a94:	15a00041 	bnez	t5,9d004b9c <__divdf3+0x52c>
9d004a98:	00005012 	mflo	t2
9d004a9c:	1119003d 	beq	t0,t9,9d004b94 <__divdf3+0x524>
9d004aa0:	008a482b 	sltu	t1,a0,t2
9d004aa4:	01194023 	subu	t0,t0,t9
9d004aa8:	008a5023 	subu	t2,a0,t2
9d004aac:	008a202b 	sltu	a0,a0,t2
9d004ab0:	01044023 	subu	t0,t0,a0
9d004ab4:	1103ff85 	beq	t0,v1,9d0048cc <__divdf3+0x25c>
9d004ab8:	2404ffff 	li	a0,-1
9d004abc:	0107001b 	divu	zero,t0,a3
9d004ac0:	00e001f4 	teq	a3,zero,0x7
9d004ac4:	000a6c02 	srl	t5,t2,0x10
9d004ac8:	00006012 	mflo	t4
9d004acc:	00004810 	mfhi	t1
9d004ad0:	00094c00 	sll	t1,t1,0x10
9d004ad4:	012d4825 	or	t1,t1,t5
9d004ad8:	718b2002 	mul	a0,t4,t3
9d004adc:	0124402b 	sltu	t0,t1,a0
9d004ae0:	5100000b 	beqzl	t0,9d004b10 <__divdf3+0x4a0>
9d004ae4:	01242023 	subu	a0,t1,a0
9d004ae8:	01234821 	addu	t1,t1,v1
9d004aec:	0123402b 	sltu	t0,t1,v1
9d004af0:	15000006 	bnez	t0,9d004b0c <__divdf3+0x49c>
9d004af4:	258cffff 	addiu	t4,t4,-1
9d004af8:	0124402b 	sltu	t0,t1,a0
9d004afc:	51000004 	beqzl	t0,9d004b10 <__divdf3+0x4a0>
9d004b00:	01242023 	subu	a0,t1,a0
9d004b04:	258cffff 	addiu	t4,t4,-1
9d004b08:	01234821 	addu	t1,t1,v1
9d004b0c:	01242023 	subu	a0,t1,a0
9d004b10:	0087001b 	divu	zero,a0,a3
9d004b14:	00e001f4 	teq	a3,zero,0x7
9d004b18:	314affff 	andi	t2,t2,0xffff
9d004b1c:	00002012 	mflo	a0
9d004b20:	00004010 	mfhi	t0
9d004b24:	00084400 	sll	t0,t0,0x10
9d004b28:	010a4025 	or	t0,t0,t2
9d004b2c:	708b5802 	mul	t3,a0,t3
9d004b30:	010b502b 	sltu	t2,t0,t3
9d004b34:	5140000b 	beqzl	t2,9d004b64 <__divdf3+0x4f4>
9d004b38:	000c6400 	sll	t4,t4,0x10
9d004b3c:	01034021 	addu	t0,t0,v1
9d004b40:	0103502b 	sltu	t2,t0,v1
9d004b44:	15400006 	bnez	t2,9d004b60 <__divdf3+0x4f0>
9d004b48:	2484ffff 	addiu	a0,a0,-1
9d004b4c:	010b502b 	sltu	t2,t0,t3
9d004b50:	51400004 	beqzl	t2,9d004b64 <__divdf3+0x4f4>
9d004b54:	000c6400 	sll	t4,t4,0x10
9d004b58:	2484ffff 	addiu	a0,a0,-1
9d004b5c:	01034021 	addu	t0,t0,v1
9d004b60:	000c6400 	sll	t4,t4,0x10
9d004b64:	008c2025 	or	a0,a0,t4
9d004b68:	00860019 	multu	a0,a2
9d004b6c:	010b5823 	subu	t3,t0,t3
9d004b70:	00006810 	mfhi	t5
9d004b74:	016d402b 	sltu	t0,t3,t5
9d004b78:	01a03821 	move	a3,t5
9d004b7c:	1500001e 	bnez	t0,9d004bf8 <__divdf3+0x588>
9d004b80:	00004812 	mflo	t1
9d004b84:	116d001a 	beq	t3,t5,9d004bf0 <__divdf3+0x580>
9d004b88:	00000000 	nop
9d004b8c:	0b401233 	j	9d0048cc <__divdf3+0x25c>
9d004b90:	34840001 	ori	a0,a0,0x1
9d004b94:	5120ffc4 	beqzl	t1,9d004aa8 <__divdf3+0x438>
9d004b98:	00004021 	move	t0,zero
9d004b9c:	00862021 	addu	a0,a0,a2
9d004ba0:	0086482b 	sltu	t1,a0,a2
9d004ba4:	01234821 	addu	t1,t1,v1
9d004ba8:	01284021 	addu	t0,t1,t0
9d004bac:	0068482b 	sltu	t1,v1,t0
9d004bb0:	11200008 	beqz	t1,9d004bd4 <__divdf3+0x564>
9d004bb4:	24a5ffff 	addiu	a1,a1,-1
9d004bb8:	010c482b 	sltu	t1,t0,t4
9d004bbc:	5520002c 	bnezl	t1,9d004c70 <__divdf3+0x600>
9d004bc0:	00862021 	addu	a0,a0,a2
9d004bc4:	11880027 	beq	t4,t0,9d004c64 <__divdf3+0x5f4>
9d004bc8:	008a482b 	sltu	t1,a0,t2
9d004bcc:	0b4012aa 	j	9d004aa8 <__divdf3+0x438>
9d004bd0:	010c4023 	subu	t0,t0,t4
9d004bd4:	5503ffb4 	bnel	t0,v1,9d004aa8 <__divdf3+0x438>
9d004bd8:	010c4023 	subu	t0,t0,t4
9d004bdc:	0086482b 	sltu	t1,a0,a2
9d004be0:	1120fff6 	beqz	t1,9d004bbc <__divdf3+0x54c>
9d004be4:	010c482b 	sltu	t1,t0,t4
9d004be8:	0b4012aa 	j	9d004aa8 <__divdf3+0x438>
9d004bec:	006c4023 	subu	t0,v1,t4
9d004bf0:	11200008 	beqz	t1,9d004c14 <__divdf3+0x5a4>
9d004bf4:	00004021 	move	t0,zero
9d004bf8:	01635821 	addu	t3,t3,v1
9d004bfc:	0163502b 	sltu	t2,t3,v1
9d004c00:	2484ffff 	addiu	a0,a0,-1
9d004c04:	11400007 	beqz	t2,9d004c24 <__divdf3+0x5b4>
9d004c08:	00c04021 	move	t0,a2
9d004c0c:	5567ff2f 	bnel	t3,a3,9d0048cc <__divdf3+0x25c>
9d004c10:	34840001 	ori	a0,a0,0x1
9d004c14:	5509ff2d 	bnel	t0,t1,9d0048cc <__divdf3+0x25c>
9d004c18:	34840001 	ori	a0,a0,0x1
9d004c1c:	0b401234 	j	9d0048d0 <__divdf3+0x260>
9d004c20:	244203ff 	addiu	v0,v0,1023
9d004c24:	0167402b 	sltu	t0,t3,a3
9d004c28:	55000007 	bnezl	t0,9d004c48 <__divdf3+0x5d8>
9d004c2c:	00064040 	sll	t0,a2,0x1
9d004c30:	54ebff26 	bnel	a3,t3,9d0048cc <__divdf3+0x25c>
9d004c34:	34840001 	ori	a0,a0,0x1
9d004c38:	00c9502b 	sltu	t2,a2,t1
9d004c3c:	1140fff5 	beqz	t2,9d004c14 <__divdf3+0x5a4>
9d004c40:	00c04021 	move	t0,a2
9d004c44:	00064040 	sll	t0,a2,0x1
9d004c48:	0106302b 	sltu	a2,t0,a2
9d004c4c:	00c31821 	addu	v1,a2,v1
9d004c50:	01635821 	addu	t3,t3,v1
9d004c54:	1567ffcd 	bne	t3,a3,9d004b8c <__divdf3+0x51c>
9d004c58:	2484ffff 	addiu	a0,a0,-1
9d004c5c:	0b401305 	j	9d004c14 <__divdf3+0x5a4>
9d004c60:	00000000 	nop
9d004c64:	5120ff90 	beqzl	t1,9d004aa8 <__divdf3+0x438>
9d004c68:	00004021 	move	t0,zero
9d004c6c:	00862021 	addu	a0,a0,a2
9d004c70:	0086482b 	sltu	t1,a0,a2
9d004c74:	01234821 	addu	t1,t1,v1
9d004c78:	01284021 	addu	t0,t1,t0
9d004c7c:	24a5ffff 	addiu	a1,a1,-1
9d004c80:	0b4012aa 	j	9d004aa8 <__divdf3+0x438>
9d004c84:	010c4023 	subu	t0,t0,t4
9d004c88:	24030001 	li	v1,1
9d004c8c:	00621023 	subu	v0,v1,v0
9d004c90:	28430039 	slti	v1,v0,57
9d004c94:	5060fefa 	beqzl	v1,9d004880 <__divdf3+0x210>
9d004c98:	00002821 	move	a1,zero
9d004c9c:	28430020 	slti	v1,v0,32
9d004ca0:	10600018 	beqz	v1,9d004d04 <__divdf3+0x694>
9d004ca4:	24060020 	li	a2,32
9d004ca8:	24030020 	li	v1,32
9d004cac:	00621823 	subu	v1,v1,v0
9d004cb0:	00653804 	sllv	a3,a1,v1
9d004cb4:	00443006 	srlv	a2,a0,v0
9d004cb8:	00641804 	sllv	v1,a0,v1
9d004cbc:	00e63825 	or	a3,a3,a2
9d004cc0:	0003182b 	sltu	v1,zero,v1
9d004cc4:	00e32025 	or	a0,a3,v1
9d004cc8:	00452806 	srlv	a1,a1,v0
9d004ccc:	3083000f 	andi	v1,a0,0xf
9d004cd0:	24020004 	li	v0,4
9d004cd4:	10620004 	beq	v1,v0,9d004ce8 <__divdf3+0x678>
9d004cd8:	24820004 	addiu	v0,a0,4
9d004cdc:	0044202b 	sltu	a0,v0,a0
9d004ce0:	00a42821 	addu	a1,a1,a0
9d004ce4:	00402021 	move	a0,v0
9d004ce8:	7ca205c0 	ext	v0,a1,0x17,0x1
9d004cec:	1040000f 	beqz	v0,9d004d2c <__divdf3+0x6bc>
9d004cf0:	00053740 	sll	a2,a1,0x1d
9d004cf4:	24020001 	li	v0,1
9d004cf8:	00002821 	move	a1,zero
9d004cfc:	0b401200 	j	9d004800 <__divdf3+0x190>
9d004d00:	00002021 	move	a0,zero
9d004d04:	00453806 	srlv	a3,a1,v0
9d004d08:	10460003 	beq	v0,a2,9d004d18 <__divdf3+0x6a8>
9d004d0c:	00001821 	move	v1,zero
9d004d10:	00021023 	negu	v0,v0
9d004d14:	00451804 	sllv	v1,a1,v0
9d004d18:	00642025 	or	a0,v1,a0
9d004d1c:	0004202b 	sltu	a0,zero,a0
9d004d20:	00872025 	or	a0,a0,a3
9d004d24:	0b401333 	j	9d004ccc <__divdf3+0x65c>
9d004d28:	00002821 	move	a1,zero
9d004d2c:	000420c2 	srl	a0,a0,0x3
9d004d30:	00c42025 	or	a0,a2,a0
9d004d34:	7ca598c0 	ext	a1,a1,0x3,0x14
9d004d38:	0b401200 	j	9d004800 <__divdf3+0x190>
9d004d3c:	00001021 	move	v0,zero
9d004d40:	00a22825 	or	a1,a1,v0
9d004d44:	7ca59800 	ext	a1,a1,0x0,0x14
9d004d48:	0b401219 	j	9d004864 <__divdf3+0x1f4>
9d004d4c:	240207ff 	li	v0,2047

9d004d50 <__gedf2>:
9d004d50:	7ca35500 	ext	v1,a1,0x14,0xb
9d004d54:	240207ff 	li	v0,2047
9d004d58:	7cab9800 	ext	t3,a1,0x0,0x14
9d004d5c:	7cea9800 	ext	t2,a3,0x0,0x14
9d004d60:	7ce85500 	ext	t0,a3,0x14,0xb
9d004d64:	00052fc2 	srl	a1,a1,0x1f
9d004d68:	1062002f 	beq	v1,v0,9d004e28 <__gedf2+0xd8>
9d004d6c:	00073fc2 	srl	a3,a3,0x1f
9d004d70:	240207ff 	li	v0,2047
9d004d74:	11020031 	beq	t0,v0,9d004e3c <__gedf2+0xec>
9d004d78:	01464825 	or	t1,t2,a2
9d004d7c:	14600003 	bnez	v1,9d004d8c <__gedf2+0x3c>
9d004d80:	00001021 	move	v0,zero
9d004d84:	01641025 	or	v0,t3,a0
9d004d88:	2c420001 	sltiu	v0,v0,1
9d004d8c:	15000003 	bnez	t0,9d004d9c <__gedf2+0x4c>
9d004d90:	00004821 	move	t1,zero
9d004d94:	01464825 	or	t1,t2,a2
9d004d98:	2d290001 	sltiu	t1,t1,1
9d004d9c:	10400007 	beqz	v0,9d004dbc <__gedf2+0x6c>
9d004da0:	00000000 	nop
9d004da4:	15200023 	bnez	t1,9d004e34 <__gedf2+0xe4>
9d004da8:	00001021 	move	v0,zero
9d004dac:	24020001 	li	v0,1
9d004db0:	2403ffff 	li	v1,-1
9d004db4:	03e00008 	jr	ra
9d004db8:	0067100a 	movz	v0,v1,a3
9d004dbc:	1520000d 	bnez	t1,9d004df4 <__gedf2+0xa4>
9d004dc0:	2402ffff 	li	v0,-1
9d004dc4:	54a7000c 	bnel	a1,a3,9d004df8 <__gedf2+0xa8>
9d004dc8:	24030001 	li	v1,1
9d004dcc:	0103102a 	slt	v0,t0,v1
9d004dd0:	54400008 	bnezl	v0,9d004df4 <__gedf2+0xa4>
9d004dd4:	2402ffff 	li	v0,-1
9d004dd8:	0068182a 	slt	v1,v1,t0
9d004ddc:	50600008 	beqzl	v1,9d004e00 <__gedf2+0xb0>
9d004de0:	014b102b 	sltu	v0,t2,t3
9d004de4:	24020001 	li	v0,1
9d004de8:	2403ffff 	li	v1,-1
9d004dec:	03e00008 	jr	ra
9d004df0:	0065100a 	movz	v0,v1,a1
9d004df4:	24030001 	li	v1,1
9d004df8:	03e00008 	jr	ra
9d004dfc:	0065100a 	movz	v0,v1,a1
9d004e00:	5440fffc 	bnezl	v0,9d004df4 <__gedf2+0xa4>
9d004e04:	2402ffff 	li	v0,-1
9d004e08:	116a0012 	beq	t3,t2,9d004e54 <__gedf2+0x104>
9d004e0c:	016a502b 	sltu	t2,t3,t2
9d004e10:	1140000e 	beqz	t2,9d004e4c <__gedf2+0xfc>
9d004e14:	00000000 	nop
9d004e18:	24020001 	li	v0,1
9d004e1c:	2403ffff 	li	v1,-1
9d004e20:	03e00008 	jr	ra
9d004e24:	0065100a 	movz	v0,v1,a1
9d004e28:	01644825 	or	t1,t3,a0
9d004e2c:	1120ffd0 	beqz	t1,9d004d70 <__gedf2+0x20>
9d004e30:	2402fffe 	li	v0,-2
9d004e34:	03e00008 	jr	ra
9d004e38:	00000000 	nop
9d004e3c:	1120ffcf 	beqz	t1,9d004d7c <__gedf2+0x2c>
9d004e40:	2402fffe 	li	v0,-2
9d004e44:	03e00008 	jr	ra
9d004e48:	00000000 	nop
9d004e4c:	03e00008 	jr	ra
9d004e50:	00001021 	move	v0,zero
9d004e54:	00c4102b 	sltu	v0,a2,a0
9d004e58:	1440ffe6 	bnez	v0,9d004df4 <__gedf2+0xa4>
9d004e5c:	2402ffff 	li	v0,-1
9d004e60:	0086202b 	sltu	a0,a0,a2
9d004e64:	1480ffec 	bnez	a0,9d004e18 <__gedf2+0xc8>
9d004e68:	00001021 	move	v0,zero
9d004e6c:	03e00008 	jr	ra
9d004e70:	00000000 	nop

9d004e74 <__ledf2>:
9d004e74:	7ca35500 	ext	v1,a1,0x14,0xb
9d004e78:	240207ff 	li	v0,2047
9d004e7c:	7ca99800 	ext	t1,a1,0x0,0x14
9d004e80:	7cea9800 	ext	t2,a3,0x0,0x14
9d004e84:	7ce85500 	ext	t0,a3,0x14,0xb
9d004e88:	00052fc2 	srl	a1,a1,0x1f
9d004e8c:	1062001d 	beq	v1,v0,9d004f04 <__ledf2+0x90>
9d004e90:	00073fc2 	srl	a3,a3,0x1f
9d004e94:	240207ff 	li	v0,2047
9d004e98:	11020011 	beq	t0,v0,9d004ee0 <__ledf2+0x6c>
9d004e9c:	01465825 	or	t3,t2,a2
9d004ea0:	14600003 	bnez	v1,9d004eb0 <__ledf2+0x3c>
9d004ea4:	00001021 	move	v0,zero
9d004ea8:	01241025 	or	v0,t1,a0
9d004eac:	2c420001 	sltiu	v0,v0,1
9d004eb0:	15000003 	bnez	t0,9d004ec0 <__ledf2+0x4c>
9d004eb4:	00005821 	move	t3,zero
9d004eb8:	01465825 	or	t3,t2,a2
9d004ebc:	2d6b0001 	sltiu	t3,t3,1
9d004ec0:	1040000b 	beqz	v0,9d004ef0 <__ledf2+0x7c>
9d004ec4:	00000000 	nop
9d004ec8:	15600007 	bnez	t3,9d004ee8 <__ledf2+0x74>
9d004ecc:	00001021 	move	v0,zero
9d004ed0:	24020001 	li	v0,1
9d004ed4:	2403ffff 	li	v1,-1
9d004ed8:	03e00008 	jr	ra
9d004edc:	0067100a 	movz	v0,v1,a3
9d004ee0:	1160ffef 	beqz	t3,9d004ea0 <__ledf2+0x2c>
9d004ee4:	24020002 	li	v0,2
9d004ee8:	03e00008 	jr	ra
9d004eec:	00000000 	nop
9d004ef0:	11600009 	beqz	t3,9d004f18 <__ledf2+0xa4>
9d004ef4:	2402ffff 	li	v0,-1
9d004ef8:	24030001 	li	v1,1
9d004efc:	03e00008 	jr	ra
9d004f00:	0065100a 	movz	v0,v1,a1
9d004f04:	01245825 	or	t3,t1,a0
9d004f08:	1160ffe2 	beqz	t3,9d004e94 <__ledf2+0x20>
9d004f0c:	24020002 	li	v0,2
9d004f10:	03e00008 	jr	ra
9d004f14:	00000000 	nop
9d004f18:	14a7fff7 	bne	a1,a3,9d004ef8 <__ledf2+0x84>
9d004f1c:	00000000 	nop
9d004f20:	0103102a 	slt	v0,t0,v1
9d004f24:	5440fff4 	bnezl	v0,9d004ef8 <__ledf2+0x84>
9d004f28:	2402ffff 	li	v0,-1
9d004f2c:	0068182a 	slt	v1,v1,t0
9d004f30:	50600005 	beqzl	v1,9d004f48 <__ledf2+0xd4>
9d004f34:	0149102b 	sltu	v0,t2,t1
9d004f38:	24020001 	li	v0,1
9d004f3c:	2403ffff 	li	v1,-1
9d004f40:	03e00008 	jr	ra
9d004f44:	0065100a 	movz	v0,v1,a1
9d004f48:	5440ffeb 	bnezl	v0,9d004ef8 <__ledf2+0x84>
9d004f4c:	2402ffff 	li	v0,-1
9d004f50:	112a0007 	beq	t1,t2,9d004f70 <__ledf2+0xfc>
9d004f54:	012a482b 	sltu	t1,t1,t2
9d004f58:	1120000d 	beqz	t1,9d004f90 <__ledf2+0x11c>
9d004f5c:	00000000 	nop
9d004f60:	2403ffff 	li	v1,-1
9d004f64:	24020001 	li	v0,1
9d004f68:	03e00008 	jr	ra
9d004f6c:	0065100a 	movz	v0,v1,a1
9d004f70:	00c4102b 	sltu	v0,a2,a0
9d004f74:	5440ffe0 	bnezl	v0,9d004ef8 <__ledf2+0x84>
9d004f78:	2402ffff 	li	v0,-1
9d004f7c:	0086202b 	sltu	a0,a0,a2
9d004f80:	1480fff7 	bnez	a0,9d004f60 <__ledf2+0xec>
9d004f84:	00001021 	move	v0,zero
9d004f88:	03e00008 	jr	ra
9d004f8c:	00000000 	nop
9d004f90:	03e00008 	jr	ra
9d004f94:	00001021 	move	v0,zero

9d004f98 <__muldf3>:
9d004f98:	27bdfff0 	addiu	sp,sp,-16
9d004f9c:	7ca807c0 	ext	t0,a1,0x1f,0x1
9d004fa0:	7ca35500 	ext	v1,a1,0x14,0xb
9d004fa4:	afb3000c 	sw	s3,12(sp)
9d004fa8:	afb20008 	sw	s2,8(sp)
9d004fac:	afb10004 	sw	s1,4(sp)
9d004fb0:	afb00000 	sw	s0,0(sp)
9d004fb4:	7ca59800 	ext	a1,a1,0x0,0x14
9d004fb8:	1460002f 	bnez	v1,9d005078 <__muldf3+0xe0>
9d004fbc:	310c00ff 	andi	t4,t0,0xff
9d004fc0:	00a44825 	or	t1,a1,a0
9d004fc4:	11200065 	beqz	t1,9d00515c <__muldf3+0x1c4>
9d004fc8:	240b0004 	li	t3,4
9d004fcc:	14a00003 	bnez	a1,9d004fdc <__muldf3+0x44>
9d004fd0:	70a94820 	clz	t1,a1
9d004fd4:	70894820 	clz	t1,a0
9d004fd8:	25290020 	addiu	t1,t1,32
9d004fdc:	2523fff5 	addiu	v1,t1,-11
9d004fe0:	286a001d 	slti	t2,v1,29
9d004fe4:	5140010d 	beqzl	t2,9d00541c <__muldf3+0x484>
9d004fe8:	2525ffd8 	addiu	a1,t1,-40
9d004fec:	240a001d 	li	t2,29
9d004ff0:	2529fff8 	addiu	t1,t1,-8
9d004ff4:	01435023 	subu	t2,t2,v1
9d004ff8:	01445006 	srlv	t2,a0,t2
9d004ffc:	01252804 	sllv	a1,a1,t1
9d005000:	01452825 	or	a1,t2,a1
9d005004:	01242004 	sllv	a0,a0,t1
9d005008:	2409fc02 	li	t1,-1022
9d00500c:	7cee07c0 	ext	t6,a3,0x1f,0x1
9d005010:	01231823 	subu	v1,t1,v1
9d005014:	7ce95500 	ext	t1,a3,0x14,0xb
9d005018:	00005821 	move	t3,zero
9d00501c:	0000c021 	move	t8,zero
9d005020:	7ce79800 	ext	a3,a3,0x0,0x14
9d005024:	11200024 	beqz	t1,9d0050b8 <__muldf3+0x120>
9d005028:	31cd00ff 	andi	t5,t6,0xff
9d00502c:	240a07ff 	li	t2,2047
9d005030:	112a0041 	beq	t1,t2,9d005138 <__muldf3+0x1a0>
9d005034:	00e67825 	or	t7,a3,a2
9d005038:	3c0a0010 	lui	t2,0x10
9d00503c:	00ea3825 	or	a3,a3,t2
9d005040:	000738c0 	sll	a3,a3,0x3
9d005044:	00065742 	srl	t2,a2,0x1d
9d005048:	00ea3825 	or	a3,a3,t2
9d00504c:	000630c0 	sll	a2,a2,0x3
9d005050:	2529fc01 	addiu	t1,t1,-1023
9d005054:	00005021 	move	t2,zero
9d005058:	014b5825 	or	t3,t2,t3
9d00505c:	3c0f9d00 	lui	t7,0x9d00
9d005060:	25ef6890 	addiu	t7,t7,26768
9d005064:	000b5880 	sll	t3,t3,0x2
9d005068:	01eb5821 	addu	t3,t7,t3
9d00506c:	8d6f0000 	lw	t7,0(t3)
9d005070:	01e00008 	jr	t7
9d005074:	01ac5826 	xor	t3,t5,t4
9d005078:	240907ff 	li	t1,2047
9d00507c:	10690024 	beq	v1,t1,9d005110 <__muldf3+0x178>
9d005080:	3c090010 	lui	t1,0x10
9d005084:	00a92825 	or	a1,a1,t1
9d005088:	000528c0 	sll	a1,a1,0x3
9d00508c:	00044f42 	srl	t1,a0,0x1d
9d005090:	00a92825 	or	a1,a1,t1
9d005094:	000420c0 	sll	a0,a0,0x3
9d005098:	2463fc01 	addiu	v1,v1,-1023
9d00509c:	00005821 	move	t3,zero
9d0050a0:	0000c021 	move	t8,zero
9d0050a4:	7cee07c0 	ext	t6,a3,0x1f,0x1
9d0050a8:	7ce95500 	ext	t1,a3,0x14,0xb
9d0050ac:	31cd00ff 	andi	t5,t6,0xff
9d0050b0:	1520ffde 	bnez	t1,9d00502c <__muldf3+0x94>
9d0050b4:	7ce79800 	ext	a3,a3,0x0,0x14
9d0050b8:	00e65025 	or	t2,a3,a2
9d0050bc:	51400024 	beqzl	t2,9d005150 <__muldf3+0x1b8>
9d0050c0:	00003821 	move	a3,zero
9d0050c4:	14e00003 	bnez	a3,9d0050d4 <__muldf3+0x13c>
9d0050c8:	70ea5020 	clz	t2,a3
9d0050cc:	70ca5020 	clz	t2,a2
9d0050d0:	254a0020 	addiu	t2,t2,32
9d0050d4:	2549fff5 	addiu	t1,t2,-11
9d0050d8:	292f001d 	slti	t7,t1,29
9d0050dc:	51e000cc 	beqzl	t7,9d005410 <__muldf3+0x478>
9d0050e0:	2547ffd8 	addiu	a3,t2,-40
9d0050e4:	240f001d 	li	t7,29
9d0050e8:	254afff8 	addiu	t2,t2,-8
9d0050ec:	01e97823 	subu	t7,t7,t1
9d0050f0:	01e67806 	srlv	t7,a2,t7
9d0050f4:	01473804 	sllv	a3,a3,t2
9d0050f8:	01e73825 	or	a3,t7,a3
9d0050fc:	01463004 	sllv	a2,a2,t2
9d005100:	240afc02 	li	t2,-1022
9d005104:	01494823 	subu	t1,t2,t1
9d005108:	0b401416 	j	9d005058 <__muldf3+0xc0>
9d00510c:	00005021 	move	t2,zero
9d005110:	00a44825 	or	t1,a1,a0
9d005114:	240a000c 	li	t2,12
9d005118:	240b0008 	li	t3,8
9d00511c:	24180002 	li	t8,2
9d005120:	0149580b 	movn	t3,t2,t1
9d005124:	240a0003 	li	t2,3
9d005128:	0009280a 	movz	a1,zero,t1
9d00512c:	0009200a 	movz	a0,zero,t1
9d005130:	0b401429 	j	9d0050a4 <__muldf3+0x10c>
9d005134:	0149c00b 	movn	t8,t2,t1
9d005138:	240a0002 	li	t2,2
9d00513c:	24190003 	li	t9,3
9d005140:	000f380a 	movz	a3,zero,t7
9d005144:	000f300a 	movz	a2,zero,t7
9d005148:	0b401416 	j	9d005058 <__muldf3+0xc0>
9d00514c:	032f500b 	movn	t2,t9,t7
9d005150:	00003021 	move	a2,zero
9d005154:	0b401416 	j	9d005058 <__muldf3+0xc0>
9d005158:	240a0001 	li	t2,1
9d00515c:	00002821 	move	a1,zero
9d005160:	00002021 	move	a0,zero
9d005164:	0b401429 	j	9d0050a4 <__muldf3+0x10c>
9d005168:	24180001 	li	t8,1
9d00516c:	01604021 	move	t0,t3
9d005170:	03005021 	move	t2,t8
9d005174:	24030002 	li	v1,2
9d005178:	5143002e 	beql	t2,v1,9d005234 <__muldf3+0x29c>
9d00517c:	00002821 	move	a1,zero
9d005180:	24030003 	li	v1,3
9d005184:	114300b2 	beq	t2,v1,9d005450 <__muldf3+0x4b8>
9d005188:	24030001 	li	v1,1
9d00518c:	51430093 	beql	t2,v1,9d0053dc <__muldf3+0x444>
9d005190:	00002821 	move	a1,zero
9d005194:	244203ff 	addiu	v0,v0,1023
9d005198:	18400089 	blez	v0,9d0053c0 <__muldf3+0x428>
9d00519c:	3086000f 	andi	a2,a0,0xf
9d0051a0:	24030004 	li	v1,4
9d0051a4:	10c30004 	beq	a2,v1,9d0051b8 <__muldf3+0x220>
9d0051a8:	24830004 	addiu	v1,a0,4
9d0051ac:	0064202b 	sltu	a0,v1,a0
9d0051b0:	00a42821 	addu	a1,a1,a0
9d0051b4:	00602021 	move	a0,v1
9d0051b8:	7ca30600 	ext	v1,a1,0x18,0x1
9d0051bc:	10600006 	beqz	v1,9d0051d8 <__muldf3+0x240>
9d0051c0:	284307ff 	slti	v1,v0,2047
9d0051c4:	3c03feff 	lui	v1,0xfeff
9d0051c8:	3463ffff 	ori	v1,v1,0xffff
9d0051cc:	00a32824 	and	a1,a1,v1
9d0051d0:	24420001 	addiu	v0,v0,1
9d0051d4:	284307ff 	slti	v1,v0,2047
9d0051d8:	14600093 	bnez	v1,9d005428 <__muldf3+0x490>
9d0051dc:	00053740 	sll	a2,a1,0x1d
9d0051e0:	01604021 	move	t0,t3
9d0051e4:	240207ff 	li	v0,2047
9d0051e8:	00002821 	move	a1,zero
9d0051ec:	00002021 	move	a0,zero
9d0051f0:	00001821 	move	v1,zero
9d0051f4:	7ca39804 	ins	v1,a1,0x0,0x14
9d0051f8:	7c43f504 	ins	v1,v0,0x14,0xb
9d0051fc:	7d03ffc4 	ins	v1,t0,0x1f,0x1
9d005200:	00801021 	move	v0,a0
9d005204:	8fb3000c 	lw	s3,12(sp)
9d005208:	8fb20008 	lw	s2,8(sp)
9d00520c:	8fb10004 	lw	s1,4(sp)
9d005210:	8fb00000 	lw	s0,0(sp)
9d005214:	03e00008 	jr	ra
9d005218:	27bd0010 	addiu	sp,sp,16
9d00521c:	03005021 	move	t2,t8
9d005220:	24030002 	li	v1,2
9d005224:	31080001 	andi	t0,t0,0x1
9d005228:	1543ffd5 	bne	t2,v1,9d005180 <__muldf3+0x1e8>
9d00522c:	01805821 	move	t3,t4
9d005230:	00002821 	move	a1,zero
9d005234:	00001821 	move	v1,zero
9d005238:	240207ff 	li	v0,2047
9d00523c:	7ca39804 	ins	v1,a1,0x0,0x14
9d005240:	7c43f504 	ins	v1,v0,0x14,0xb
9d005244:	00002021 	move	a0,zero
9d005248:	7d03ffc4 	ins	v1,t0,0x1f,0x1
9d00524c:	00801021 	move	v0,a0
9d005250:	8fb3000c 	lw	s3,12(sp)
9d005254:	8fb20008 	lw	s2,8(sp)
9d005258:	8fb10004 	lw	s1,4(sp)
9d00525c:	8fb00000 	lw	s0,0(sp)
9d005260:	03e00008 	jr	ra
9d005264:	27bd0010 	addiu	sp,sp,16
9d005268:	01604021 	move	t0,t3
9d00526c:	00e02821 	move	a1,a3
9d005270:	0b40145d 	j	9d005174 <__muldf3+0x1dc>
9d005274:	00c02021 	move	a0,a2
9d005278:	00e40019 	multu	a3,a0
9d00527c:	01231021 	addu	v0,t1,v1
9d005280:	00007012 	mflo	t6
9d005284:	00007810 	mfhi	t7
9d005288:	00c40019 	multu	a2,a0
9d00528c:	0000c012 	mflo	t8
9d005290:	0000c810 	mfhi	t9
9d005294:	01d91821 	addu	v1,t6,t9
9d005298:	006e682b 	sltu	t5,v1,t6
9d00529c:	00c50019 	multu	a2,a1
9d0052a0:	00008012 	mflo	s0
9d0052a4:	00701821 	addu	v1,v1,s0
9d0052a8:	00032240 	sll	a0,v1,0x9
9d0052ac:	00008810 	mfhi	s1
9d0052b0:	0098c025 	or	t8,a0,t8
9d0052b4:	0070402b 	sltu	t0,v1,s0
9d0052b8:	0018c02b 	sltu	t8,zero,t8
9d0052bc:	00e50019 	multu	a3,a1
9d0052c0:	00031dc2 	srl	v1,v1,0x17
9d0052c4:	03032025 	or	a0,t8,v1
9d0052c8:	00009012 	mflo	s2
9d0052cc:	01f27021 	addu	t6,t7,s2
9d0052d0:	01ae6021 	addu	t4,t5,t6
9d0052d4:	01914821 	addu	t1,t4,s1
9d0052d8:	00009810 	mfhi	s3
9d0052dc:	01281821 	addu	v1,t1,t0
9d0052e0:	01cf702b 	sltu	t6,t6,t7
9d0052e4:	018d602b 	sltu	t4,t4,t5
9d0052e8:	0068402b 	sltu	t0,v1,t0
9d0052ec:	0131482b 	sltu	t1,t1,s1
9d0052f0:	018e6025 	or	t4,t4,t6
9d0052f4:	01932821 	addu	a1,t4,s3
9d0052f8:	01094025 	or	t0,t0,t1
9d0052fc:	00a82821 	addu	a1,a1,t0
9d005300:	000335c2 	srl	a2,v1,0x17
9d005304:	00052a40 	sll	a1,a1,0x9
9d005308:	00a62825 	or	a1,a1,a2
9d00530c:	00031a40 	sll	v1,v1,0x9
9d005310:	7ca70600 	ext	a3,a1,0x18,0x1
9d005314:	10e0ff9f 	beqz	a3,9d005194 <__muldf3+0x1fc>
9d005318:	00832025 	or	a0,a0,v1
9d00531c:	30860001 	andi	a2,a0,0x1
9d005320:	00042042 	srl	a0,a0,0x1
9d005324:	00051fc0 	sll	v1,a1,0x1f
9d005328:	00c42025 	or	a0,a2,a0
9d00532c:	24420001 	addiu	v0,v0,1
9d005330:	00832025 	or	a0,a0,v1
9d005334:	0b401465 	j	9d005194 <__muldf3+0x1fc>
9d005338:	00052842 	srl	a1,a1,0x1
9d00533c:	31c80001 	andi	t0,t6,0x1
9d005340:	00e02821 	move	a1,a3
9d005344:	00c02021 	move	a0,a2
9d005348:	0b40145d 	j	9d005174 <__muldf3+0x1dc>
9d00534c:	01a05821 	move	t3,t5
9d005350:	00e53825 	or	a3,a3,a1
9d005354:	3c020008 	lui	v0,0x8
9d005358:	00e23824 	and	a3,a3,v0
9d00535c:	54e00038 	bnezl	a3,9d005440 <__muldf3+0x4a8>
9d005360:	3c05000f 	lui	a1,0xf
9d005364:	00a22825 	or	a1,a1,v0
9d005368:	01805821 	move	t3,t4
9d00536c:	7ca59800 	ext	a1,a1,0x0,0x14
9d005370:	00001821 	move	v1,zero
9d005374:	240207ff 	li	v0,2047
9d005378:	7ca39804 	ins	v1,a1,0x0,0x14
9d00537c:	7c43f504 	ins	v1,v0,0x14,0xb
9d005380:	01604021 	move	t0,t3
9d005384:	7d03ffc4 	ins	v1,t0,0x1f,0x1
9d005388:	00801021 	move	v0,a0
9d00538c:	8fb3000c 	lw	s3,12(sp)
9d005390:	8fb20008 	lw	s2,8(sp)
9d005394:	8fb10004 	lw	s1,4(sp)
9d005398:	8fb00000 	lw	s0,0(sp)
9d00539c:	03e00008 	jr	ra
9d0053a0:	27bd0010 	addiu	sp,sp,16
9d0053a4:	3c05000f 	lui	a1,0xf
9d0053a8:	00004021 	move	t0,zero
9d0053ac:	34a5ffff 	ori	a1,a1,0xffff
9d0053b0:	2404ffff 	li	a0,-1
9d0053b4:	00005821 	move	t3,zero
9d0053b8:	0b40145d 	j	9d005174 <__muldf3+0x1dc>
9d0053bc:	240a0003 	li	t2,3
9d0053c0:	24030001 	li	v1,1
9d0053c4:	00621023 	subu	v0,v1,v0
9d0053c8:	28430039 	slti	v1,v0,57
9d0053cc:	14600023 	bnez	v1,9d00545c <__muldf3+0x4c4>
9d0053d0:	28430020 	slti	v1,v0,32
9d0053d4:	01604021 	move	t0,t3
9d0053d8:	00002821 	move	a1,zero
9d0053dc:	00001821 	move	v1,zero
9d0053e0:	00001021 	move	v0,zero
9d0053e4:	7ca39804 	ins	v1,a1,0x0,0x14
9d0053e8:	7c43f504 	ins	v1,v0,0x14,0xb
9d0053ec:	00002021 	move	a0,zero
9d0053f0:	7d03ffc4 	ins	v1,t0,0x1f,0x1
9d0053f4:	00801021 	move	v0,a0
9d0053f8:	8fb3000c 	lw	s3,12(sp)
9d0053fc:	8fb20008 	lw	s2,8(sp)
9d005400:	8fb10004 	lw	s1,4(sp)
9d005404:	8fb00000 	lw	s0,0(sp)
9d005408:	03e00008 	jr	ra
9d00540c:	27bd0010 	addiu	sp,sp,16
9d005410:	00e63804 	sllv	a3,a2,a3
9d005414:	0b401440 	j	9d005100 <__muldf3+0x168>
9d005418:	00003021 	move	a2,zero
9d00541c:	00a42804 	sllv	a1,a0,a1
9d005420:	0b401402 	j	9d005008 <__muldf3+0x70>
9d005424:	00002021 	move	a0,zero
9d005428:	000420c2 	srl	a0,a0,0x3
9d00542c:	00c42025 	or	a0,a2,a0
9d005430:	7ca598c0 	ext	a1,a1,0x3,0x14
9d005434:	304207ff 	andi	v0,v0,0x7ff
9d005438:	0b40147c 	j	9d0051f0 <__muldf3+0x258>
9d00543c:	01604021 	move	t0,t3
9d005440:	34a5ffff 	ori	a1,a1,0xffff
9d005444:	2404ffff 	li	a0,-1
9d005448:	0b4014db 	j	9d00536c <__muldf3+0x3d4>
9d00544c:	00005821 	move	t3,zero
9d005450:	3c070008 	lui	a3,0x8
9d005454:	0b4014db 	j	9d00536c <__muldf3+0x3d4>
9d005458:	00a72825 	or	a1,a1,a3
9d00545c:	10600019 	beqz	v1,9d0054c4 <__muldf3+0x52c>
9d005460:	24060020 	li	a2,32
9d005464:	24030020 	li	v1,32
9d005468:	00621823 	subu	v1,v1,v0
9d00546c:	00653804 	sllv	a3,a1,v1
9d005470:	00443006 	srlv	a2,a0,v0
9d005474:	00641804 	sllv	v1,a0,v1
9d005478:	00e63825 	or	a3,a3,a2
9d00547c:	0003182b 	sltu	v1,zero,v1
9d005480:	00e32025 	or	a0,a3,v1
9d005484:	00452806 	srlv	a1,a1,v0
9d005488:	3083000f 	andi	v1,a0,0xf
9d00548c:	24020004 	li	v0,4
9d005490:	10620004 	beq	v1,v0,9d0054a4 <__muldf3+0x50c>
9d005494:	24820004 	addiu	v0,a0,4
9d005498:	0044202b 	sltu	a0,v0,a0
9d00549c:	00a42821 	addu	a1,a1,a0
9d0054a0:	00402021 	move	a0,v0
9d0054a4:	7ca205c0 	ext	v0,a1,0x17,0x1
9d0054a8:	10400010 	beqz	v0,9d0054ec <__muldf3+0x554>
9d0054ac:	00053740 	sll	a2,a1,0x1d
9d0054b0:	01604021 	move	t0,t3
9d0054b4:	24020001 	li	v0,1
9d0054b8:	00002821 	move	a1,zero
9d0054bc:	0b40147c 	j	9d0051f0 <__muldf3+0x258>
9d0054c0:	00002021 	move	a0,zero
9d0054c4:	00453806 	srlv	a3,a1,v0
9d0054c8:	10460003 	beq	v0,a2,9d0054d8 <__muldf3+0x540>
9d0054cc:	00001821 	move	v1,zero
9d0054d0:	00021023 	negu	v0,v0
9d0054d4:	00451804 	sllv	v1,a1,v0
9d0054d8:	00642025 	or	a0,v1,a0
9d0054dc:	0004202b 	sltu	a0,zero,a0
9d0054e0:	00872025 	or	a0,a0,a3
9d0054e4:	0b401522 	j	9d005488 <__muldf3+0x4f0>
9d0054e8:	00002821 	move	a1,zero
9d0054ec:	000420c2 	srl	a0,a0,0x3
9d0054f0:	00c42025 	or	a0,a2,a0
9d0054f4:	7ca598c0 	ext	a1,a1,0x3,0x14
9d0054f8:	01604021 	move	t0,t3
9d0054fc:	0b40147c 	j	9d0051f0 <__muldf3+0x258>
9d005500:	00001021 	move	v0,zero

9d005504 <__subdf3>:
9d005504:	7cac9800 	ext	t4,a1,0x0,0x14
9d005508:	7ce99800 	ext	t1,a3,0x0,0x14
9d00550c:	7cad07c0 	ext	t5,a1,0x1f,0x1
9d005510:	00067742 	srl	t6,a2,0x1d
9d005514:	000c60c0 	sll	t4,t4,0x3
9d005518:	00044742 	srl	t0,a0,0x1d
9d00551c:	000948c0 	sll	t1,t1,0x3
9d005520:	7ce35500 	ext	v1,a3,0x14,0xb
9d005524:	240207ff 	li	v0,2047
9d005528:	7ca55500 	ext	a1,a1,0x14,0xb
9d00552c:	31ab00ff 	andi	t3,t5,0xff
9d005530:	01886025 	or	t4,t4,t0
9d005534:	000450c0 	sll	t2,a0,0x3
9d005538:	00073fc2 	srl	a3,a3,0x1f
9d00553c:	012e4825 	or	t1,t1,t6
9d005540:	10620014 	beq	v1,v0,9d005594 <__subdf3+0x90>
9d005544:	000630c0 	sll	a2,a2,0x3
9d005548:	38e70001 	xori	a3,a3,0x1
9d00554c:	11670073 	beq	t3,a3,9d00571c <__subdf3+0x218>
9d005550:	00a34023 	subu	t0,a1,v1
9d005554:	190000c4 	blez	t0,9d005868 <__subdf3+0x364>
9d005558:	00000000 	nop
9d00555c:	14600012 	bnez	v1,9d0055a8 <__subdf3+0xa4>
9d005560:	240207ff 	li	v0,2047
9d005564:	01261025 	or	v0,t1,a2
9d005568:	5040009b 	beqzl	v0,9d0057d8 <__subdf3+0x2d4>
9d00556c:	24a80001 	addiu	t0,a1,1
9d005570:	2508ffff 	addiu	t0,t0,-1
9d005574:	550000ae 	bnezl	t0,9d005830 <__subdf3+0x32c>
9d005578:	240207ff 	li	v0,2047
9d00557c:	01462023 	subu	a0,t2,a2
9d005580:	01891023 	subu	v0,t4,t1
9d005584:	0144502b 	sltu	t2,t2,a0
9d005588:	004a1023 	subu	v0,v0,t2
9d00558c:	0b401582 	j	9d005608 <__subdf3+0x104>
9d005590:	00a01821 	move	v1,a1
9d005594:	01261025 	or	v0,t1,a2
9d005598:	5040ffec 	beqzl	v0,9d00554c <__subdf3+0x48>
9d00559c:	38e70001 	xori	a3,a3,0x1
9d0055a0:	0b401553 	j	9d00554c <__subdf3+0x48>
9d0055a4:	00000000 	nop
9d0055a8:	10a200a4 	beq	a1,v0,9d00583c <__subdf3+0x338>
9d0055ac:	314e000f 	andi	t6,t2,0xf
9d0055b0:	3c020080 	lui	v0,0x80
9d0055b4:	01224825 	or	t1,t1,v0
9d0055b8:	29020039 	slti	v0,t0,57
9d0055bc:	104000c9 	beqz	v0,9d0058e4 <__subdf3+0x3e0>
9d0055c0:	01262025 	or	a0,t1,a2
9d0055c4:	29020020 	slti	v0,t0,32
9d0055c8:	104000ec 	beqz	v0,9d00597c <__subdf3+0x478>
9d0055cc:	24040020 	li	a0,32
9d0055d0:	24020020 	li	v0,32
9d0055d4:	00481023 	subu	v0,v0,t0
9d0055d8:	00492004 	sllv	a0,t1,v0
9d0055dc:	01061806 	srlv	v1,a2,t0
9d0055e0:	00463004 	sllv	a2,a2,v0
9d0055e4:	00832025 	or	a0,a0,v1
9d0055e8:	0006302b 	sltu	a2,zero,a2
9d0055ec:	00862025 	or	a0,a0,a2
9d0055f0:	01091006 	srlv	v0,t1,t0
9d0055f4:	01442023 	subu	a0,t2,a0
9d0055f8:	01821023 	subu	v0,t4,v0
9d0055fc:	0144502b 	sltu	t2,t2,a0
9d005600:	004a1023 	subu	v0,v0,t2
9d005604:	00a01821 	move	v1,a1
9d005608:	7c4505c0 	ext	a1,v0,0x17,0x1
9d00560c:	10a00093 	beqz	a1,9d00585c <__subdf3+0x358>
9d005610:	7c48b000 	ext	t0,v0,0x0,0x17
9d005614:	15000003 	bnez	t0,9d005624 <__subdf3+0x120>
9d005618:	71021020 	clz	v0,t0
9d00561c:	70821020 	clz	v0,a0
9d005620:	24420020 	addiu	v0,v0,32
9d005624:	2445fff8 	addiu	a1,v0,-8
9d005628:	28a60020 	slti	a2,a1,32
9d00562c:	10c000aa 	beqz	a2,9d0058d8 <__subdf3+0x3d4>
9d005630:	2442ffd8 	addiu	v0,v0,-40
9d005634:	00051023 	negu	v0,a1
9d005638:	00441006 	srlv	v0,a0,v0
9d00563c:	00a84004 	sllv	t0,t0,a1
9d005640:	00484025 	or	t0,v0,t0
9d005644:	00a42004 	sllv	a0,a0,a1
9d005648:	00a3102a 	slt	v0,a1,v1
9d00564c:	14400080 	bnez	v0,9d005850 <__subdf3+0x34c>
9d005650:	3c02ff7f 	lui	v0,0xff7f
9d005654:	00a31823 	subu	v1,a1,v1
9d005658:	24630001 	addiu	v1,v1,1
9d00565c:	28620020 	slti	v0,v1,32
9d005660:	104000b9 	beqz	v0,9d005948 <__subdf3+0x444>
9d005664:	24050020 	li	a1,32
9d005668:	24020020 	li	v0,32
9d00566c:	00431023 	subu	v0,v0,v1
9d005670:	00642806 	srlv	a1,a0,v1
9d005674:	00442004 	sllv	a0,a0,v0
9d005678:	00481004 	sllv	v0,t0,v0
9d00567c:	00a21025 	or	v0,a1,v0
9d005680:	0004202b 	sltu	a0,zero,a0
9d005684:	00442025 	or	a0,v0,a0
9d005688:	00681006 	srlv	v0,t0,v1
9d00568c:	308e000f 	andi	t6,a0,0xf
9d005690:	24080001 	li	t0,1
9d005694:	00001821 	move	v1,zero
9d005698:	24050004 	li	a1,4
9d00569c:	51c50055 	beql	t6,a1,9d0057f4 <__subdf3+0x2f0>
9d0056a0:	316b0001 	andi	t3,t3,0x1
9d0056a4:	24850004 	addiu	a1,a0,4
9d0056a8:	00a4202b 	sltu	a0,a1,a0
9d0056ac:	00441021 	addu	v0,v0,a0
9d0056b0:	24680001 	addiu	t0,v1,1
9d0056b4:	316b0001 	andi	t3,t3,0x1
9d0056b8:	7c4405c0 	ext	a0,v0,0x17,0x1
9d0056bc:	50800009 	beqzl	a0,9d0056e4 <__subdf3+0x1e0>
9d0056c0:	310807ff 	andi	t0,t0,0x7ff
9d0056c4:	240307ff 	li	v1,2047
9d0056c8:	1103007a 	beq	t0,v1,9d0058b4 <__subdf3+0x3b0>
9d0056cc:	3c04ff7f 	lui	a0,0xff7f
9d0056d0:	3484ffff 	ori	a0,a0,0xffff
9d0056d4:	01001821 	move	v1,t0
9d0056d8:	00441024 	and	v0,v0,a0
9d0056dc:	25080001 	addiu	t0,t0,1
9d0056e0:	310807ff 	andi	t0,t0,0x7ff
9d0056e4:	00023740 	sll	a2,v0,0x1d
9d0056e8:	000528c2 	srl	a1,a1,0x3
9d0056ec:	29080002 	slti	t0,t0,2
9d0056f0:	00c53025 	or	a2,a2,a1
9d0056f4:	15000031 	bnez	t0,9d0057bc <__subdf3+0x2b8>
9d0056f8:	000210c2 	srl	v0,v0,0x3
9d0056fc:	7c429800 	ext	v0,v0,0x0,0x14
9d005700:	306807ff 	andi	t0,v1,0x7ff
9d005704:	00001821 	move	v1,zero
9d005708:	7c439804 	ins	v1,v0,0x0,0x14
9d00570c:	7d03f504 	ins	v1,t0,0x14,0xb
9d005710:	7d63ffc4 	ins	v1,t3,0x1f,0x1
9d005714:	03e00008 	jr	ra
9d005718:	00c01021 	move	v0,a2
9d00571c:	00a31023 	subu	v0,a1,v1
9d005720:	18400076 	blez	v0,9d0058fc <__subdf3+0x3f8>
9d005724:	00000000 	nop
9d005728:	10600034 	beqz	v1,9d0057fc <__subdf3+0x2f8>
9d00572c:	01261825 	or	v1,t1,a2
9d005730:	240307ff 	li	v1,2047
9d005734:	10a3003a 	beq	a1,v1,9d005820 <__subdf3+0x31c>
9d005738:	314e000f 	andi	t6,t2,0xf
9d00573c:	3c030080 	lui	v1,0x80
9d005740:	01234825 	or	t1,t1,v1
9d005744:	28430039 	slti	v1,v0,57
9d005748:	146000ba 	bnez	v1,9d005a34 <__subdf3+0x530>
9d00574c:	28430020 	slti	v1,v0,32
9d005750:	01262025 	or	a0,t1,a2
9d005754:	00001021 	move	v0,zero
9d005758:	0004202b 	sltu	a0,zero,a0
9d00575c:	008a2021 	addu	a0,a0,t2
9d005760:	004c1021 	addu	v0,v0,t4
9d005764:	008a502b 	sltu	t2,a0,t2
9d005768:	004a1021 	addu	v0,v0,t2
9d00576c:	00a01821 	move	v1,a1
9d005770:	7c4505c0 	ext	a1,v0,0x17,0x1
9d005774:	10a0003a 	beqz	a1,9d005860 <__subdf3+0x35c>
9d005778:	24680001 	addiu	t0,v1,1
9d00577c:	24630001 	addiu	v1,v1,1
9d005780:	240507ff 	li	a1,2047
9d005784:	506500dd 	beql	v1,a1,9d005afc <__subdf3+0x5f8>
9d005788:	31ab0001 	andi	t3,t5,0x1
9d00578c:	3c05ff7f 	lui	a1,0xff7f
9d005790:	34a5ffff 	ori	a1,a1,0xffff
9d005794:	00451024 	and	v0,v0,a1
9d005798:	30850001 	andi	a1,a0,0x1
9d00579c:	00042042 	srl	a0,a0,0x1
9d0057a0:	00a42025 	or	a0,a1,a0
9d0057a4:	00022fc0 	sll	a1,v0,0x1f
9d0057a8:	00852025 	or	a0,a0,a1
9d0057ac:	00021042 	srl	v0,v0,0x1
9d0057b0:	24680001 	addiu	t0,v1,1
9d0057b4:	0b4015a6 	j	9d005698 <__subdf3+0x194>
9d0057b8:	308e000f 	andi	t6,a0,0xf
9d0057bc:	00c22025 	or	a0,a2,v0
9d0057c0:	1080017b 	beqz	a0,9d005db0 <__subdf3+0x8ac>
9d0057c4:	306807ff 	andi	t0,v1,0x7ff
9d0057c8:	10600049 	beqz	v1,9d0058f0 <__subdf3+0x3ec>
9d0057cc:	3c040008 	lui	a0,0x8
9d0057d0:	0b4015bf 	j	9d0056fc <__subdf3+0x1f8>
9d0057d4:	00441025 	or	v0,v0,a0
9d0057d8:	00a01821 	move	v1,a1
9d0057dc:	314e000f 	andi	t6,t2,0xf
9d0057e0:	24050004 	li	a1,4
9d0057e4:	01801021 	move	v0,t4
9d0057e8:	15c5ffae 	bne	t6,a1,9d0056a4 <__subdf3+0x1a0>
9d0057ec:	01402021 	move	a0,t2
9d0057f0:	316b0001 	andi	t3,t3,0x1
9d0057f4:	0b4015ae 	j	9d0056b8 <__subdf3+0x1b4>
9d0057f8:	00802821 	move	a1,a0
9d0057fc:	1060fff6 	beqz	v1,9d0057d8 <__subdf3+0x2d4>
9d005800:	24a80001 	addiu	t0,a1,1
9d005804:	2442ffff 	addiu	v0,v0,-1
9d005808:	1040009f 	beqz	v0,9d005a88 <__subdf3+0x584>
9d00580c:	00ca2021 	addu	a0,a2,t2
9d005810:	240307ff 	li	v1,2047
9d005814:	54a3ffcc 	bnel	a1,v1,9d005748 <__subdf3+0x244>
9d005818:	28430039 	slti	v1,v0,57
9d00581c:	314e000f 	andi	t6,t2,0xf
9d005820:	01801021 	move	v0,t4
9d005824:	01402021 	move	a0,t2
9d005828:	0b4015a6 	j	9d005698 <__subdf3+0x194>
9d00582c:	24080800 	li	t0,2048
9d005830:	54a2ff62 	bnel	a1,v0,9d0055bc <__subdf3+0xb8>
9d005834:	29020039 	slti	v0,t0,57
9d005838:	314e000f 	andi	t6,t2,0xf
9d00583c:	01801021 	move	v0,t4
9d005840:	01402021 	move	a0,t2
9d005844:	24080800 	li	t0,2048
9d005848:	0b4015a6 	j	9d005698 <__subdf3+0x194>
9d00584c:	240307ff 	li	v1,2047
9d005850:	3442ffff 	ori	v0,v0,0xffff
9d005854:	00651823 	subu	v1,v1,a1
9d005858:	01021024 	and	v0,t0,v0
9d00585c:	24680001 	addiu	t0,v1,1
9d005860:	0b4015a6 	j	9d005698 <__subdf3+0x194>
9d005864:	308e000f 	andi	t6,a0,0xf
9d005868:	1500004e 	bnez	t0,9d0059a4 <__subdf3+0x4a0>
9d00586c:	24a20001 	addiu	v0,a1,1
9d005870:	304207ff 	andi	v0,v0,0x7ff
9d005874:	28420002 	slti	v0,v0,2
9d005878:	14400092 	bnez	v0,9d005ac4 <__subdf3+0x5c0>
9d00587c:	01462023 	subu	a0,t2,a2
9d005880:	0144102b 	sltu	v0,t2,a0
9d005884:	01894023 	subu	t0,t4,t1
9d005888:	01024023 	subu	t0,t0,v0
9d00588c:	7d0205c0 	ext	v0,t0,0x17,0x1
9d005890:	10400060 	beqz	v0,9d005a14 <__subdf3+0x510>
9d005894:	01041025 	or	v0,t0,a0
9d005898:	00ca2023 	subu	a0,a2,t2
9d00589c:	012c4823 	subu	t1,t1,t4
9d0058a0:	00c4302b 	sltu	a2,a2,a0
9d0058a4:	01264023 	subu	t0,t1,a2
9d0058a8:	00a01821 	move	v1,a1
9d0058ac:	0b401585 	j	9d005614 <__subdf3+0x110>
9d0058b0:	00e05821 	move	t3,a3
9d0058b4:	00001021 	move	v0,zero
9d0058b8:	00001821 	move	v1,zero
9d0058bc:	240807ff 	li	t0,2047
9d0058c0:	7c439804 	ins	v1,v0,0x0,0x14
9d0058c4:	00003021 	move	a2,zero
9d0058c8:	7d03f504 	ins	v1,t0,0x14,0xb
9d0058cc:	7d63ffc4 	ins	v1,t3,0x1f,0x1
9d0058d0:	03e00008 	jr	ra
9d0058d4:	00c01021 	move	v0,a2
9d0058d8:	00444004 	sllv	t0,a0,v0
9d0058dc:	0b401592 	j	9d005648 <__subdf3+0x144>
9d0058e0:	00002021 	move	a0,zero
9d0058e4:	00001021 	move	v0,zero
9d0058e8:	0b40157d 	j	9d0055f4 <__subdf3+0xf0>
9d0058ec:	0004202b 	sltu	a0,zero,a0
9d0058f0:	7c429800 	ext	v0,v0,0x0,0x14
9d0058f4:	0b4015c1 	j	9d005704 <__subdf3+0x200>
9d0058f8:	00004021 	move	t0,zero
9d0058fc:	1440008d 	bnez	v0,9d005b34 <__subdf3+0x630>
9d005900:	00000000 	nop
9d005904:	24a30001 	addiu	v1,a1,1
9d005908:	306207ff 	andi	v0,v1,0x7ff
9d00590c:	28420002 	slti	v0,v0,2
9d005910:	14400062 	bnez	v0,9d005a9c <__subdf3+0x598>
9d005914:	240207ff 	li	v0,2047
9d005918:	10620077 	beq	v1,v0,9d005af8 <__subdf3+0x5f4>
9d00591c:	00ca3021 	addu	a2,a2,t2
9d005920:	00ca502b 	sltu	t2,a2,t2
9d005924:	012c1021 	addu	v0,t1,t4
9d005928:	004a1021 	addu	v0,v0,t2
9d00592c:	00023fc0 	sll	a3,v0,0x1f
9d005930:	00063042 	srl	a2,a2,0x1
9d005934:	00c72025 	or	a0,a2,a3
9d005938:	00021042 	srl	v0,v0,0x1
9d00593c:	24a80002 	addiu	t0,a1,2
9d005940:	0b4015a6 	j	9d005698 <__subdf3+0x194>
9d005944:	308e000f 	andi	t6,a0,0xf
9d005948:	00683006 	srlv	a2,t0,v1
9d00594c:	10650003 	beq	v1,a1,9d00595c <__subdf3+0x458>
9d005950:	00001021 	move	v0,zero
9d005954:	00031023 	negu	v0,v1
9d005958:	00481004 	sllv	v0,t0,v0
9d00595c:	00442025 	or	a0,v0,a0
9d005960:	0004202b 	sltu	a0,zero,a0
9d005964:	00862025 	or	a0,a0,a2
9d005968:	308e000f 	andi	t6,a0,0xf
9d00596c:	24080001 	li	t0,1
9d005970:	00001021 	move	v0,zero
9d005974:	0b4015a6 	j	9d005698 <__subdf3+0x194>
9d005978:	00001821 	move	v1,zero
9d00597c:	01091806 	srlv	v1,t1,t0
9d005980:	11040003 	beq	t0,a0,9d005990 <__subdf3+0x48c>
9d005984:	00001021 	move	v0,zero
9d005988:	00084023 	negu	t0,t0
9d00598c:	01091004 	sllv	v0,t1,t0
9d005990:	00462025 	or	a0,v0,a2
9d005994:	0004202b 	sltu	a0,zero,a0
9d005998:	00832025 	or	a0,a0,v1
9d00599c:	0b40157d 	j	9d0055f4 <__subdf3+0xf0>
9d0059a0:	00001021 	move	v0,zero
9d0059a4:	10a0002f 	beqz	a1,9d005a64 <__subdf3+0x560>
9d0059a8:	00084023 	negu	t0,t0
9d0059ac:	240207ff 	li	v0,2047
9d0059b0:	10620079 	beq	v1,v0,9d005b98 <__subdf3+0x694>
9d0059b4:	30ce000f 	andi	t6,a2,0xf
9d0059b8:	3c020080 	lui	v0,0x80
9d0059bc:	01826025 	or	t4,t4,v0
9d0059c0:	29020039 	slti	v0,t0,57
9d0059c4:	10400095 	beqz	v0,9d005c1c <__subdf3+0x718>
9d0059c8:	018a2025 	or	a0,t4,t2
9d0059cc:	29020020 	slti	v0,t0,32
9d0059d0:	504000cd 	beqzl	v0,9d005d08 <__subdf3+0x804>
9d0059d4:	24040020 	li	a0,32
9d0059d8:	24020020 	li	v0,32
9d0059dc:	00481023 	subu	v0,v0,t0
9d0059e0:	004c2804 	sllv	a1,t4,v0
9d0059e4:	010a2006 	srlv	a0,t2,t0
9d0059e8:	004a1004 	sllv	v0,t2,v0
9d0059ec:	0002102b 	sltu	v0,zero,v0
9d0059f0:	00a42025 	or	a0,a1,a0
9d0059f4:	00822025 	or	a0,a0,v0
9d0059f8:	010c1006 	srlv	v0,t4,t0
9d0059fc:	00c42023 	subu	a0,a2,a0
9d005a00:	01221023 	subu	v0,t1,v0
9d005a04:	00c4302b 	sltu	a2,a2,a0
9d005a08:	00461023 	subu	v0,v0,a2
9d005a0c:	0b401582 	j	9d005608 <__subdf3+0x104>
9d005a10:	00e05821 	move	t3,a3
9d005a14:	1440feff 	bnez	v0,9d005614 <__subdf3+0x110>
9d005a18:	00a01821 	move	v1,a1
9d005a1c:	00005821 	move	t3,zero
9d005a20:	24080001 	li	t0,1
9d005a24:	00001021 	move	v0,zero
9d005a28:	24050004 	li	a1,4
9d005a2c:	0b4015ae 	j	9d0056b8 <__subdf3+0x1b4>
9d005a30:	00001821 	move	v1,zero
9d005a34:	50600035 	beqzl	v1,9d005b0c <__subdf3+0x608>
9d005a38:	24040020 	li	a0,32
9d005a3c:	24030020 	li	v1,32
9d005a40:	00621823 	subu	v1,v1,v0
9d005a44:	00693804 	sllv	a3,t1,v1
9d005a48:	00462006 	srlv	a0,a2,v0
9d005a4c:	00661804 	sllv	v1,a2,v1
9d005a50:	00e42025 	or	a0,a3,a0
9d005a54:	0003182b 	sltu	v1,zero,v1
9d005a58:	00832025 	or	a0,a0,v1
9d005a5c:	0b4015d7 	j	9d00575c <__subdf3+0x258>
9d005a60:	00491006 	srlv	v0,t1,v0
9d005a64:	018a1025 	or	v0,t4,t2
9d005a68:	54400064 	bnezl	v0,9d005bfc <__subdf3+0x6f8>
9d005a6c:	2508ffff 	addiu	t0,t0,-1
9d005a70:	24680001 	addiu	t0,v1,1
9d005a74:	30ce000f 	andi	t6,a2,0xf
9d005a78:	01201021 	move	v0,t1
9d005a7c:	00c02021 	move	a0,a2
9d005a80:	0b4015a6 	j	9d005698 <__subdf3+0x194>
9d005a84:	00e05821 	move	t3,a3
9d005a88:	012c1021 	addu	v0,t1,t4
9d005a8c:	008a502b 	sltu	t2,a0,t2
9d005a90:	004a1021 	addu	v0,v0,t2
9d005a94:	0b4015dc 	j	9d005770 <__subdf3+0x26c>
9d005a98:	00a01821 	move	v1,a1
9d005a9c:	14a0008d 	bnez	a1,9d005cd4 <__subdf3+0x7d0>
9d005aa0:	018a1025 	or	v0,t4,t2
9d005aa4:	544000ac 	bnezl	v0,9d005d58 <__subdf3+0x854>
9d005aa8:	01261025 	or	v0,t1,a2
9d005aac:	30ce000f 	andi	t6,a2,0xf
9d005ab0:	01201021 	move	v0,t1
9d005ab4:	00c02021 	move	a0,a2
9d005ab8:	24080001 	li	t0,1
9d005abc:	0b4015a6 	j	9d005698 <__subdf3+0x194>
9d005ac0:	00001821 	move	v1,zero
9d005ac4:	14a00025 	bnez	a1,9d005b5c <__subdf3+0x658>
9d005ac8:	018a1025 	or	v0,t4,t2
9d005acc:	1440006f 	bnez	v0,9d005c8c <__subdf3+0x788>
9d005ad0:	01261025 	or	v0,t1,a2
9d005ad4:	5040ffd2 	beqzl	v0,9d005a20 <__subdf3+0x51c>
9d005ad8:	00005821 	move	t3,zero
9d005adc:	30ce000f 	andi	t6,a2,0xf
9d005ae0:	01201021 	move	v0,t1
9d005ae4:	00c02021 	move	a0,a2
9d005ae8:	00e05821 	move	t3,a3
9d005aec:	24080001 	li	t0,1
9d005af0:	0b4015a6 	j	9d005698 <__subdf3+0x194>
9d005af4:	00001821 	move	v1,zero
9d005af8:	31ab0001 	andi	t3,t5,0x1
9d005afc:	24080800 	li	t0,2048
9d005b00:	00001021 	move	v0,zero
9d005b04:	0b4015ae 	j	9d0056b8 <__subdf3+0x1b4>
9d005b08:	24050004 	li	a1,4
9d005b0c:	00493806 	srlv	a3,t1,v0
9d005b10:	10440003 	beq	v0,a0,9d005b20 <__subdf3+0x61c>
9d005b14:	00001821 	move	v1,zero
9d005b18:	00021023 	negu	v0,v0
9d005b1c:	00491804 	sllv	v1,t1,v0
9d005b20:	00662025 	or	a0,v1,a2
9d005b24:	0004202b 	sltu	a0,zero,a0
9d005b28:	00872025 	or	a0,a0,a3
9d005b2c:	0b4015d7 	j	9d00575c <__subdf3+0x258>
9d005b30:	00001021 	move	v0,zero
9d005b34:	14a0003c 	bnez	a1,9d005c28 <__subdf3+0x724>
9d005b38:	00021023 	negu	v0,v0
9d005b3c:	018a2025 	or	a0,t4,t2
9d005b40:	5480007b 	bnezl	a0,9d005d30 <__subdf3+0x82c>
9d005b44:	2442ffff 	addiu	v0,v0,-1
9d005b48:	24680001 	addiu	t0,v1,1
9d005b4c:	30ce000f 	andi	t6,a2,0xf
9d005b50:	01201021 	move	v0,t1
9d005b54:	0b4015a6 	j	9d005698 <__subdf3+0x194>
9d005b58:	00c02021 	move	a0,a2
9d005b5c:	54400014 	bnezl	v0,9d005bb0 <__subdf3+0x6ac>
9d005b60:	01263025 	or	a2,t1,a2
9d005b64:	01261025 	or	v0,t1,a2
9d005b68:	1440000b 	bnez	v0,9d005b98 <__subdf3+0x694>
9d005b6c:	30ce000f 	andi	t6,a2,0xf
9d005b70:	3c02007f 	lui	v0,0x7f
9d005b74:	00005821 	move	t3,zero
9d005b78:	24080800 	li	t0,2048
9d005b7c:	3442ffff 	ori	v0,v0,0xffff
9d005b80:	2405fffc 	li	a1,-4
9d005b84:	0b4015ae 	j	9d0056b8 <__subdf3+0x1b4>
9d005b88:	240307ff 	li	v1,2047
9d005b8c:	5462ff8d 	bnel	v1,v0,9d0059c4 <__subdf3+0x4c0>
9d005b90:	29020039 	slti	v0,t0,57
9d005b94:	30ce000f 	andi	t6,a2,0xf
9d005b98:	01201021 	move	v0,t1
9d005b9c:	00c02021 	move	a0,a2
9d005ba0:	00e05821 	move	t3,a3
9d005ba4:	24080800 	li	t0,2048
9d005ba8:	0b4015a6 	j	9d005698 <__subdf3+0x194>
9d005bac:	240307ff 	li	v1,2047
9d005bb0:	10c0ff22 	beqz	a2,9d00583c <__subdf3+0x338>
9d005bb4:	314e000f 	andi	t6,t2,0xf
9d005bb8:	000c18c2 	srl	v1,t4,0x3
9d005bbc:	000910c2 	srl	v0,t1,0x3
9d005bc0:	00431025 	or	v0,v0,v1
9d005bc4:	7c4204c0 	ext	v0,v0,0x13,0x1
9d005bc8:	54400072 	bnezl	v0,9d005d94 <__subdf3+0x890>
9d005bcc:	3c02007f 	lui	v0,0x7f
9d005bd0:	000a50c2 	srl	t2,t2,0x3
9d005bd4:	000c2740 	sll	a0,t4,0x1d
9d005bd8:	008a2025 	or	a0,a0,t2
9d005bdc:	00041742 	srl	v0,a0,0x1d
9d005be0:	000318c0 	sll	v1,v1,0x3
9d005be4:	000420c0 	sll	a0,a0,0x3
9d005be8:	00431025 	or	v0,v0,v1
9d005bec:	308e000f 	andi	t6,a0,0xf
9d005bf0:	24080800 	li	t0,2048
9d005bf4:	0b4015a6 	j	9d005698 <__subdf3+0x194>
9d005bf8:	240307ff 	li	v1,2047
9d005bfc:	5500ffe3 	bnezl	t0,9d005b8c <__subdf3+0x688>
9d005c00:	240207ff 	li	v0,2047
9d005c04:	00ca2023 	subu	a0,a2,t2
9d005c08:	012c1023 	subu	v0,t1,t4
9d005c0c:	00c4302b 	sltu	a2,a2,a0
9d005c10:	00461023 	subu	v0,v0,a2
9d005c14:	0b401582 	j	9d005608 <__subdf3+0x104>
9d005c18:	00e05821 	move	t3,a3
9d005c1c:	00001021 	move	v0,zero
9d005c20:	0b40167f 	j	9d0059fc <__subdf3+0x4f8>
9d005c24:	0004202b 	sltu	a0,zero,a0
9d005c28:	240407ff 	li	a0,2047
9d005c2c:	1064002c 	beq	v1,a0,9d005ce0 <__subdf3+0x7dc>
9d005c30:	30ce000f 	andi	t6,a2,0xf
9d005c34:	3c040080 	lui	a0,0x80
9d005c38:	01846025 	or	t4,t4,a0
9d005c3c:	28440039 	slti	a0,v0,57
9d005c40:	10800042 	beqz	a0,9d005d4c <__subdf3+0x848>
9d005c44:	018a2025 	or	a0,t4,t2
9d005c48:	28440020 	slti	a0,v0,32
9d005c4c:	50800063 	beqzl	a0,9d005ddc <__subdf3+0x8d8>
9d005c50:	24040020 	li	a0,32
9d005c54:	24050020 	li	a1,32
9d005c58:	00a22823 	subu	a1,a1,v0
9d005c5c:	00ac3804 	sllv	a3,t4,a1
9d005c60:	004a2006 	srlv	a0,t2,v0
9d005c64:	00aa2804 	sllv	a1,t2,a1
9d005c68:	00e42025 	or	a0,a3,a0
9d005c6c:	0005282b 	sltu	a1,zero,a1
9d005c70:	00852025 	or	a0,a0,a1
9d005c74:	004c1006 	srlv	v0,t4,v0
9d005c78:	00862021 	addu	a0,a0,a2
9d005c7c:	00491021 	addu	v0,v0,t1
9d005c80:	0086302b 	sltu	a2,a0,a2
9d005c84:	0b4015dc 	j	9d005770 <__subdf3+0x26c>
9d005c88:	00461021 	addu	v0,v0,a2
9d005c8c:	10400019 	beqz	v0,9d005cf4 <__subdf3+0x7f0>
9d005c90:	314e000f 	andi	t6,t2,0xf
9d005c94:	01462023 	subu	a0,t2,a2
9d005c98:	01891823 	subu	v1,t4,t1
9d005c9c:	0144102b 	sltu	v0,t2,a0
9d005ca0:	00621023 	subu	v0,v1,v0
9d005ca4:	7c4305c0 	ext	v1,v0,0x17,0x1
9d005ca8:	50600048 	beqzl	v1,9d005dcc <__subdf3+0x8c8>
9d005cac:	00441825 	or	v1,v0,a0
9d005cb0:	00ca2023 	subu	a0,a2,t2
9d005cb4:	012c1023 	subu	v0,t1,t4
9d005cb8:	00c4302b 	sltu	a2,a2,a0
9d005cbc:	00461023 	subu	v0,v0,a2
9d005cc0:	308e000f 	andi	t6,a0,0xf
9d005cc4:	00e05821 	move	t3,a3
9d005cc8:	24080001 	li	t0,1
9d005ccc:	0b4015a6 	j	9d005698 <__subdf3+0x194>
9d005cd0:	00001821 	move	v1,zero
9d005cd4:	5440ffb6 	bnezl	v0,9d005bb0 <__subdf3+0x6ac>
9d005cd8:	01263025 	or	a2,t1,a2
9d005cdc:	30ce000f 	andi	t6,a2,0xf
9d005ce0:	01201021 	move	v0,t1
9d005ce4:	00c02021 	move	a0,a2
9d005ce8:	24080800 	li	t0,2048
9d005cec:	0b4015a6 	j	9d005698 <__subdf3+0x194>
9d005cf0:	240307ff 	li	v1,2047
9d005cf4:	01801021 	move	v0,t4
9d005cf8:	01402021 	move	a0,t2
9d005cfc:	24080001 	li	t0,1
9d005d00:	0b4015a6 	j	9d005698 <__subdf3+0x194>
9d005d04:	00001821 	move	v1,zero
9d005d08:	010c2806 	srlv	a1,t4,t0
9d005d0c:	11040003 	beq	t0,a0,9d005d1c <__subdf3+0x818>
9d005d10:	00001021 	move	v0,zero
9d005d14:	00084023 	negu	t0,t0
9d005d18:	010c1004 	sllv	v0,t4,t0
9d005d1c:	004a2025 	or	a0,v0,t2
9d005d20:	0004202b 	sltu	a0,zero,a0
9d005d24:	00852025 	or	a0,a0,a1
9d005d28:	0b40167f 	j	9d0059fc <__subdf3+0x4f8>
9d005d2c:	00001021 	move	v0,zero
9d005d30:	54400022 	bnezl	v0,9d005dbc <__subdf3+0x8b8>
9d005d34:	240407ff 	li	a0,2047
9d005d38:	00ca2021 	addu	a0,a2,t2
9d005d3c:	012c1021 	addu	v0,t1,t4
9d005d40:	0086302b 	sltu	a2,a0,a2
9d005d44:	0b4015dc 	j	9d005770 <__subdf3+0x26c>
9d005d48:	00461021 	addu	v0,v0,a2
9d005d4c:	00001021 	move	v0,zero
9d005d50:	0b40171e 	j	9d005c78 <__subdf3+0x774>
9d005d54:	0004202b 	sltu	a0,zero,a0
9d005d58:	1040ffe6 	beqz	v0,9d005cf4 <__subdf3+0x7f0>
9d005d5c:	314e000f 	andi	t6,t2,0xf
9d005d60:	00ca2021 	addu	a0,a2,t2
9d005d64:	012c1021 	addu	v0,t1,t4
9d005d68:	008a502b 	sltu	t2,a0,t2
9d005d6c:	004a1021 	addu	v0,v0,t2
9d005d70:	7c4305c0 	ext	v1,v0,0x17,0x1
9d005d74:	10600023 	beqz	v1,9d005e04 <__subdf3+0x900>
9d005d78:	308e000f 	andi	t6,a0,0xf
9d005d7c:	3c03ff7f 	lui	v1,0xff7f
9d005d80:	3463ffff 	ori	v1,v1,0xffff
9d005d84:	00431024 	and	v0,v0,v1
9d005d88:	24080002 	li	t0,2
9d005d8c:	0b4015a6 	j	9d005698 <__subdf3+0x194>
9d005d90:	24030001 	li	v1,1
9d005d94:	240e0008 	li	t6,8
9d005d98:	2404fff8 	li	a0,-8
9d005d9c:	3442ffff 	ori	v0,v0,0xffff
9d005da0:	00005821 	move	t3,zero
9d005da4:	24080800 	li	t0,2048
9d005da8:	0b4015a6 	j	9d005698 <__subdf3+0x194>
9d005dac:	240307ff 	li	v1,2047
9d005db0:	00001021 	move	v0,zero
9d005db4:	0b4015c1 	j	9d005704 <__subdf3+0x200>
9d005db8:	00003021 	move	a2,zero
9d005dbc:	5464ffa0 	bnel	v1,a0,9d005c40 <__subdf3+0x73c>
9d005dc0:	28440039 	slti	a0,v0,57
9d005dc4:	0b401738 	j	9d005ce0 <__subdf3+0x7dc>
9d005dc8:	30ce000f 	andi	t6,a2,0xf
9d005dcc:	5060ff14 	beqzl	v1,9d005a20 <__subdf3+0x51c>
9d005dd0:	00005821 	move	t3,zero
9d005dd4:	0b4015a4 	j	9d005690 <__subdf3+0x18c>
9d005dd8:	308e000f 	andi	t6,a0,0xf
9d005ddc:	004c3806 	srlv	a3,t4,v0
9d005de0:	10440003 	beq	v0,a0,9d005df0 <__subdf3+0x8ec>
9d005de4:	00002821 	move	a1,zero
9d005de8:	00021023 	negu	v0,v0
9d005dec:	004c2804 	sllv	a1,t4,v0
9d005df0:	00aa2025 	or	a0,a1,t2
9d005df4:	0004202b 	sltu	a0,zero,a0
9d005df8:	00872025 	or	a0,a0,a3
9d005dfc:	0b40171e 	j	9d005c78 <__subdf3+0x774>
9d005e00:	00001021 	move	v0,zero
9d005e04:	0b4015a6 	j	9d005698 <__subdf3+0x194>
9d005e08:	24080001 	li	t0,1

9d005e0c <__fixdfsi>:
9d005e0c:	7ca35500 	ext	v1,a1,0x14,0xb
9d005e10:	286603ff 	slti	a2,v1,1023
9d005e14:	7ca79800 	ext	a3,a1,0x0,0x14
9d005e18:	00001021 	move	v0,zero
9d005e1c:	14c0000f 	bnez	a2,9d005e5c <__fixdfsi+0x50>
9d005e20:	00052fc2 	srl	a1,a1,0x1f
9d005e24:	2866041e 	slti	a2,v1,1054
9d005e28:	10c0000e 	beqz	a2,9d005e64 <__fixdfsi+0x58>
9d005e2c:	24060433 	li	a2,1075
9d005e30:	00c33023 	subu	a2,a2,v1
9d005e34:	3c020010 	lui	v0,0x10
9d005e38:	28c80020 	slti	t0,a2,32
9d005e3c:	1100000d 	beqz	t0,9d005e74 <__fixdfsi+0x68>
9d005e40:	00e23825 	or	a3,a3,v0
9d005e44:	2463fbed 	addiu	v1,v1,-1043
9d005e48:	00c42006 	srlv	a0,a0,a2
9d005e4c:	00673804 	sllv	a3,a3,v1
9d005e50:	00872025 	or	a0,a0,a3
9d005e54:	00041023 	negu	v0,a0
9d005e58:	0085100a 	movz	v0,a0,a1
9d005e5c:	03e00008 	jr	ra
9d005e60:	00000000 	nop
9d005e64:	3c027fff 	lui	v0,0x7fff
9d005e68:	3442ffff 	ori	v0,v0,0xffff
9d005e6c:	03e00008 	jr	ra
9d005e70:	00a21021 	addu	v0,a1,v0
9d005e74:	24040413 	li	a0,1043
9d005e78:	00832023 	subu	a0,a0,v1
9d005e7c:	00872006 	srlv	a0,a3,a0
9d005e80:	00041023 	negu	v0,a0
9d005e84:	03e00008 	jr	ra
9d005e88:	0085100a 	movz	v0,a0,a1

9d005e8c <__floatsidf>:
9d005e8c:	10800021 	beqz	a0,9d005f14 <__floatsidf+0x88>
9d005e90:	00042fc2 	srl	a1,a0,0x1f
9d005e94:	00041023 	negu	v0,a0
9d005e98:	0045200b 	movn	a0,v0,a1
9d005e9c:	70821020 	clz	v0,a0
9d005ea0:	2403041e 	li	v1,1054
9d005ea4:	00621823 	subu	v1,v1,v0
9d005ea8:	24060433 	li	a2,1075
9d005eac:	00c33023 	subu	a2,a2,v1
9d005eb0:	28c20020 	slti	v0,a2,32
9d005eb4:	5440000d 	bnezl	v0,9d005eec <__floatsidf+0x60>
9d005eb8:	2462fbed 	addiu	v0,v1,-1043
9d005ebc:	24020413 	li	v0,1043
9d005ec0:	00431023 	subu	v0,v0,v1
9d005ec4:	00441004 	sllv	v0,a0,v0
9d005ec8:	306807ff 	andi	t0,v1,0x7ff
9d005ecc:	7c429800 	ext	v0,v0,0x0,0x14
9d005ed0:	00001821 	move	v1,zero
9d005ed4:	7c439804 	ins	v1,v0,0x0,0x14
9d005ed8:	00002021 	move	a0,zero
9d005edc:	7d03f504 	ins	v1,t0,0x14,0xb
9d005ee0:	7ca3ffc4 	ins	v1,a1,0x1f,0x1
9d005ee4:	03e00008 	jr	ra
9d005ee8:	00801021 	move	v0,a0
9d005eec:	00441006 	srlv	v0,a0,v0
9d005ef0:	306807ff 	andi	t0,v1,0x7ff
9d005ef4:	7c429800 	ext	v0,v0,0x0,0x14
9d005ef8:	00001821 	move	v1,zero
9d005efc:	7c439804 	ins	v1,v0,0x0,0x14
9d005f00:	00c42004 	sllv	a0,a0,a2
9d005f04:	7d03f504 	ins	v1,t0,0x14,0xb
9d005f08:	7ca3ffc4 	ins	v1,a1,0x1f,0x1
9d005f0c:	03e00008 	jr	ra
9d005f10:	00801021 	move	v0,a0
9d005f14:	00001021 	move	v0,zero
9d005f18:	00001821 	move	v1,zero
9d005f1c:	00004021 	move	t0,zero
9d005f20:	7c439804 	ins	v1,v0,0x0,0x14
9d005f24:	00002821 	move	a1,zero
9d005f28:	00002021 	move	a0,zero
9d005f2c:	7d03f504 	ins	v1,t0,0x14,0xb
9d005f30:	7ca3ffc4 	ins	v1,a1,0x1f,0x1
9d005f34:	03e00008 	jr	ra
9d005f38:	00801021 	move	v0,a0

9d005f3c <__floatunsidf>:
9d005f3c:	10800021 	beqz	a0,9d005fc4 <__floatunsidf+0x88>
9d005f40:	00003021 	move	a2,zero
9d005f44:	2403041e 	li	v1,1054
9d005f48:	70821020 	clz	v0,a0
9d005f4c:	00621023 	subu	v0,v1,v0
9d005f50:	24030433 	li	v1,1075
9d005f54:	00621823 	subu	v1,v1,v0
9d005f58:	28650020 	slti	a1,v1,32
9d005f5c:	14a0000e 	bnez	a1,9d005f98 <__floatunsidf+0x5c>
9d005f60:	2446fbed 	addiu	a2,v0,-1043
9d005f64:	24060413 	li	a2,1043
9d005f68:	00c23023 	subu	a2,a2,v0
9d005f6c:	00c43004 	sllv	a2,a0,a2
9d005f70:	7cc69800 	ext	a2,a2,0x0,0x14
9d005f74:	00002821 	move	a1,zero
9d005f78:	304707ff 	andi	a3,v0,0x7ff
9d005f7c:	7cc59804 	ins	a1,a2,0x0,0x14
9d005f80:	7ce5f504 	ins	a1,a3,0x14,0xb
9d005f84:	00002021 	move	a0,zero
9d005f88:	7ca5f000 	ext	a1,a1,0x0,0x1f
9d005f8c:	00801021 	move	v0,a0
9d005f90:	03e00008 	jr	ra
9d005f94:	00a01821 	move	v1,a1
9d005f98:	00c43006 	srlv	a2,a0,a2
9d005f9c:	7cc69800 	ext	a2,a2,0x0,0x14
9d005fa0:	00002821 	move	a1,zero
9d005fa4:	304707ff 	andi	a3,v0,0x7ff
9d005fa8:	7cc59804 	ins	a1,a2,0x0,0x14
9d005fac:	7ce5f504 	ins	a1,a3,0x14,0xb
9d005fb0:	00642004 	sllv	a0,a0,v1
9d005fb4:	7ca5f000 	ext	a1,a1,0x0,0x1f
9d005fb8:	00801021 	move	v0,a0
9d005fbc:	03e00008 	jr	ra
9d005fc0:	00a01821 	move	v1,a1
9d005fc4:	00002821 	move	a1,zero
9d005fc8:	00003821 	move	a3,zero
9d005fcc:	7cc59804 	ins	a1,a2,0x0,0x14
9d005fd0:	7ce5f504 	ins	a1,a3,0x14,0xb
9d005fd4:	00002021 	move	a0,zero
9d005fd8:	7ca5f000 	ext	a1,a1,0x0,0x1f
9d005fdc:	00801021 	move	v0,a0
9d005fe0:	03e00008 	jr	ra
9d005fe4:	00a01821 	move	v1,a1

9d005fe8 <__extendsfdf2>:
9d005fe8:	7c833dc0 	ext	v1,a0,0x17,0x8
9d005fec:	24650001 	addiu	a1,v1,1
9d005ff0:	30a500ff 	andi	a1,a1,0xff
9d005ff4:	28a50002 	slti	a1,a1,2
9d005ff8:	7c82b000 	ext	v0,a0,0x0,0x17
9d005ffc:	14a0000a 	bnez	a1,9d006028 <__extendsfdf2+0x40>
9d006000:	000427c2 	srl	a0,a0,0x1f
9d006004:	00024f40 	sll	t1,v0,0x1d
9d006008:	000240c2 	srl	t0,v0,0x3
9d00600c:	24650380 	addiu	a1,v1,896
9d006010:	00001821 	move	v1,zero
9d006014:	7d039804 	ins	v1,t0,0x0,0x14
9d006018:	7ca3f504 	ins	v1,a1,0x14,0xb
9d00601c:	7c83ffc4 	ins	v1,a0,0x1f,0x1
9d006020:	03e00008 	jr	ra
9d006024:	01201021 	move	v0,t1
9d006028:	14600016 	bnez	v1,9d006084 <__extendsfdf2+0x9c>
9d00602c:	00000000 	nop
9d006030:	10400021 	beqz	v0,9d0060b8 <__extendsfdf2+0xd0>
9d006034:	00002821 	move	a1,zero
9d006038:	70431820 	clz	v1,v0
9d00603c:	2865000b 	slti	a1,v1,11
9d006040:	10a00020 	beqz	a1,9d0060c4 <__extendsfdf2+0xdc>
9d006044:	2468fff5 	addiu	t0,v1,-11
9d006048:	2408000b 	li	t0,11
9d00604c:	01034023 	subu	t0,t0,v1
9d006050:	24690015 	addiu	t1,v1,21
9d006054:	01024006 	srlv	t0,v0,t0
9d006058:	01224804 	sllv	t1,v0,t1
9d00605c:	24050389 	li	a1,905
9d006060:	00a31823 	subu	v1,a1,v1
9d006064:	306507ff 	andi	a1,v1,0x7ff
9d006068:	7d089800 	ext	t0,t0,0x0,0x14
9d00606c:	00001821 	move	v1,zero
9d006070:	7d039804 	ins	v1,t0,0x0,0x14
9d006074:	7ca3f504 	ins	v1,a1,0x14,0xb
9d006078:	7c83ffc4 	ins	v1,a0,0x1f,0x1
9d00607c:	03e00008 	jr	ra
9d006080:	01201021 	move	v0,t1
9d006084:	10400009 	beqz	v0,9d0060ac <__extendsfdf2+0xc4>
9d006088:	240507ff 	li	a1,2047
9d00608c:	000240c2 	srl	t0,v0,0x3
9d006090:	00001821 	move	v1,zero
9d006094:	7d039804 	ins	v1,t0,0x0,0x14
9d006098:	00024f40 	sll	t1,v0,0x1d
9d00609c:	7ca3f504 	ins	v1,a1,0x14,0xb
9d0060a0:	7c83ffc4 	ins	v1,a0,0x1f,0x1
9d0060a4:	03e00008 	jr	ra
9d0060a8:	01201021 	move	v0,t1
9d0060ac:	00004021 	move	t0,zero
9d0060b0:	0b401804 	j	9d006010 <__extendsfdf2+0x28>
9d0060b4:	00004821 	move	t1,zero
9d0060b8:	00004021 	move	t0,zero
9d0060bc:	0b401804 	j	9d006010 <__extendsfdf2+0x28>
9d0060c0:	00004821 	move	t1,zero
9d0060c4:	01024004 	sllv	t0,v0,t0
9d0060c8:	0b401817 	j	9d00605c <__extendsfdf2+0x74>
9d0060cc:	00004821 	move	t1,zero

9d0060d0 <__truncdfsf2>:
9d0060d0:	7ca25500 	ext	v0,a1,0x14,0xb
9d0060d4:	24430001 	addiu	v1,v0,1
9d0060d8:	7ca79800 	ext	a3,a1,0x0,0x14
9d0060dc:	306307ff 	andi	v1,v1,0x7ff
9d0060e0:	000738c0 	sll	a3,a3,0x3
9d0060e4:	00043742 	srl	a2,a0,0x1d
9d0060e8:	28630002 	slti	v1,v1,2
9d0060ec:	00052fc2 	srl	a1,a1,0x1f
9d0060f0:	00e63025 	or	a2,a3,a2
9d0060f4:	14600034 	bnez	v1,9d0061c8 <__truncdfsf2+0xf8>
9d0060f8:	000440c0 	sll	t0,a0,0x3
9d0060fc:	2443fc80 	addiu	v1,v0,-896
9d006100:	286700ff 	slti	a3,v1,255
9d006104:	14e00019 	bnez	a3,9d00616c <__truncdfsf2+0x9c>
9d006108:	00000000 	nop
9d00610c:	24020100 	li	v0,256
9d006110:	24040004 	li	a0,4
9d006114:	240300ff 	li	v1,255
9d006118:	7c860680 	ext	a2,a0,0x1a,0x1
9d00611c:	50c00009 	beqzl	a2,9d006144 <__truncdfsf2+0x74>
9d006120:	304200ff 	andi	v0,v0,0xff
9d006124:	240300ff 	li	v1,255
9d006128:	10430038 	beq	v0,v1,9d00620c <__truncdfsf2+0x13c>
9d00612c:	3c06fbff 	lui	a2,0xfbff
9d006130:	34c6ffff 	ori	a2,a2,0xffff
9d006134:	00401821 	move	v1,v0
9d006138:	00862024 	and	a0,a0,a2
9d00613c:	24420001 	addiu	v0,v0,1
9d006140:	304200ff 	andi	v0,v0,0xff
9d006144:	28420002 	slti	v0,v0,2
9d006148:	14400017 	bnez	v0,9d0061a8 <__truncdfsf2+0xd8>
9d00614c:	000420c2 	srl	a0,a0,0x3
9d006150:	7c84b000 	ext	a0,a0,0x0,0x17
9d006154:	306300ff 	andi	v1,v1,0xff
9d006158:	00001021 	move	v0,zero
9d00615c:	7c82b004 	ins	v0,a0,0x0,0x17
9d006160:	7c62f5c4 	ins	v0,v1,0x17,0x8
9d006164:	03e00008 	jr	ra
9d006168:	7ca2ffc4 	ins	v0,a1,0x1f,0x1
9d00616c:	1860002e 	blez	v1,9d006228 <__truncdfsf2+0x158>
9d006170:	00042180 	sll	a0,a0,0x6
9d006174:	0004202b 	sltu	a0,zero,a0
9d006178:	00084742 	srl	t0,t0,0x1d
9d00617c:	00882025 	or	a0,a0,t0
9d006180:	000630c0 	sll	a2,a2,0x3
9d006184:	2442fc81 	addiu	v0,v0,-895
9d006188:	00862025 	or	a0,a0,a2
9d00618c:	3087000f 	andi	a3,a0,0xf
9d006190:	24060004 	li	a2,4
9d006194:	10e6ffe1 	beq	a3,a2,9d00611c <__truncdfsf2+0x4c>
9d006198:	7c860680 	ext	a2,a0,0x1a,0x1
9d00619c:	24840004 	addiu	a0,a0,4
9d0061a0:	0b401846 	j	9d006118 <__truncdfsf2+0x48>
9d0061a4:	24620001 	addiu	v0,v1,1
9d0061a8:	5080ffeb 	beqzl	a0,9d006158 <__truncdfsf2+0x88>
9d0061ac:	306300ff 	andi	v1,v1,0xff
9d0061b0:	5060ffe9 	beqzl	v1,9d006158 <__truncdfsf2+0x88>
9d0061b4:	7c84b000 	ext	a0,a0,0x0,0x17
9d0061b8:	3c020040 	lui	v0,0x40
9d0061bc:	00822025 	or	a0,a0,v0
9d0061c0:	0b401855 	j	9d006154 <__truncdfsf2+0x84>
9d0061c4:	7c84b000 	ext	a0,a0,0x0,0x17
9d0061c8:	1040000a 	beqz	v0,9d0061f4 <__truncdfsf2+0x124>
9d0061cc:	24030004 	li	v1,4
9d0061d0:	00c84025 	or	t0,a2,t0
9d0061d4:	5100ffce 	beqzl	t0,9d006110 <__truncdfsf2+0x40>
9d0061d8:	24020100 	li	v0,256
9d0061dc:	3c020200 	lui	v0,0x200
9d0061e0:	000630c0 	sll	a2,a2,0x3
9d0061e4:	00c22025 	or	a0,a2,v0
9d0061e8:	240300ff 	li	v1,255
9d0061ec:	0b401863 	j	9d00618c <__truncdfsf2+0xbc>
9d0061f0:	24020100 	li	v0,256
9d0061f4:	00c83025 	or	a2,a2,t0
9d0061f8:	24040005 	li	a0,5
9d0061fc:	0066200a 	movz	a0,v1,a2
9d006200:	24020001 	li	v0,1
9d006204:	0b401846 	j	9d006118 <__truncdfsf2+0x48>
9d006208:	00001821 	move	v1,zero
9d00620c:	00002021 	move	a0,zero
9d006210:	00001021 	move	v0,zero
9d006214:	240300ff 	li	v1,255
9d006218:	7c82b004 	ins	v0,a0,0x0,0x17
9d00621c:	7c62f5c4 	ins	v0,v1,0x17,0x8
9d006220:	03e00008 	jr	ra
9d006224:	7ca2ffc4 	ins	v0,a1,0x1f,0x1
9d006228:	2864ffe9 	slti	a0,v1,-23
9d00622c:	54800011 	bnezl	a0,9d006274 <__truncdfsf2+0x1a4>
9d006230:	24020001 	li	v0,1
9d006234:	2409001e 	li	t1,30
9d006238:	01234823 	subu	t1,t1,v1
9d00623c:	3c070080 	lui	a3,0x80
9d006240:	29240020 	slti	a0,t1,32
9d006244:	1080000e 	beqz	a0,9d006280 <__truncdfsf2+0x1b0>
9d006248:	00c73025 	or	a2,a2,a3
9d00624c:	2442fc82 	addiu	v0,v0,-894
9d006250:	00482004 	sllv	a0,t0,v0
9d006254:	00463004 	sllv	a2,a2,v0
9d006258:	0004202b 	sltu	a0,zero,a0
9d00625c:	01284006 	srlv	t0,t0,t1
9d006260:	00c42025 	or	a0,a2,a0
9d006264:	00882025 	or	a0,a0,t0
9d006268:	24020001 	li	v0,1
9d00626c:	0b401863 	j	9d00618c <__truncdfsf2+0xbc>
9d006270:	00001821 	move	v1,zero
9d006274:	24040005 	li	a0,5
9d006278:	0b401846 	j	9d006118 <__truncdfsf2+0x48>
9d00627c:	00001821 	move	v1,zero
9d006280:	2404fffe 	li	a0,-2
9d006284:	00831823 	subu	v1,a0,v1
9d006288:	24040020 	li	a0,32
9d00628c:	00661806 	srlv	v1,a2,v1
9d006290:	11240003 	beq	t1,a0,9d0062a0 <__truncdfsf2+0x1d0>
9d006294:	00003821 	move	a3,zero
9d006298:	2442fca2 	addiu	v0,v0,-862
9d00629c:	00463804 	sllv	a3,a2,v0
9d0062a0:	00e82025 	or	a0,a3,t0
9d0062a4:	0004202b 	sltu	a0,zero,a0
9d0062a8:	00832025 	or	a0,a0,v1
9d0062ac:	24020001 	li	v0,1
9d0062b0:	0b401863 	j	9d00618c <__truncdfsf2+0xbc>
9d0062b4:	00001821 	move	v1,zero

9d0062b8 <rand>:
9d0062b8:	3c02a000 	lui	v0,0xa000
9d0062bc:	8c4304f0 	lw	v1,1264(v0)
9d0062c0:	3c025851 	lui	v0,0x5851
9d0062c4:	3442f42d 	ori	v0,v0,0xf42d
9d0062c8:	8c6500a8 	lw	a1,168(v1)
9d0062cc:	8c6600ac 	lw	a2,172(v1)
9d0062d0:	3c044c95 	lui	a0,0x4c95
9d0062d4:	00a20018 	mult	a1,v0
9d0062d8:	24847f2d 	addiu	a0,a0,32557
9d0062dc:	70c40000 	madd	a2,a0
9d0062e0:	00001012 	mflo	v0
9d0062e4:	00a40019 	multu	a1,a0
9d0062e8:	00003012 	mflo	a2
9d0062ec:	24c40001 	addiu	a0,a2,1
9d0062f0:	0086282b 	sltu	a1,a0,a2
9d0062f4:	00003810 	mfhi	a3
9d0062f8:	ac6400a8 	sw	a0,168(v1)
9d0062fc:	00471021 	addu	v0,v0,a3
9d006300:	00a21021 	addu	v0,a1,v0
9d006304:	ac6200ac 	sw	v0,172(v1)
9d006308:	03e00008 	jr	ra
9d00630c:	7c42f000 	ext	v0,v0,0x0,0x1f

9d006310 <_general_exception_context>:
9d006310:	27bdffa8 	addiu	sp,sp,-88
9d006314:	afa10004 	sw	at,4(sp)
9d006318:	afa20008 	sw	v0,8(sp)
9d00631c:	afa3000c 	sw	v1,12(sp)
9d006320:	afa40010 	sw	a0,16(sp)
9d006324:	afa50014 	sw	a1,20(sp)
9d006328:	afa60018 	sw	a2,24(sp)
9d00632c:	afa7001c 	sw	a3,28(sp)
9d006330:	afa80020 	sw	t0,32(sp)
9d006334:	afa90024 	sw	t1,36(sp)
9d006338:	afaa0028 	sw	t2,40(sp)
9d00633c:	afab002c 	sw	t3,44(sp)
9d006340:	afac0030 	sw	t4,48(sp)
9d006344:	afad0034 	sw	t5,52(sp)
9d006348:	afae0038 	sw	t6,56(sp)
9d00634c:	afaf003c 	sw	t7,60(sp)
9d006350:	afb80040 	sw	t8,64(sp)
9d006354:	afb90044 	sw	t9,68(sp)
9d006358:	afbf0048 	sw	ra,72(sp)
9d00635c:	00004012 	mflo	t0
9d006360:	afa8004c 	sw	t0,76(sp)
9d006364:	00004010 	mfhi	t0
9d006368:	afa80050 	sw	t0,80(sp)
9d00636c:	40046800 	mfc0	a0,c0_cause
9d006370:	40056000 	mfc0	a1,c0_status
9d006374:	0f4018f8 	jal	9d0063e0 <_general_exception_handler>
9d006378:	00000000 	nop
9d00637c:	8fa80050 	lw	t0,80(sp)
9d006380:	01000011 	mthi	t0
9d006384:	8fa8004c 	lw	t0,76(sp)
9d006388:	01000013 	mtlo	t0
9d00638c:	8fa10004 	lw	at,4(sp)
9d006390:	8fa20008 	lw	v0,8(sp)
9d006394:	8fa3000c 	lw	v1,12(sp)
9d006398:	8fa40010 	lw	a0,16(sp)
9d00639c:	8fa50014 	lw	a1,20(sp)
9d0063a0:	8fa60018 	lw	a2,24(sp)
9d0063a4:	8fa7001c 	lw	a3,28(sp)
9d0063a8:	8fa80020 	lw	t0,32(sp)
9d0063ac:	8fa90024 	lw	t1,36(sp)
9d0063b0:	8faa0028 	lw	t2,40(sp)
9d0063b4:	8fab002c 	lw	t3,44(sp)
9d0063b8:	8fac0030 	lw	t4,48(sp)
9d0063bc:	8fad0034 	lw	t5,52(sp)
9d0063c0:	8fae0038 	lw	t6,56(sp)
9d0063c4:	8faf003c 	lw	t7,60(sp)
9d0063c8:	8fb80040 	lw	t8,64(sp)
9d0063cc:	8fb90044 	lw	t9,68(sp)
9d0063d0:	8fbf0048 	lw	ra,72(sp)
9d0063d4:	27bd0058 	addiu	sp,sp,88
9d0063d8:	000000c0 	ehb
9d0063dc:	42000018 	eret

9d0063e0 <_general_exception_handler>:
9d0063e0:	0b4018f8 	j	9d0063e0 <_general_exception_handler>
9d0063e4:	00000000 	nop

9d0063e8 <_on_reset>:
9d0063e8:	03e00008 	jr	ra
9d0063ec:	00000000 	nop

9d0063f0 <_on_bootstrap>:
9d0063f0:	03e00008 	jr	ra
9d0063f4:	00000000 	nop

9d0063f8 <_nmi_handler>:
9d0063f8:	401a6000 	mfc0	k0,c0_status
9d0063fc:	3c1bffbf 	lui	k1,0xffbf
9d006400:	377bffff 	ori	k1,k1,0xffff
9d006404:	035bd024 	and	k0,k0,k1
9d006408:	409a6000 	mtc0	k0,c0_status
9d00640c:	42000018 	eret

9d006410 <__do_global_ctors_aux>:
9d006410:	3c029d00 	lui	v0,0x9d00
9d006414:	8c4264ac 	lw	v0,25772(v0)
9d006418:	27bdffe0 	addiu	sp,sp,-32
9d00641c:	2403ffff 	li	v1,-1
9d006420:	afbf001c 	sw	ra,28(sp)
9d006424:	afb10018 	sw	s1,24(sp)
9d006428:	10430009 	beq	v0,v1,9d006450 <__do_global_ctors_aux+0x40>
9d00642c:	afb00014 	sw	s0,20(sp)
9d006430:	3c119d00 	lui	s1,0x9d00
9d006434:	263164ac 	addiu	s1,s1,25772
9d006438:	2410ffff 	li	s0,-1
9d00643c:	0040f809 	jalr	v0
9d006440:	2631fffc 	addiu	s1,s1,-4
9d006444:	8e220000 	lw	v0,0(s1)
9d006448:	1450fffc 	bne	v0,s0,9d00643c <__do_global_ctors_aux+0x2c>
9d00644c:	00000000 	nop
9d006450:	8fbf001c 	lw	ra,28(sp)
9d006454:	8fb10018 	lw	s1,24(sp)
9d006458:	8fb00014 	lw	s0,20(sp)
9d00645c:	03e00008 	jr	ra
9d006460:	27bd0020 	addiu	sp,sp,32

Disassembly of section .init:

9d006464 <_init>:
9d006464:	27bdffe0 	addiu	sp,sp,-32
9d006468:	afbf0014 	sw	ra,20(sp)
9d00646c:	0f4004b3 	jal	9d0012cc <frame_dummy>
9d006470:	00000000 	nop
9d006474:	0f401904 	jal	9d006410 <__do_global_ctors_aux>
9d006478:	00000000 	nop
9d00647c:	8fbf0014 	lw	ra,20(sp)
9d006480:	03e00008 	jr	ra
9d006484:	27bd0020 	addiu	sp,sp,32

Disassembly of section .fini:

9d006488 <_fini>:
9d006488:	27bdffe0 	addiu	sp,sp,-32
9d00648c:	afbf0014 	sw	ra,20(sp)
9d006490:	0f400484 	jal	9d001210 <__do_global_dtors_aux>
9d006494:	00000000 	nop
9d006498:	8fbf0014 	lw	ra,20(sp)
9d00649c:	03e00008 	jr	ra
9d0064a0:	27bd0020 	addiu	sp,sp,32
